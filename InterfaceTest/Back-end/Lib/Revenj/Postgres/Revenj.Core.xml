<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Revenj.Core</name>
    </assembly>
    <members>
        <member name="M:Revenj.Extensibility.Autofac.Util.TypeExtensions.GetTypesThatClose(System.Type,System.Type)">
            <summary>Returns the first concrete interface supported by the candidate type that
            closes the provided open generic service type.</summary>
            <param name="this">The type that is being checked for the interface.</param>
            <param name="openGeneric">The open generic type to locate.</param>
            <returns>The type of the interface.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Util.TypeExtensions.FindAssignableTypesThatClose(System.Type,System.Type)">
            <summary>
            Looks for an interface on the candidate type that closes the provided open generic interface type.
            </summary>
            <param name="candidateType">The type that is being checked for the interface.</param>
            <param name="openGenericServiceType">The open generic service type to locate.</param>
            <returns>True if a closed implementation was found; otherwise false.</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Features.OwnedInstances.Owned`1">
            <summary>
            Represents a dependency that can be released by the dependent component.
            </summary>
            <typeparam name="T">The service provided by the dependency.</typeparam>
            <remarks>
            <para>
            Autofac automatically provides instances of <see cref="T:Revenj.Extensibility.Autofac.Features.OwnedInstances.Owned`1"/> whenever the
            service <typeparamref name="T"/> is registered.
            </para>
            <para>
            It is not necessary for <typeparamref name="T"/>, or the underlying component, to implement <see cref="T:System.IDisposable"/>.
            Disposing of the <see cref="T:Revenj.Extensibility.Autofac.Features.OwnedInstances.Owned`1"/> object is the correct way to handle cleanup of the dependency,
            as this will dispose of any other components created indirectly as well.
            </para>
            <para>
            When <see cref="T:Revenj.Extensibility.Autofac.Features.OwnedInstances.Owned`1"/> is resolved, a new <see cref="T:Revenj.Extensibility.Autofac.ILifetimeScope"/> is created for the
            underlying <typeparamref name="T"/>, and tagged with the service matching <typeparamref name="T"/>,
            generally a <see cref="T:Revenj.Extensibility.Autofac.Core.TypedService"/>. This means that shared instances can be tied to this
            scope by registering them as InstancePerMatchingLifetimeScope(new TypedService(typeof(T))).
            </para>
            </remarks>
            <example>
            The component D below is disposable and implements IService:
            <code>
            public class D : IService, IDisposable
            {
              // ...
            }
            </code>
            The dependent component C can dispose of the D instance whenever required by taking a dependency on
            <see cref="T:Revenj.Extensibility.Autofac.Features.OwnedInstances.Owned`1"/>:
            <code>
            public class C
            {
              IService _service;
              
              public C(Owned&lt;IService&gt; service)
              {
                _service = service;
              }
              
              void DoWork()
              {
                _service.Value.DoSomething();
              }
              
              void OnFinished()
              {
                _service.Dispose();
              }
            }
            </code>
            In general, rather than depending on <see cref="T:Revenj.Extensibility.Autofac.Features.OwnedInstances.Owned`1"/> directly, components will depend on
            System.Func&lt;Owned&lt;T&gt;&gt; in order to create and dispose of other components as required.
            </example>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Util.Disposable">
            <summary>
            Base class for disposable objects.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Util.Disposable.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Util.Disposable.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Util.Disposable.IsDisposed">
            <summary>
            Returns true if the current instance has been disposed; otherwise false;
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.OwnedInstances.Owned`1.#ctor(`0,System.IDisposable)">
            <summary>
            Create an instance of <see cref="T:Revenj.Extensibility.Autofac.Features.OwnedInstances.Owned`1"/>.
            </summary>
            <param name="value">The value representing the instance.</param>
            <param name="lifetime">An IDisposable interface through which ownership can be released.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.OwnedInstances.Owned`1.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Features.OwnedInstances.Owned`1.Value">
            <summary>
            The owned value.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Features.OpenGenerics.OpenGenericRegistrationSource">
            <summary>
            Generates activators for open generic types.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.IRegistrationSource">
            <summary>
            Allows registrations to be made on-the-fly when unregistered
            services are requested (lazy registrations.)
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.IRegistrationSource.RegistrationsFor(Revenj.Extensibility.Autofac.Core.Service,System.Func{Revenj.Extensibility.Autofac.Core.Service,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.IComponentRegistration}})">
            <summary>
            Retrieve registrations for an unregistered service, to be used
            by the container.
            </summary>
            <param name="service">The service that was requested.</param>
            <param name="registrationAccessor">A function that will return existing registrations for a service.</param>
            <returns>Registrations providing the service.</returns>
            <remarks>
            If the source is queried for service s, and it returns a component that implements both s and s', then it
            will not be queried again for either s or s'. This means that if the source can return other implementations
            of s', it should return these, plus the transitive closure of other components implementing their 
            additional services, along with the implementation of s. It is not an error to return components
            that do not implement <paramref name="service"/>.
            </remarks>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IRegistrationSource.IsAdapterForIndividualComponents">
            <summary>
            Gets whether the registrations provided by this source are 1:1 adapters on top
            of other components (I.e. like Meta, Func or Owned.)
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Resolving.IInstanceLookup">
            <summary>
            Represents the process of finding a component during a resolve operation.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Resolving.IInstanceLookup.ComponentRegistration">
            <summary>
            The component for which an instance is to be looked up.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Resolving.IInstanceLookup.ActivationScope">
            <summary>
            The scope in which the instance will be looked up.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Resolving.IInstanceLookup.Parameters">
            <summary>
            The parameters provided for new instance creation.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Resolving.IInstanceLookup.Factory">
            <summary>
            Factory to create an instance
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Resolving.IInstanceLookup.Preparing">
            <summary>
            Preparing instance
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Resolving.IInstanceLookup.Activating">
            <summary>
            Activating instance
            </summary>
        </member>
        <member name="E:Revenj.Extensibility.Autofac.Core.Resolving.IInstanceLookup.SharedInstanceActivation">
            <summary>
            When shared instance is activated
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Registration.ScopeRestrictedRegistry">
            <summary>
            Switches components with a RootScopeLifetime (singletons) with
            decorators exposing MatchingScopeLifetime targeting the specified scope.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistry">
            <summary>
            Maps services onto the components that provide them.
            </summary>
            <remarks>
            The component registry provides services directly from components,
            and also uses <see cref="T:Revenj.Extensibility.Autofac.Core.IRegistrationSource"/> to generate components
            on-the-fly or as adapters for other components. A component registry
            is normally used through a <see cref="T:Revenj.Extensibility.Autofac.ContainerBuilder"/>, and not
            directly by application code.
            </remarks>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.IComponentRegistry">
            <summary>
            Provides component registrations according to the services they provide.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.IComponentRegistry.TryGetRegistration(Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.Core.IComponentRegistration@)">
            <summary>
            Attempts to find a default registration for the specified service.
            </summary>
            <param name="service">The service to look up.</param>
            <param name="registration">The default registration for the service.</param>
            <returns>True if a registration exists.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.IComponentRegistry.IsRegistered(Revenj.Extensibility.Autofac.Core.Service)">
            <summary>
            Determines whether the specified service is registered.
            </summary>
            <param name="service">The service to test.</param>
            <returns>True if the service is registered.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.IComponentRegistry.Register(Revenj.Extensibility.Autofac.Core.IComponentRegistration)">
            <summary>
            Register a component.
            </summary>
            <param name="registration">The component registration.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.IComponentRegistry.Register(Revenj.Extensibility.Autofac.Core.IComponentRegistration,System.Boolean)">
            <summary>
            Register a component.
            </summary>
            <param name="registration">The component registration.</param>
            <param name="preserveDefaults">If true, existing defaults for the services provided by the
            component will not be changed.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.IComponentRegistry.RegistrationsFor(Revenj.Extensibility.Autofac.Core.Service)">
            <summary>
            Selects from the available registrations after ensuring that any
            dynamic registration sources that may provide <paramref name="service"/>
            have been invoked.
            </summary>
            <param name="service">The service for which registrations are sought.</param>
            <returns>Registrations supporting <paramref name="service"/>.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.IComponentRegistry.AddRegistrationSource(Revenj.Extensibility.Autofac.Core.IRegistrationSource)">
            <summary>
            Add a registration source that will provide registrations on-the-fly.
            </summary>
            <param name="source">The source to register.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IComponentRegistry.Registrations">
            <summary>
            Enumerate the registered components.
            </summary>
        </member>
        <member name="E:Revenj.Extensibility.Autofac.Core.IComponentRegistry.Registered">
            <summary>
            Fired whenever a component is registered - either explicitly or via a
            <see cref="T:Revenj.Extensibility.Autofac.Core.IRegistrationSource"/>.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IComponentRegistry.Sources">
            <summary>
            Gets the registration sources that are used by the registry.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IComponentRegistry.HasLocalComponents">
            <summary>
            True if the registry contains its own components; false if it is forwarding
            registrations from another external registry.
            </summary>
            <remarks>This property is used when walking up the scope tree looking for
            registrations for a new customised scope. (See issue 336.)</remarks>
        </member>
        <member name="E:Revenj.Extensibility.Autofac.Core.IComponentRegistry.RegistrationSourceAdded">
            <summary>
            Fired when an <see cref="T:Revenj.Extensibility.Autofac.Core.IRegistrationSource"/> is added to the registry.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistry._synchRoot">
            <summary>
            Protects instance variables from concurrent access.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistry._dynamicRegistrationSources">
            <summary>
            External registration sources.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistry._registrations">
            <summary>
            All registrations.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistry._serviceInfo">
            <summary>
            Keeps track of the status of registered services.
            TODO: this should be populated on build
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistry.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistry.TryGetRegistration(Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.Core.IComponentRegistration@)">
            <summary>
            Attempts to find a default registration for the specified service.
            </summary>
            <param name="service">The service to look up.</param>
            <param name="registration">The default registration for the service.</param>
            <returns>True if a registration exists.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistry.IsRegistered(Revenj.Extensibility.Autofac.Core.Service)">
            <summary>
            Determines whether the specified service is registered.
            </summary>
            <param name="service">The service to test.</param>
            <returns>True if the service is registered.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistry.Register(Revenj.Extensibility.Autofac.Core.IComponentRegistration)">
            <summary>
            Register a component.
            </summary>
            <param name="registration">The component registration.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistry.Register(Revenj.Extensibility.Autofac.Core.IComponentRegistration,System.Boolean)">
            <summary>
            Register a component.
            </summary>
            <param name="registration">The component registration.</param>
            <param name="preserveDefaults">If true, existing defaults for the services provided by the
            component will not be changed.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistry.RegistrationsFor(Revenj.Extensibility.Autofac.Core.Service)">
            <summary>
            Selects from the available registrations after ensuring that any
            dynamic registration sources that may provide <paramref name="service"/>
            have been invoked.
            </summary>
            <param name="service">The service for which registrations are sought.</param>
            <returns>Registrations supporting <paramref name="service"/>.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistry.AddRegistrationSource(Revenj.Extensibility.Autofac.Core.IRegistrationSource)">
            <summary>
            Add a registration source that will provide registrations on-the-fly.
            </summary>
            <param name="source">The source to register.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistry.Registrations">
            <summary>
            Enumerate the registered components.
            </summary>
        </member>
        <member name="E:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistry.Registered">
            <summary>
            Fired whenever a component is registered - either explicitly or via a
            <see cref="T:Revenj.Extensibility.Autofac.Core.IRegistrationSource"/>.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistry.Sources">
            <summary>
            Gets the registration sources that are used by the registry.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistry.HasLocalComponents">
            <summary>
            True if the registry contains its own components; false if it is forwarding
            registrations from another external registry.
            </summary>
            <remarks>This property is used when walking up the scope tree looking for
            registrations for a new customised scope. (See issue 336.)</remarks>
        </member>
        <member name="E:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistry.RegistrationSourceAdded">
            <summary>
            Fired when an <see cref="T:Revenj.Extensibility.Autofac.Core.IRegistrationSource"/> is added to the registry.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Lifetime.MatchingScopeLifetime">
            <summary>
            Attaches the component's lifetime to scopes matching a supplied expression.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.IComponentLifetime">
            <summary>
            Locates the lifetime to which instances of a component should be attached.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.IComponentLifetime.FindScope(Revenj.Extensibility.Autofac.Core.ISharingLifetimeScope)">
            <summary>
            Given the most nested scope visible within the resolve operation, find
            the scope for the component.
            </summary>
            <param name="mostNestedVisibleScope">The most nested visible scope.</param>
            <returns>The scope for the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Lifetime.MatchingScopeLifetime.#ctor(System.Linq.Expressions.Expression{System.Func{Revenj.Extensibility.Autofac.ILifetimeScope,System.Boolean}})">
            <summary>
            Match scopes based on the provided expression.
            </summary>
            <param name="matchExpression">Expression describing scopes that will match.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Lifetime.MatchingScopeLifetime.#ctor(System.Object)">
            <summary>
            Match scopes by comparing tags for equality.
            </summary>
            <param name="lifetimeScopeTagToMatch">The tag applied to matching scopes.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Lifetime.MatchingScopeLifetime.FindScope(Revenj.Extensibility.Autofac.Core.ISharingLifetimeScope)">
            <summary>
            Given the most nested scope visible within the resolve operation, find
            the scope for the component.
            </summary>
            <param name="mostNestedVisibleScope">The most nested visible scope.</param>
            <returns>The scope for the component.</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.ConstantParameter">
            <summary>
            Base class for parameters that provide a constant value.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Parameter">
            <summary>
            Used in order to provide a value to a constructor parameter or property on an instance
            being created by the container.
            </summary>
            <remarks>
            Not all parameters can be applied to all sites.
            </remarks>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Parameter.CanSupplyValue(System.Reflection.ParameterInfo,Revenj.Extensibility.Autofac.IComponentContext,System.Func{System.Object}@)">
            <summary>
            Returns true if the parameter is able to provide a value to a particular site.
            </summary>
            <param name="pi">Constructor, method, or property-mutator parameter.</param>
            <param name="context">The component context in which the value is being provided.</param>
            <param name="valueProvider">If the result is true, the valueProvider parameter will
            be set to a function that will lazily retrieve the parameter value. If the result is false,
            will be set to null.</param>
            <returns>True if a value can be supplied; otherwise, false.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.ConstantParameter.#ctor(System.Object,System.Predicate{System.Reflection.ParameterInfo})">
            <summary>
            Create a constant parameter that will apply to parameters matching
            the supplied predicate.
            </summary>
            <param name="value"></param>
            <param name="predicate"></param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.ConstantParameter.CanSupplyValue(System.Reflection.ParameterInfo,Revenj.Extensibility.Autofac.IComponentContext,System.Func{System.Object}@)">
            <summary>
            Returns true if the parameter is able to provide a value to a particular site.
            </summary>
            <param name="pi">Constructor, method, or property-mutator parameter.</param>
            <param name="context">The component context in which the value is being provided.</param>
            <param name="valueProvider">If the result is true, the valueProvider parameter will
            be set to a function that will lazily retrieve the parameter value. If the result is false,
            will be set to null.</param>
            <returns>True if a value can be supplied; otherwise, false.</returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.ConstantParameter.Value">
            <summary>
            The value of the parameter.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.MetadataElementCollection">
            <summary>
            Collection of extended property elements.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.NamedConfigurationElementCollection`1">
            <summary>
            Base for multi-valued configuration elements.
            </summary>
            <typeparam name="TElementType"></typeparam>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.NamedConfigurationElementCollection`1.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Configuration.NamedConfigurationElementCollection`1"/> class.
            </summary>
            <param name="elementName">Name of the element.</param>
            <param name="elementKey">The element key.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.NamedConfigurationElementCollection`1.IsElementName(System.String)">
            <summary>
            Indicates whether the specified <see cref="T:System.Configuration.ConfigurationElement"/> exists in the <see cref="T:System.Configuration.ConfigurationElementCollection"/>.
            </summary>
            <param name="elementName">The name of the element to verify.</param>
            <returns>
            true if the element exists in the collection; otherwise, false. The default is false.
            </returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.NamedConfigurationElementCollection`1.CreateNewElement">
            <summary>
            Creates a new <see cref="T:System.Configuration.ConfigurationElement"/>.
            </summary>
            <returns>
            A new <see cref="T:System.Configuration.ConfigurationElement"/>.
            </returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.NamedConfigurationElementCollection`1.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary>
            Gets the element key for a specified configuration element when overridden in a derived class.
            </summary>
            <param name="element">The <see cref="T:System.Configuration.ConfigurationElement"/> to return the key for.</param>
            <returns>
            An <see cref="T:System.Object"/> that acts as the key for the specified <see cref="T:System.Configuration.ConfigurationElement"/>.
            </returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.NamedConfigurationElementCollection`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.NamedConfigurationElementCollection`1.ElementName">
            <summary>
            Gets the name used to identify this collection of elements in the configuration file when overridden in a derived class.
            </summary>
            <value></value>
            <returns>The name of the collection; otherwise, an empty string. The default is an empty string.</returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.NamedConfigurationElementCollection`1.CollectionType">
            <summary>
            Gets the type of the <see cref="T:System.Configuration.ConfigurationElementCollection"/>.
            </summary>
            <value></value>
            <returns>The <see cref="T:System.Configuration.ConfigurationElementCollectionType"/> of this collection.</returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.NamedConfigurationElementCollection`1.Item(System.Int32)">
            <summary>
            Gets or sets the TElementType at the specified index.
            </summary>
            <value></value>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.MetadataElementCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Configuration.PropertyElementCollection"/> class.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.DictionaryElementCollection">
            <summary>
            Holds a dictionary of values for those properties/parameters that are a dictionary
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.DictionaryElementCollection.DictionaryElementTypeConverter">
            <summary>
            Helps convert the configuration element into an actuall generic list
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Builder.ContainerBuildOptions">
            <summary>
            Parameterises the construction of a container by a <see cref="T:Revenj.Extensibility.Autofac.ContainerBuilder"/>.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Builder.ContainerBuildOptions.None">
            <summary>
            No options.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Builder.ContainerBuildOptions.Default">
            <summary>
            Standard container construction.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Builder.ContainerBuildOptions.ExcludeDefaultModules">
            <summary>
            Prevents inclusion of standard modules like support for
            relationship types including <see cref="T:System.Collections.Generic.IEnumerable`1"/> etc.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Builder.ContainerBuildOptions.IgnoreStartableComponents">
            <summary>
            Does not call <see cref="M:Revenj.Extensibility.Autofac.IStartable.Start"/> on components implementing
            this interface (useful for module testing.)
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlState">
            <summary> This class represents the base class for the state pattern design pattern
             implementation.
             </summary>
            
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlState.ChangeState(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector,Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlState)">
            <summary>
            This method is used by the states to change the state of the context.
             </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlState.ProcessBackendResponses(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector)">
            <summary>
             This method is responsible to handle all protocol messages sent from the backend.
             It holds all the logic to do it.
             To exchange data, it uses a Mediator object from which it reads/writes information
             to handle backend requests.
             </summary>
            
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlState.ProcessBackendResponsesEnum(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector,System.Boolean)">
            <summary>
             This method is responsible to handle all protocol messages sent from the backend.
             It holds all the logic to do it.
             To exchange data, it uses a Mediator object from which it reads/writes information
             to handle backend requests.
             </summary>
            
        </member>
        <!-- Badly formed XML comment ignored for member "M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlState.CheckForContextSocketAvailability(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector,System.Net.Sockets.SelectMode)" -->
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlClosedState.ResolveIPHost(System.String)">
            <summary>
            Resolve a host name or IP address.
            This is needed because if you call Dns.Resolve() with an IP address, it will attempt
            to resolve it as a host name, when it should just convert it to an IP address.
            </summary>
            <param name="HostName"></param>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.PGUtil">
            <summary>
             This class provides many util methods to handle
             reading and writing of PostgreSQL protocol messages.
             </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.PGUtil.ExtractServerVersion(System.String)">
            <summary>
            This method takes a version string as returned by SELECT VERSION() and returns
            a valid version string ("7.2.2" for example).
            This is only needed when running protocol version 2.
            This does not do any validity checks.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.PGUtil.ReadString(System.IO.Stream,Revenj.DatabasePersistence.Postgres.Npgsql.ByteBuffer)">
            <summary>
             This method gets a C NULL terminated string from the network stream.
             It keeps reading a byte in each time until a NULL byte is returned.
             It returns the resultant string of bytes read.
             This string is sent from backend.
             </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.PGUtil.ReadBytes(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads requested number of bytes from stream with retries until Stream.Read returns 0 or count is reached.
            </summary>
            <param name="stream">Stream to read</param>
            <param name="buffer">byte buffer to fill</param>
            <param name="offset">starting position to fill the buffer</param>
            <param name="count">number of bytes to read</param>
            <returns>The number of bytes read.  May be less than count if no more bytes are available.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.PGUtil.WriteString(System.String,System.IO.Stream)">
            <summary>
             This method writes a C NULL terminated string to the network stream.
             It appends a NULL terminator to the end of the String.
             </summary>
            <summary>
             This method writes a C NULL terminated string to the network stream.
             It appends a NULL terminator to the end of the String.
             </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.PGUtil.WriteBytes(System.Byte[],System.IO.Stream)">
            <summary>
            This method writes a set of bytes to the stream. It also enables logging of them.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.PGUtil.WriteLimString(System.String,System.Int32,System.IO.Stream)">
            <summary>
             This method writes a C NULL terminated string limited in length to the
             backend server.
             It pads the string with null bytes to the size specified.
             </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.PGUtil.WriteInt32(System.IO.Stream,System.Int32)">
            <summary>
            Write a 32-bit integer to the given stream in the correct byte order.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.PGUtil.ReadInt32(System.IO.Stream,System.Byte[])">
            <summary>
            Read a 32-bit integer from the given stream in the correct byte order.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.PGUtil.WriteInt16(System.IO.Stream,System.Int16)">
            <summary>
            Write a 16-bit integer to the given stream in the correct byte order.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.PGUtil.ReadInt16(System.IO.Stream,System.Byte[])">
            <summary>
            Read a 16-bit integer from the given stream in the correct byte order.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlBind">
             <summary>
             This class represents the Bind message sent to PostgreSQL
             server.
             </summary>
            
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.ClientMessage">
            <summary>
            For classes representing messages sent from the client to the server.
            </summary>
        </member>
        <member name="T:Revenj.Utility.BufferedTextReader">
            <summary>
            Performant text reader.
            Should be reused whenever possible.
            </summary>
        </member>
        <member name="F:Revenj.Utility.BufferedTextReader.SmallBuffer">
            <summary>
            Temporary small char buffer for reuse
            </summary>
        </member>
        <member name="F:Revenj.Utility.BufferedTextReader.CharBuffer">
            <summary>
            Temporary char buffer for reuse
            </summary>
        </member>
        <member name="F:Revenj.Utility.BufferedTextReader.ByteBuffer">
            <summary>
            Temporary byte buffer for reuse (1024 bytes total)
            </summary>
        </member>
        <member name="F:Revenj.Utility.BufferedTextReader.LargeTempBuffer">
            <summary>
            Temporary large temp buffer for reuse (32768 chars total)
            </summary>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.#ctor(System.IO.TextReader,System.Char[],System.Char[])">
            <summary>
            Allocate reader by reusing part of the buffers and providing original reader object.
            </summary>
            <param name="reader"></param>
            <param name="smallBuffer"></param>
            <param name="tempBuffer"></param>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.#ctor(System.String,System.Char[],System.Char[])">
            <summary>
            Allocate reader by reusing part of the buffers and providing original string object
            </summary>
            <param name="value"></param>
            <param name="smallBuffer"></param>
            <param name="tempBuffer"></param>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.Reuse(System.IO.TextReader)">
            <summary>
            Reuse existing instance with a new reader
            </summary>
            <param name="reader">new reader to process</param>
            <returns>itself</returns>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.Reuse(System.String)">
            <summary>
            Reuse existing instance with a new string
            </summary>
            <param name="value">new string to process</param>
            <returns>itself</returns>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.Peek">
            <summary>
            Read next char without changing position.
            Will return -1 on end of input
            </summary>
            <returns>next char</returns>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.Read">
            <summary>
            Read next char and move a single position
            Will return -1 on end of input
            </summary>
            <returns>next char</returns>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.Read(System.Int32)">
            <summary>
            Skip several chars and read only the last one.
            Don't use return value if total == 0
            Moves position by specified argument
            </summary>
            <param name="total">total chars to read</param>
            <returns>last char read</returns>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.InitBuffer">
            <summary>
            Reset buffer to starting position. 
            Buffer should be used to fill in small values which will be reconstructed after
            </summary>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.InitBuffer(System.Char)">
            <summary>
            Reset buffer to starting position and specify initial value.
            Buffer should be used to fill in small values which will be reconstructed after
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.FillUntil(System.Char)">
            <summary>
            Fill buffer until specified char is found.
            If end of input is detected, but char is not found, SerializationException will be thrown.
            </summary>
            <param name="match">char to found</param>
            <returns>how many chars were processed</returns>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.FillUntil(System.Char,System.Char)">
            <summary>
            Fill buffer until any of the specified chars is found.
            If end of input is detected, but chars are not found, SerializationException will be thrown.
            </summary>
            <param name="match1">char to found</param>
            <param name="match2">char to found</param>
            <returns>how many chars were processed</returns>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.FillUntil(System.IO.TextWriter,System.Char,System.Char)">
            <summary>
            Fill provided writer until any of the specified chars is found.
            If end of input is detected, but chars are not found, SerializationException will be thrown.
            </summary>
            <param name="writer">text writer to populate</param>
            <param name="match1">char to found</param>
            <param name="match2">char to found</param>
            <returns>how many chars were processed</returns>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.AddToBuffer(System.Char)">
            <summary>
            Append char to internal buffer.
            </summary>
            <param name="ch">char to add</param>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.BufferMatches(System.String)">
            <summary>
            Check if buffer matches provided string.
            Used as string comparison without new string allocation.
            </summary>
            <param name="reference">compare to</param>
            <returns>buffer matches string</returns>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.BufferHash">
            <summary>
            Current buffer hash.
            Used as string hashcode without allocating new string.
            Doesn't match string hashcode algorithm.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.BufferToString">
            <summary>
            Convert buffer to new string
            </summary>
            <returns>new string from populated buffer</returns>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.BufferToValue``1(System.Func{System.Char[],System.Int32,``0})">
            <summary>
            Convert buffer to an instance
            </summary>
            <param name="factory">converter</param>
            <returns>instance</returns>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.BufferToValue``1(System.Func{System.Char[],System.Int32,Revenj.Utility.BufferedTextReader,``0})">
            <summary>
            Convert buffer to an instance
            </summary>
            <param name="factory">converter</param>
            <returns>instance</returns>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.ReadUntil(System.Char[],System.Int32,System.Char)">
            <summary>
            Fill target char[] until specified char is found.
            If end of input is detected, but char is not found, SerializationException will be thrown.
            </summary>
            <param name="target">target array to fill</param>
            <param name="from">fill target array starting from specified position</param>
            <param name="match">char to found</param>
            <returns>how many chars were processed</returns>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.ReadUntil(System.Char[],System.Int32,System.Char,System.Char)">
            <summary>
            Fill target char[] until any of the specified chars is found.
            If end of input is detected, but chars are not found, SerializationException will be thrown.
            </summary>
            <param name="target">target array to fill</param>
            <param name="from">fill target array starting from specified position</param>
            <param name="match1">char to found</param>
            <param name="match2">char to found</param>
            <returns>how many chars were processed</returns>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.ReadNumber(System.Char[],System.Int32)">
            <summary>
            Fill target char[] while number chars are found.
            If end of input is detected, but chars are not found, SerializationException will be thrown.
            </summary>
            <param name="target">target array to fill</param>
            <param name="from">fill target array starting from specified position</param>
            <returns>how many chars were processed</returns>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.Read(System.Char[],System.Int32,System.Int32)">
            <summary>
            Fill target char[] starting at specified index and up to specified count.
            Returns how many chars were copied or -1 on end of input.
            Method is allowed to stop early if current buffer end is encountered.
            </summary>
            <param name="buffer">target array to fill</param>
            <param name="index">fill target array starting from specified position</param>
            <param name="count">maximum number</param>
            <returns>how many chars were copied or -1 for immediate end of input</returns>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.ReadBlock(System.Char[],System.Int32,System.Int32)">
            <summary>
            Fill target char[] starting at specified index and up to specified count.
            Returns how many chars were copied or -1 on end of input.
            Method is not allowed to stop early if current buffer end is encountered.
            Must read all available chars up to specified count
            </summary>
            <param name="buffer">target array to fill</param>
            <param name="index">fill target array starting from specified position</param>
            <param name="count">maximum number</param>
            <returns>how many chars were copied or -1 for immediate end of input</returns>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.ReadLine">
            <summary>
            Read a single line from input.
            </summary>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.ReadToEnd">
            <summary>
            Read input to end and convert to string
            </summary>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.Close">
            <summary>
            Close provided reader
            </summary>
        </member>
        <member name="M:Revenj.Utility.BufferedTextReader.Dispose(System.Boolean)">
            <summary>
            Dispose provided reader
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="P:Revenj.Utility.BufferedTextReader.Position">
            <summary>
            Current position.
            Sum of total processed buffers and position in the current buffer.
            </summary>
        </member>
        <member name="T:Revenj.Utility.ExpandoHelper">
            <summary>
            Utilities for expando object.
            </summary>
        </member>
        <member name="M:Revenj.Utility.ExpandoHelper.With(System.Dynamic.ExpandoObject,System.Action{System.Object})">
            <summary>
            Use dynamic syntax with ExpandoObject.
            </summary>
            <param name="eo">expando object</param>
            <param name="initialize">apply actions</param>
            <returns>self</returns>
        </member>
        <member name="M:Revenj.Utility.ExpandoHelper.AsExpando(System.Object)">
            <summary>
            Convert object to expando object.
            Copy properties from object using reflection.
            </summary>
            <param name="item">source instance</param>
            <returns>expando clone</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Resolving.InstanceLookupBeginningEventArgs">
            <summary>
            Fired when instance lookup is complete.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Resolving.InstanceLookupBeginningEventArgs.#ctor(Revenj.Extensibility.Autofac.Core.Resolving.IInstanceLookup)">
            <param name="instanceLookup">The instance lookup that is ending.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Resolving.InstanceLookupBeginningEventArgs.InstanceLookup">
            <summary>
            The instance lookup operation that is beginning.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.InstanceOwnership">
            <summary>
            Determines when instances supporting IDisposable are disposed.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Core.InstanceOwnership.ExternallyOwned">
            <summary>
            The lifetime scope does not dispose the instances.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Core.InstanceOwnership.OwnedByLifetimeScope">
            <summary>
            The instances are disposed when the lifetime scope is disposed.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.IInstanceActivator">
            <summary>
            Activates component instances.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.IInstanceActivator.GetFactory(Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Activate an instance in the provided context.
            </summary>
            <param name="context">Context in which to activate instances.</param>
            <param name="parameters">Parameters to the instance.</param>
            <returns>The activated instance.</returns>
            <remarks>
            The context parameter here should probably be ILifetimeScope in order to reveal Disposer,
            but will wait until implementing a concrete use case to make the decision
            </remarks>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IInstanceActivator.LimitType">
            <summary>
            The most specific type that the component instances are known to be castable to.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.InstanceActivatorHelper">
            <summary>
            Helper
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.InstanceActivatorHelper.ActivateInstance(Revenj.Extensibility.Autofac.Core.IInstanceActivator,Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Activate an instance in the provided context.
            </summary>
            <param name="activator">Activator</param>
            <param name="context">Context in which to activate instances.</param>
            <param name="parameters">Parameters to the instance.</param>
            <returns>The activated instance.</returns>
            <remarks>
            The context parameter here should probably be ILifetimeScope in order to reveal Disposer,
            but will wait until implementing a concrete use case to make the decision
            </remarks>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Container">
            <summary>
            Standard container implementation.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.IContainer">
            <summary>
            Creates, wires dependencies and manages lifetime for a set of components.
            Most instances of <see cref="T:Revenj.Extensibility.Autofac.IContainer"/> are created 
            by a <see cref="T:Revenj.Extensibility.Autofac.ContainerBuilder"/>.
            </summary>
            <example>
            <code>
            // See ContainerBuilder for the definition of the builder variable
            using (var container = builder.Build())
            {
                var program = container.Resolve&lt;Program&gt;();
                program.Run();
            }
            </code>
            </example>
            <remarks>
            Most <see cref="T:Revenj.Extensibility.Autofac.IContainer"/> functionality is provided by extension methods
            on the inherited <see cref="T:Revenj.Extensibility.Autofac.IComponentContext"/> interface.
            </remarks>
            <seealso cref="T:Revenj.Extensibility.Autofac.ILifetimeScope"/>
            <seealso cref="T:Revenj.Extensibility.Autofac.IComponentContext"/>
            <seealso cref="T:Revenj.Extensibility.Autofac.ResolutionExtensions"/>
            <seealso cref="T:Revenj.Extensibility.Autofac.ContainerBuilder"/>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.ILifetimeScope">
            <summary>
            An <see cref="T:Revenj.Extensibility.Autofac.ILifetimeScope"/> tracks the instantiation of component instances.
            It defines a boundary in which instances are shared and configured.
            Disposing an <see cref="T:Revenj.Extensibility.Autofac.ILifetimeScope"/> will dispose the components that were
            resolved through it.
            </summary>
            <example>
            <code>
            // See IContainer for definition of the container variable
            using (var requestScope = container.BeginLifetimeScope())
            {
                // Note that handler is resolved from requestScope, not
                // from the container:
                
                var handler = requestScope.Resolve&lt;IRequestHandler&gt;();
                handler.Handle(request);
                
                // When requestScope is disposed, all resources used in processing
                // the request will be released.
            }
            </code>
            </example>
            <remarks>
            All long-running applications should resolve components via an
            <see cref="T:Revenj.Extensibility.Autofac.ILifetimeScope"/>. Choosing the duration of the lifetime is application-
            specific. The standard Autofac WCF and ASP.NET/MVC integrations are already configured
            to create and release <see cref="T:Revenj.Extensibility.Autofac.ILifetimeScope"/>s as appropriate. For example, the
            ASP.NET integration will create and release an <see cref="T:Revenj.Extensibility.Autofac.ILifetimeScope"/> per HTTP
            request.
            Most <see cref="T:Revenj.Extensibility.Autofac.ILifetimeScope"/> functionality is provided by extension methods
            on the inherited <see cref="T:Revenj.Extensibility.Autofac.IComponentContext"/> interface.
            </remarks>
            <seealso cref="T:Revenj.Extensibility.Autofac.IContainer"/>
            <seealso cref="T:Revenj.Extensibility.Autofac.IComponentContext"/>
            <seealso cref="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.InstancePerMatchingLifetimeScope(System.Object)"/>
            <seealso cref="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.InstancePerLifetimeScope"/>
            <seealso cref="T:Revenj.Extensibility.Autofac.Core.InstanceSharing"/>
            <seealso cref="T:Revenj.Extensibility.Autofac.Core.IComponentLifetime"/>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.IComponentContext">
            <summary>
            The context in which a service can be accessed or a component's
            dependencies resolved. Disposal of a context will dispose any owned
            components.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.IComponentContext.ResolveLookup(Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.Core.IComponentRegistration,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Resolve an factory of the provided registration within the context.
            </summary>
            <param name="service">Service which is trying to be resolved</param>
            <param name="registration">The registration.</param>
            <param name="parameters">Parameters for the instance.</param>
            <returns>
            The component factory.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.IComponentContext.ComponentRegistry">
            <summary>
            Associates services with the components that provide them.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ILifetimeScope.BeginLifetimeScope">
            <summary>
            Begin a new nested scope. Component instances created via the new scope
            will be disposed along with it.
            </summary>
            <returns>A new lifetime scope.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ILifetimeScope.BeginLifetimeScope(System.Object)">
            <summary>
            Begin a new nested scope. Component instances created via the new scope
            will be disposed along with it.
            </summary>
            <param name="tag">The tag applied to the <see cref="T:Revenj.Extensibility.Autofac.ILifetimeScope"/>.</param>
            <returns>A new lifetime scope.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ILifetimeScope.BeginLifetimeScope(System.Action{Revenj.Extensibility.Autofac.ContainerBuilder})">
            <summary>
            Begin a new nested scope, with additional components available to it.
            Component instances created via the new scope
            will be disposed along with it.
            </summary>
            <remarks>
            The components registered in the sub-scope will be treated as though they were
            registered in the root scope, i.e., SingleInstance() components will live as long
            as the root scope.
            </remarks>
            <param name="configurationAction">Action on a <see cref="T:Revenj.Extensibility.Autofac.ContainerBuilder"/>
            that adds component registations visible only in the new scope.</param>
            <returns>A new lifetime scope.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ILifetimeScope.BeginLifetimeScope(System.Object,System.Action{Revenj.Extensibility.Autofac.ContainerBuilder})">
            <summary>
            Begin a new nested scope, with additional components available to it.
            Component instances created via the new scope
            will be disposed along with it.
            </summary>
            <remarks>
            The components registered in the sub-scope will be treated as though they were
            registered in the root scope, i.e., SingleInstance() components will live as long
            as the root scope.
            </remarks>
            <param name="tag">The tag applied to the <see cref="T:Revenj.Extensibility.Autofac.ILifetimeScope"/>.</param>
            <param name="configurationAction">Action on a <see cref="T:Revenj.Extensibility.Autofac.ContainerBuilder"/>
            that adds component registations visible only in the new scope.</param>
            <returns>A new lifetime scope.</returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.ILifetimeScope.Disposer">
            <summary>
            The disposer associated with this <see cref="T:Revenj.Extensibility.Autofac.ILifetimeScope"/>.
            Component instances can be associated with it manually if required.
            </summary>
            <remarks>Typical usage does not require interaction with this member- it
            is used when extending the container.</remarks>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.ILifetimeScope.Tag">
            <summary>
            The tag applied to the <see cref="T:Revenj.Extensibility.Autofac.ILifetimeScope"/>.
            </summary>
            <remarks>Tags allow a level in the lifetime hierarchy to be identified.
            In most applications, tags are not necessary.</remarks>
            <seealso cref="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.InstancePerMatchingLifetimeScope(System.Object)"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Container.#ctor">
            <summary>
            Create a new container.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Container.BeginLifetimeScope">
            <summary>
            Begin a new sub-scope. Instances created via the sub-scope
            will be disposed along with it.
            </summary>
            <returns>A new lifetime scope.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Container.BeginLifetimeScope(System.Object)">
            <summary>
            Begin a new sub-scope. Instances created via the sub-scope
            will be disposed along with it.
            </summary>
            <param name="tag">The tag applied to the <see cref="T:Revenj.Extensibility.Autofac.ILifetimeScope"/>.</param>
            <returns>A new lifetime scope.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Container.BeginLifetimeScope(System.Action{Revenj.Extensibility.Autofac.ContainerBuilder})">
            <summary>
            Begin a new nested scope, with additional components available to it.
            Component instances created via the new scope
            will be disposed along with it.
            </summary>
            <param name="configurationAction">Action on a <see cref="T:Revenj.Extensibility.Autofac.ContainerBuilder"/>
            that adds component registations visible only in the new scope.</param>
            <returns>A new lifetime scope.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Container.BeginLifetimeScope(System.Object,System.Action{Revenj.Extensibility.Autofac.ContainerBuilder})">
            <summary>
            Begin a new nested scope, with additional components available to it.
            Component instances created via the new scope
            will be disposed along with it.
            </summary>
            <param name="tag">The tag applied to the <see cref="T:Revenj.Extensibility.Autofac.ILifetimeScope"/>.</param>
            <param name="configurationAction">Action on a <see cref="T:Revenj.Extensibility.Autofac.ContainerBuilder"/>
            that adds component registations visible only in the new scope.</param>
            <returns>A new lifetime scope.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Container.ResolveLookup(Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.Core.IComponentRegistration,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Resolve an instance of the provided registration within the context.
            </summary>
            <param name="service">Service which is trying to be resolved</param>
            <param name="registration">The registration.</param>
            <param name="parameters">Parameters for the instance.</param>
            <returns>
            The component instance.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Container.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Container.System#IServiceProvider#GetService(System.Type)">
            <summary>
            Gets the service object of the specified type.
            </summary>
            <param name="serviceType">An object that specifies the type of service object 
            to get.</param>
            <returns>
            A service object of type <paramref name="serviceType"/>.-or- null if there is 
            no service object of type <paramref name="serviceType"/>.
            </returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Container.Empty">
            <summary>
            An empty container.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Container.Disposer">
            <summary>
            The disposer associated with this container. Instances can be associated
            with it manually if required.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Container.Tag">
            <summary>
            Tag applied to the lifetime scope.
            </summary>
            <remarks>The tag applied to this scope and the contexts generated when
            it resolves component dependencies.</remarks>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Container.ComponentRegistry">
            <summary>
            Associates services with the components that provide them.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Activators.Reflection.MostParametersConstructorSelector">
            <summary>
            Selects the constructor with the most parameters.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Activators.Reflection.IConstructorSelector">
            <summary>
            Selects the best constructor from a set of available constructors.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.Reflection.IConstructorSelector.SelectConstructorBinding(Revenj.Extensibility.Autofac.Core.Activators.Reflection.ConstructorParameterBinding[])">
            <summary>
            Selects the best constructor from the available constructors.
            </summary>
            <param name="constructorBindings">Available constructors.</param>
            <returns>The best constructor.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.Reflection.MostParametersConstructorSelector.SelectConstructorBinding(Revenj.Extensibility.Autofac.Core.Activators.Reflection.ConstructorParameterBinding[])">
            <summary>
            Selects the best constructor from the available constructors.
            </summary>
            <param name="constructorBindings">Available constructors.</param>
            <returns>The best constructor.</returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException">A single unambiguous match could not be chosen.</exception>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.PropertyElementCollection">
            <summary>
            Collection of property elements.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.PropertyElementCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Configuration.PropertyElementCollection"/> class.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.PropertyElementCollection.ToParameters">
            <summary>
            Convert to the Autofac parameter type.
            </summary>
            <returns>The parameters represented by this collection.</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.ConfigurationSettingsReader">
            <summary>
            Configures containers based upon app.config settings.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Module">
            <summary>
            Base class for user-defined modules. Modules can add a set of releated components
            to a container (<see cref="M:Revenj.Extensibility.Autofac.Module.Load(Revenj.Extensibility.Autofac.ContainerBuilder)"/>) or attach cross-cutting functionality
            to other components (<see cref="M:Revenj.Extensibility.Autofac.Module.AttachToComponentRegistration(Revenj.Extensibility.Autofac.Core.IComponentRegistry,Revenj.Extensibility.Autofac.Core.IComponentRegistration)"/>.
            Modules are given special support in the XML configuration feature - see
            http://code.google.com/p/autofac/wiki/StructuringWithModules.
            </summary>
            <remarks>Provides a user-friendly way to implement <see cref="T:Revenj.Extensibility.Autofac.Core.IModule"/>
            via <see cref="T:Revenj.Extensibility.Autofac.ContainerBuilder"/>.</remarks>
            <example>
            Defining a module:
            <code>
            public class DataAccessModule : Module
            {
                public string ConnectionString { get; set; }
                
                public override void Load(ContainerBuilder moduleBuilder)
                {
                    moduleBuilder.RegisterGeneric(typeof(MyRepository&lt;&gt;))
                        .As(typeof(IRepository&lt;&gt;))
                        .InstancePerMatchingLifetimeScope(WebLifetime.Request);
                    
                    moduleBuilder.Register(c =&gt; new MyDbConnection(ConnectionString))
                        .As&lt;IDbConnection&gt;()
                        .InstancePerMatchingLifetimeScope(WebLifetime.Request);
                }
            }
            </code>
            Using the module:
            <code>
            var builder = new ContainerBuilder();
            builder.RegisterModule(new DataAccessModule { ConnectionString = "..." });
            var container = builder.Build();
            var customers = container.Resolve&lt;IRepository&lt;Customer&gt;&gt;();
            </code>
            </example>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.IModule">
            <summary>
            Represents a set of components and related functionality
            packaged together.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.IModule.Configure(Revenj.Extensibility.Autofac.Core.IComponentRegistry)">
            <summary>
            Apply the module to the component registry.
            </summary>
            <param name="componentRegistry">Component registry to apply configuration to.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Module.Configure(Revenj.Extensibility.Autofac.Core.IComponentRegistry)">
            <summary>
            Apply the module to the component registry.
            </summary>
            <param name="componentRegistry">Component registry to apply configuration to.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Module.Load(Revenj.Extensibility.Autofac.ContainerBuilder)">
            <summary>
            Override to add registrations to the container.
            </summary>
            <remarks>
            Note that the ContainerBuilder parameter is unique to this module.
            </remarks>
            <param name="builder">The builder through which components can be
            registered.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Module.AttachToComponentRegistration(Revenj.Extensibility.Autofac.Core.IComponentRegistry,Revenj.Extensibility.Autofac.Core.IComponentRegistration)">
            <summary>
            Override to attach module-specific functionality to a
            component registration.
            </summary>
            <remarks>This method will be called for all existing <i>and future</i> component
            registrations - ordering is not important.</remarks>
            <param name="componentRegistry">The component registry.</param>
            <param name="registration">The registration to attach functionality to.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Module.AttachToRegistrationSource(Revenj.Extensibility.Autofac.Core.IComponentRegistry,Revenj.Extensibility.Autofac.Core.IRegistrationSource)">
            <summary>
            Override to perform module-specific processing on a registration source.
            </summary>
            <remarks>This method will be called for all existing <i>and future</i> sources
            - ordering is not important.</remarks>
            <param name="componentRegistry">The component registry into which the source was added.</param>
            <param name="registrationSource">The registration source.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Module.ThisAssembly">
            <summary>
            The assembly in which the concrete module type is located. To avoid bugs whereby deriving from a module will
            change the target assembly, this property can only be used by modules that inherit directly from
            <see cref="T:Revenj.Extensibility.Autofac.Module"/>.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Configuration.ConfigurationSettingsReader.DefaultSectionName">
            <summary>
            The default section name that will be searched for.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.ConfigurationSettingsReader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Configuration.ConfigurationSettingsReader"/> class.
            The reader will look for a 'autofac' section.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.ConfigurationSettingsReader.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Configuration.ConfigurationSettingsReader"/> class.
            </summary>
            <param name="sectionName">Name of the configuration section.</param>
            <param name="configurationFile">The configuration file.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.ConfigurationSettingsReader.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Configuration.ConfigurationSettingsReader"/> class.
            </summary>
            <param name="sectionName">Name of the configuration section.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.ConfigurationSettingsReader.Load(Revenj.Extensibility.Autofac.ContainerBuilder)">
            <summary>
            Override to add registrations to the container.
            </summary>
            <param name="builder">The builder.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.ConfigurationSettingsReader.SetInjectProperties``2(Revenj.Extensibility.Autofac.Configuration.ComponentElement,Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{System.Object,``0,``1})">
            <summary>
            Sets the property injection mode for the component.
            </summary>
            <param name="component">The component.</param>
            <param name="registrar">The registrar.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.ConfigurationSettingsReader.SetOwnership``2(Revenj.Extensibility.Autofac.Configuration.ComponentElement,Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{System.Object,``0,``1})">
            <summary>
            Sets the ownership model of the component.
            </summary>
            <param name="component">The component.</param>
            <param name="registrar">The registrar.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.ConfigurationSettingsReader.SetScope``2(Revenj.Extensibility.Autofac.Configuration.ComponentElement,Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{System.Object,``0,``1})">
            <summary>
            Sets the scope model for the component.
            </summary>
            <param name="component">The component.</param>
            <param name="registrar">The registrar.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.ConfigurationSettingsReader.LoadType(System.String,System.Reflection.Assembly)">
            <summary>
            Loads the type.
            </summary>
            <param name="typeName">Name of the type.</param>
            <param name="defaultAssembly">The default assembly.</param>
            <returns></returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ConfigurationSettingsReader.SectionHandler">
            <summary>
            Gets the section handler.
            </summary>
            <value>The section handler.</value>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Builder.SimpleActivatorData">
            <summary>
            An activator builder with no parameters.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Builder.IConcreteActivatorData">
            <summary>
            Activator data that can provide an IInstanceActivator instance.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.IConcreteActivatorData.Activator">
            <summary>
            The instance activator based on the provided data.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.SimpleActivatorData.#ctor(Revenj.Extensibility.Autofac.Core.IInstanceActivator)">
            <summary>
            Return the provided activator.
            </summary>
            <param name="activator">The activator to return.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.SimpleActivatorData.Activator">
            <summary>
            Gets the activator.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOutState">
            <summary>
            Represents an ongoing COPY TO STDOUT operation.
            Provides methods to read data from server or end the operation.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOutState.StartCopy(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector,Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyFormat)">
            <summary>
            Called from NpgsqlState.ProcessBackendResponses upon CopyOutResponse.
            If CopyStream is already set, it is used to write data received from server, after which the copy ends.
            Otherwise CopyStream is set to a readable NpgsqlCopyOutStream that receives data from server.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOutState.GetCopyData(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector)">
            <summary>
            Called from NpgsqlOutStream.Read to read copy data from server.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOutState.CopyFormat">
            <summary>
            Copy format information returned from server.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.HashAlgorithm.#ctor">
            <summary>
            Called from constructor of derived class.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.HashAlgorithm.Finalize">
            <summary>
            Finalizer for HashAlgorithm
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.HashAlgorithm.ComputeHash(System.Byte[])">
            <summary>
            Computes the entire hash of all the bytes in the byte array.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.HashAlgorithm.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, drives the hashing function.
            </summary>
            <param name="rgb"></param>
            <param name="start"></param>
            <param name="size"></param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.HashAlgorithm.HashFinal">
            <summary>
            When overridden in a derived class, this pads and hashes whatever data might be left in the buffers and then returns the hash created.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.HashAlgorithm.Initialize">
            <summary>
            When overridden in a derived class, initializes the object to prepare for hashing.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Used for stream chaining.  Computes hash as data passes through it.
            </summary>
            <param name="inputBuffer">The buffer from which to grab the data to be copied.</param>
            <param name="inputOffset">The offset into the input buffer to start reading at.</param>
            <param name="inputCount">The number of bytes to be copied.</param>
            <param name="outputBuffer">The buffer to write the copied data to.</param>
            <param name="outputOffset">At what point in the outputBuffer to write the data at.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Used for stream chaining.  Computes hash as data passes through it.  Finishes off the hash.
            </summary>
            <param name="inputBuffer">The buffer from which to grab the data to be copied.</param>
            <param name="inputOffset">The offset into the input buffer to start reading at.</param>
            <param name="inputCount">The number of bytes to be copied.</param>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.HashAlgorithm.CanTransformMultipleBlocks">
            <summary>
            Get whether or not the hash can transform multiple blocks at a time.
            Note: MUST be overriden if descendant can transform multiple block
            on a single call!
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.HashAlgorithm.Hash">
            <summary>
            Gets the previously computed hash.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.HashAlgorithm.HashSize">
            <summary>
            Returns the size in bits of the hash.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.HashAlgorithm.InputBlockSize">
            <summary>
            Must be overriden if not 1
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.HashAlgorithm.OutputBlockSize">
            <summary>
            Must be overriden if not 1
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlNoticeEventArgs">
            <summary>
            EventArgs class to send Notice parameters, which are just NpgsqlError's in a lighter context.
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlNoticeEventArgs.Notice">
            <summary>
            Notice information.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlError">
            <summary>
            This class represents the ErrorResponse and NoticeResponse
            message sent from PostgreSQL server.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlError.ToString">
            <summary>
            Return a string representation of this error object.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlError.Severity">
            <summary>
            Severity code.  All versions.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlError.Code">
            <summary>
            Error code.  PostgreSQL 7.4 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlError.Message">
            <summary>
            Terse error message.  All versions.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlError.Detail">
            <summary>
            Detailed error message.  PostgreSQL 7.4 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlError.Hint">
            <summary>
            Suggestion to help resolve the error.  PostgreSQL 7.4 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlError.Position">
            <summary>
            Position (one based) within the query string where the error was encounterd.  PostgreSQL 7.4 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlError.InternalPosition">
            <summary>
            Position (one based) within the query string where the error was encounterd.  This position refers to an internal command executed for example inside a PL/pgSQL function. PostgreSQL 7.4 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlError.InternalQuery">
            <summary>
            Internal query string where the error was encounterd.  This position refers to an internal command executed for example inside a PL/pgSQL function. PostgreSQL 7.4 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlError.Where">
            <summary>
            Trace back information.  PostgreSQL 7.4 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlError.File">
            <summary>
            Source file (in backend) reporting the error.  PostgreSQL 7.4 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlError.Line">
            <summary>
            Source file line number (in backend) reporting the error.  PostgreSQL 7.4 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlError.Routine">
            <summary>
            Source routine (in backend) reporting the error.  PostgreSQL 7.4 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlError.SchemaName">
            <summary>
            Schema name which relates to the error. PostgreSQL 9.3 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlError.TableName">
            <summary>
            Table name which relates to the error. PostgreSQL 9.3 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlError.ColumnName">
            <summary>
            Column name which relates to the error. PostgreSQL 9.3 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlError.DataTypeName">
            <summary>
            Data type of column which relates to the error. PostgreSQL 9.3 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlError.ConstraintName">
            <summary>
            Constraint name which relates to the error. PostgreSQL 9.3 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlError.ErrorSql">
            <summary>
            String containing the sql sent which produced this error.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOut">
            <summary>
            Represents a PostgreSQL COPY TO STDOUT operation with a corresponding SQL statement
            to execute against a PostgreSQL database
            and an associated stream used to write results to (if provided by user)
            or for reading the results (when generated by driver).
            Eg. new NpgsqlCopyOut("COPY (SELECT * FROM mytable) TO STDOUT", connection, streamToWrite).Start();
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOut.#ctor(System.String,Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection)">
            <summary>
            Creates NpgsqlCommand to run given query upon Start(), after which CopyStream provides data from database as requested in the query.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOut.#ctor(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand,Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection)">
            <summary>
            Given command is run upon Start(), after which CopyStream provides data from database as requested in the query.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOut.#ctor(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand,Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection,System.IO.Stream)">
            <summary>
            Given command is executed upon Start() and all requested copy data is written to toStream immediately.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOut.FieldIsBinary(System.Int32)">
            <summary>
            Returns true if this operation is currently active and field at given location is in binary format.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOut.Start">
            <summary>
            Command specified upon creation is executed as a non-query.
            If CopyStream is set upon creation, all copy data from server will be written to it, and operation will be finished immediately.
            Otherwise the CopyStream member can be used for reading copy data from server until no more data is available.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOut.End">
            <summary>
            Flush generated CopyStream at once. Effectively reads and discard all the rest of copy data from server.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOut.IsActive">
            <summary>
            Returns true if the connection is currently reserved for this operation.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOut.CopyStream">
            <summary>
            The stream provided by user or generated upon Start()
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOut.NpgsqlCommand">
            <summary>
            The Command used to execute this copy operation.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOut.IsBinary">
            <summary>
            Returns true if this operation is currently active and in binary format.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOut.FieldCount">
            <summary>
            Returns number of fields if this operation is currently active, otherwise -1
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOut.Read">
            <summary>
            Faster alternative to using the generated CopyStream.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.ParameterExtensions">
            <summary>
            Extension methods that simplify extraction of parameter values from
            an <see cref="T:System.Collections.Generic.IEnumerable`1"/> where T is <see cref="T:Revenj.Extensibility.Autofac.Core.Parameter"/>.
            Each method returns the first matching parameter value, or throws an exception if
            none is provided.
            </summary>
            <example>
            At configuration time, delegate registrations can retrieve parameter values using
            the methods <see cref="M:Revenj.Extensibility.Autofac.ParameterExtensions.Named``1(System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},System.String)"/>, <see cref="M:Revenj.Extensibility.Autofac.ParameterExtensions.Positional``1(System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},System.Int32)"/> and <see cref="M:Revenj.Extensibility.Autofac.ParameterExtensions.TypedAs``1(System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})"/>:
            <code>
            builder.Register((c, p) =&gt; new FtpClient(p.Named&lt;string&gt;("server")));
            </code>
            These parameters can be provided at resolution time:
            <code>
            container.Resolve&lt;FtpClient&gt;(new NamedParameter("server", "ftp.example.com"));
            </code>
            Alternatively, the parameters can be provided via a <i>Generated Factory</i> - http://code.google.com/p/autofac/wiki/DelegateFactories.
            </example>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ParameterExtensions.Named``1(System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},System.String)">
            <summary>
            Retrieve a named parameter value from a <see cref="T:Revenj.Extensibility.Autofac.NamedParameter"/> instance.
            </summary>
            <typeparam name="T">The type to which the returned value will be cast.</typeparam>
            <param name="parameters">The available parameters to choose from.</param>
            <param name="name">The name of the parameter to select.</param>
            <returns>The value of the selected parameter.</returns>
            <seealso cref="T:Revenj.Extensibility.Autofac.NamedParameter"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ParameterExtensions.Positional``1(System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},System.Int32)">
            <summary>
            Retrieve a positional parameter value from a <see cref="T:Revenj.Extensibility.Autofac.PositionalParameter"/> instance.
            </summary>
            <typeparam name="T">The type to which the returned value will be cast.</typeparam>
            <param name="parameters">The available parameters to choose from.</param>
            <param name="position">The zero-based position of the parameter to select.</param>
            <returns>The value of the selected parameter.</returns>
            <remarks>The position value is the one associated with the parameter when
            it was constructed, <b>not</b> its index into the <paramref name="parameters"/>
            sequence.</remarks>
            <seealso cref="T:Revenj.Extensibility.Autofac.PositionalParameter"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ParameterExtensions.TypedAs``1(System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Retrieve a typed parameter value from a <see cref="T:Revenj.Extensibility.Autofac.TypedParameter"/> instance.
            </summary>
            <typeparam name="T">The type to which the returned value will be cast.</typeparam>
            <param name="parameters">The available parameters to choose from.</param>
            <returns>The value of the selected parameter.</returns>
            <seealso cref="T:Revenj.Extensibility.Autofac.TypedParameter"/>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Features.Variance.ContravariantRegistrationSource">
            <summary>
            Enables contravariant <code>Resolve()</code> for interfaces that have a single contravariant ('in') parameter.
            </summary>
            <example>
            interface IHandler&lt;in TCommand&gt;
            {
                void Handle(TCommand command);
            }
            
            class Command { }
            
            class DerivedCommand : Command { }
            
            class CommandHandler : IHandler&lt;Command&gt; { ... }
            
            var builder = new ContainerBuilder();
            builder.RegisterSource(new ContravariantRegistrationSource());
            builder.RegisterType&lt;CommandHandler&gt;();
            var container = builder.Build();
            // Source enables this line, even though IHandler&lt;Command&gt; is the
            // actual registered type.
            var handler = container.Resolve&lt;IHandler&lt;DerivedCommand&gt;&gt;();
            handler.Handle(new DerivedCommand());
            </example>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.Variance.ContravariantRegistrationSource.RegistrationsFor(Revenj.Extensibility.Autofac.Core.Service,System.Func{Revenj.Extensibility.Autofac.Core.Service,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.IComponentRegistration}})">
            <summary>
            Retrieve registrations for an unregistered service, to be used
            by the container.
            </summary>
            <param name="service">The service that was requested.</param>
            <param name="registrationAccessor">A function that will return existing registrations for a service.</param>
            <returns>Registrations providing the service.</returns>
            <remarks>
            If the source is queried for service s, and it returns a component that implements both s and s', then it
            will not be queried again for either s or s'. This means that if the source can return other implementations
            of s', it should return these, plus the transitive closure of other components implementing their 
            additional services, along with the implementation of s. It is not an error to return components
            that do not implement <paramref name="service"/>.
            </remarks>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Features.Variance.ContravariantRegistrationSource.IsAdapterForIndividualComponents">
            <summary>
            Gets whether the registrations provided by this source are 1:1 adapters on top
            of other components (I.e. like Meta, Func or Owned.)
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Features.OwnedInstances.OwnedInstanceRegistrationSource">
            <summary>
            Generates registrations for services of type <see cref="T:Revenj.Extensibility.Autofac.Features.OwnedInstances.Owned`1"/> whenever the service
            T is available.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.OwnedInstances.OwnedInstanceRegistrationSource.RegistrationsFor(Revenj.Extensibility.Autofac.Core.Service,System.Func{Revenj.Extensibility.Autofac.Core.Service,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.IComponentRegistration}})">
            <summary>
            Retrieve registrations for an unregistered service, to be used
            by the container.
            </summary>
            <param name="service">The service that was requested.</param>
            <param name="registrationAccessor">A function that will return existing registrations for a service.</param>
            <returns>Registrations providing the service.</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Features.LightweightAdapters.LightweightAdapterActivatorData">
            <summary>
            Describes the basic requirements for generating a lightweight adapter.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.LightweightAdapters.LightweightAdapterActivatorData.#ctor(Revenj.Extensibility.Autofac.Core.Service,System.Func{Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},System.Object,System.Object})">
            <summary>
            Create an instance of <see cref="T:Revenj.Extensibility.Autofac.Features.LightweightAdapters.LightweightAdapterActivatorData"/>.
            </summary>
            <param name="fromService">The service that will be adapted from.</param>
            <param name="adapter">The adapter function.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Features.LightweightAdapters.LightweightAdapterActivatorData.Adapter">
            <summary>
            The adapter function.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Features.LightweightAdapters.LightweightAdapterActivatorData.FromService">
            <summary>
            The service to be adapted from.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistration">
            <summary>
            Describes a logical component within the container.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.IComponentRegistration">
            <summary>
            Describes a logical component within the container.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.IComponentRegistration.RaisePreparing(Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter}@)">
            <summary>
            Called by the container when an instance is required.
            </summary>
            <param name="service">Service chich is preparing</param>
            <param name="context">The context in which the instance will be activated.</param>
            <param name="parameters">Parameters for activation. These may be modified by the event handler.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.IComponentRegistration.RaiseActivating(Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},System.Object@)">
            <summary>
            Called by the container once an instance has been constructed.
            </summary>
            <param name="service">Service chich is activating</param>
            <param name="context">The context in which the instance was activated.</param>
            <param name="parameters">The parameters supplied to the activator.</param>
            <param name="instance">The instance.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.IComponentRegistration.RaiseActivated(Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},System.Object)">
            <summary>
            Called by the container once an instance has been fully constructed, including
            any requested objects that depend on the instance.
            </summary>
            <param name="service">Service which is activated</param>
            <param name="context">The context in which the instance was activated.</param>
            <param name="parameters">The parameters supplied to the activator.</param>
            <param name="instance">The instance.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IComponentRegistration.Id">
            <summary>
            A unique identifier for this component (shared in all sub-contexts.)
            This value also appears in Services.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IComponentRegistration.Activator">
            <summary>
            The activator used to create instances.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IComponentRegistration.Lifetime">
            <summary>
            The lifetime associated with the component.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IComponentRegistration.Sharing">
            <summary>
            Whether the component instances are shared or not.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IComponentRegistration.Ownership">
            <summary>
            Whether the instances of the component should be disposed by the container.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IComponentRegistration.Services">
            <summary>
            The services provided by the component.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IComponentRegistration.Metadata">
            <summary>
            Additional data associated with the component.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IComponentRegistration.Target">
            <summary>
            The component registration upon which this registration is based.
            </summary>
        </member>
        <member name="E:Revenj.Extensibility.Autofac.Core.IComponentRegistration.Preparing">
            <summary>
            Fired when a new instance is required. The instance can be
            provided in order to skip the regular activator, by setting the Instance property in
            the provided event arguments.
            </summary>
        </member>
        <member name="E:Revenj.Extensibility.Autofac.Core.IComponentRegistration.Activating">
            <summary>
            Fired when a new instance is being activated. The instance can be
            wrapped or switched at this time by setting the Instance property in
            the provided event arguments.
            </summary>
        </member>
        <member name="E:Revenj.Extensibility.Autofac.Core.IComponentRegistration.Activated">
            <summary>
            Fired when the activation process for a new instance is complete.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistration.#ctor(System.Guid,Revenj.Extensibility.Autofac.Core.IInstanceActivator,Revenj.Extensibility.Autofac.Core.IComponentLifetime,Revenj.Extensibility.Autofac.Core.InstanceSharing,Revenj.Extensibility.Autofac.Core.InstanceOwnership,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Service},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Create a new component registration.
            </summary>
            <param name="id">Unique identifier for the component.</param>
            <param name="activator">Activator used to activate instances.</param>
            <param name="lifetime">Determines how the component will be associated with its lifetime.</param>
            <param name="sharing">Whether the component is shared within its lifetime scope.</param>
            <param name="ownership">Whether the component instances are disposed at the end of their lifetimes.</param>
            <param name="services">Services the component provides.</param>
            <param name="metadata">Data associated with the component.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistration.#ctor(System.Guid,Revenj.Extensibility.Autofac.Core.IInstanceActivator,Revenj.Extensibility.Autofac.Core.IComponentLifetime,Revenj.Extensibility.Autofac.Core.InstanceSharing,Revenj.Extensibility.Autofac.Core.InstanceOwnership,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Service},System.Collections.Generic.IDictionary{System.String,System.Object},Revenj.Extensibility.Autofac.Core.IComponentRegistration)">
            <summary>
            Create a new component registration.
            </summary>
            <param name="id">Unique identifier for the component.</param>
            <param name="activator">Activator used to activate instances.</param>
            <param name="lifetime">Determines how the component will be associated with its lifetime.</param>
            <param name="sharing">Whether the component is shared within its lifetime scope.</param>
            <param name="ownership">Whether the component instances are disposed at the end of their lifetimes.</param>
            <param name="services">Services the component provides.</param>
            <param name="metadata">Data associated with the component.</param>
            <param name="target">The component registration upon which this registration is based.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistration.RaisePreparing(Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter}@)">
            <summary>
            Called by the container when an instance is required.
            </summary>
            <param name="service">Service which is preparing</param>
            <param name="context">The context in which the instance will be activated.</param>
            <param name="parameters">Parameters for activation.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistration.RaiseActivating(Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},System.Object@)">
            <summary>
            Called by the container once an instance has been constructed.
            </summary>
            <param name="service">Service which is activating</param>
            <param name="context">The context in which the instance was activated.</param>
            <param name="parameters">The parameters supplied to the activator.</param>
            <param name="instance">The instance.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistration.RaiseActivated(Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},System.Object)">
            <summary>
            Called by the container once an instance has been fully constructed, including
            any requested objects that depend on the instance.
            </summary>
            <param name="service">Service which is activated</param>
            <param name="context">The context in which the instance was activated.</param>
            <param name="parameters">The parameters supplied to the activator.</param>
            <param name="instance">The instance.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistration.ToString">
            <summary>
            Describes the component in a human-readable form.
            </summary>
            <returns>A description of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistration.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistration.Target">
            <summary>
            The component registration upon which this registration is based.
            If this registration was created directly by the user, returns this.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistration.Id">
            <summary>
            A unique identifier for this component (shared in all sub-contexts.)
            This value also appears in Services.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistration.Activator">
            <summary>
            The activator used to create instances.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistration.Lifetime">
            <summary>
            The lifetime associated with the component.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistration.Sharing">
            <summary>
            Whether the component instances are shared or not.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistration.Ownership">
            <summary>
            Whether the instances of the component should be disposed by the container.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistration.Services">
            <summary>
            The services provided by the component.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistration.Metadata">
            <summary>
            Additional data associated with the component.
            </summary>
        </member>
        <member name="E:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistration.Preparing">
            <summary>
            Fired when a new instance is required. The instance can be
            provided in order to skip the regular activator, by setting the Instance property in
            the provided event arguments.
            </summary>
        </member>
        <member name="E:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistration.Activating">
            <summary>
            Fired when a new instance is being activated. The instance can be
            wrapped or switched at this time by setting the Instance property in
            the provided event arguments.
            </summary>
        </member>
        <member name="E:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistration.Activated">
            <summary>
            Fired when the activation process for a new instance is complete.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Lifetime.CurrentScopeLifetime">
            <summary>
            Attaches the instance's lifetime to the current lifetime scope.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Lifetime.CurrentScopeLifetime.FindScope(Revenj.Extensibility.Autofac.Core.ISharingLifetimeScope)">
            <summary>
            Given the most nested scope visible within the resolve operation, find
            the scope for the component.
            </summary>
            <param name="mostNestedVisibleScope">The most nested visible scope.</param>
            <returns>The scope for the component.</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.InstanceSharing">
            <summary>
            Determines whether instances are shared within a lifetime scope.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Core.InstanceSharing.None">
            <summary>
            Each request for an instance will return a new object.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Core.InstanceSharing.Shared">
            <summary>
            Each request for an instance will return the same object.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException">
            <summary>
            Base exception type thrown whenever the dependency resolution process fails. This is a fatal
            exception, as Autofac is unable to 'roll back' changes to components that may have already
            been made during the operation. For example, 'on activated' handlers may have already been
            fired, or 'single instance' components partially constructed.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.DependencyResolutionException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.DependencyResolutionException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.DependencyResolutionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.DependencyResolutionException.Message">
            <summary>
            Gets a message that describes the current exception with dependency path.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Activators.Reflection.ConstructorParameterBinding">
            <summary>
            Binds a constructor to the parameters that will be used when it is invoked.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.Reflection.ConstructorParameterBinding.#ctor(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},Revenj.Extensibility.Autofac.IComponentContext)">
            <summary>
            Construct a new ConstructorParameterBinding.
            </summary>
            <param name="ci">ConstructorInfo to bind.</param>
            <param name="availableParameters">Available parameters.</param>
            <param name="context">Context in which to construct instance.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.Reflection.ConstructorParameterBinding.Instantiate">
            <summary>
            Invoke the constructor with the parameter bindings.
            </summary>
            <returns>The constructed instance.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.Reflection.ConstructorParameterBinding.ToString">
            <summary>Returns a System.String that represents the current System.Object.</summary>
            <returns>A System.String that represents the current System.Object.</returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Activators.Reflection.ConstructorParameterBinding.TargetConstructor">
            <summary>
            The constructor on the target type. The actual constructor used
            might differ, e.g. if using a dynamic proxy.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Activators.Reflection.ConstructorParameterBinding.CanInstantiate">
            <summary>
            True if the binding is valid.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Activators.Reflection.ConstructorParameterBinding.Description">
            <summary>
            Describes the constructor parameter binding.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.ServiceElement">
            <summary>
            Element describing a service exposed by a component.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ServiceElement.Type">
            <summary>
            Gets the service type.
            </summary>
            <value>The type.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ServiceElement.Name">
            <summary>
            Gets the service name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Builder.IHideObjectMembers">
            <summary>
            Hides standard Object members to make fluent interfaces
            easier to read.
            Based on blog post by @kzu here:
            http://www.clariusconsulting.net/blogs/kzu/archive/2008/03/10/58301.aspx
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IHideObjectMembers.GetType">
            <summary>
            Standard System.Object member.
            </summary>
            <returns>Standard result.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IHideObjectMembers.GetHashCode">
            <summary>
            Standard System.Object member.
            </summary>
            <returns>Standard result.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IHideObjectMembers.ToString">
            <summary>
            Standard System.Object member.
            </summary>
            <returns>Standard result.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IHideObjectMembers.Equals(System.Object)">
            <summary>
            Standard System.Object member.
            </summary>
            <param name="other">The other.</param>
            <returns>Standard result.</returns>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection">
            <summary>
            Represents a collection of parameters relevant to a <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand">NpgsqlCommand</see>
            as well as their respective mappings to columns in a <see cref="T:System.Data.DataSet">DataSet</see>.
            This class cannot be inherited.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.#ctor">
            <summary>
            Initializes a new instance of the NpgsqlParameterCollection class.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.Add(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter)">
            <summary>
            Adds the specified <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> object to the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection">NpgsqlParameterCollection</see>.
            </summary>
            <param name="value">The <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> to add to the collection.</param>
            <returns>The index of the new <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> object.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.Add(System.String,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlDbType)">
            <summary>
            Adds a <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> to the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection">NpgsqlParameterCollection</see> given the parameter name and the data type.
            </summary>
            <param name="parameterName">The name of the parameter.</param>
            <param name="parameterType">One of the DbType values.</param>
            <returns>The index of the new <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> object.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.Add(System.String,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlDbType,System.Int32)">
            <summary>
            Adds a <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> to the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection">NpgsqlParameterCollection</see> with the parameter name, the data type, and the column length.
            </summary>
            <param name="parameterName">The name of the parameter.</param>
            <param name="parameterType">One of the DbType values.</param>
            <param name="size">The length of the column.</param>
            <returns>The index of the new <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> object.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.Add(System.String,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlDbType,System.Int32,System.String)">
            <summary>
            Adds a <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> to the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection">NpgsqlParameterCollection</see> with the parameter name, the data type, the column length, and the source column name.
            </summary>
            <param name="parameterName">The name of the parameter.</param>
            <param name="parameterType">One of the DbType values.</param>
            <param name="size">The length of the column.</param>
            <param name="sourceColumn">The name of the source column.</param>
            <returns>The index of the new <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> object.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.RemoveAt(System.String)">
            <summary>
            Removes the specified <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> from the collection using the parameter name.
            </summary>
            <param name="parameterName">The name of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> object to retrieve.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.Contains(System.String)">
            <summary>
            Gets a value indicating whether a <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> with the specified parameter name exists in the collection.
            </summary>
            <param name="parameterName">The name of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> object to find.</param>
            <returns><b>true</b> if the collection contains the parameter; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.IndexOf(System.String)">
            <summary>
            Gets the location of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> in the collection with a specific parameter name.
            </summary>
            <param name="parameterName">The name of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> object to find.</param>
            <returns>The zero-based location of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> in the collection.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.RemoveAt(System.Int32)">
            <summary>
            Removes the specified <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> from the collection using a specific index.
            </summary>
            <param name="index">The zero-based index of the parameter.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.Insert(System.Int32,System.Object)">
            <summary>
            Inserts a <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> into the collection at the specified index.
            </summary>
            <param name="index">The zero-based index where the parameter is to be inserted within the collection.</param>
            <param name="value">The <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> to add to the collection.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.Remove(System.Object)">
            <summary>
            Removes the specified <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> from the collection.
            </summary>
            <param name="value">The <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> to remove from the collection.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.Contains(System.Object)">
            <summary>
            Gets a value indicating whether a <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> exists in the collection.
            </summary>
            <param name="value">The value of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> object to find.</param>
            <returns>true if the collection contains the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> object; otherwise, false.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.TryGetValue(System.String,Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter@)">
            <summary>
            Gets a value indicating whether a <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> with the specified parameter name exists in the collection.
            </summary>
            <param name="parameterName">The name of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> object to find.</param>
            <param name="parameter">A reference to the requested parameter is returned in this out param if it is found in the list.  This value is null if the parameter is not found.</param>
            <returns><b>true</b> if the collection contains the parameter and param will contain the parameter; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.Clear">
            <summary>
            Removes all items from the collection.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.IndexOf(System.Object)">
            <summary>
            Gets the location of a <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> in the collection.
            </summary>
            <param name="value">The value of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> object to find.</param>
            <returns>The zero-based index of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> object in the collection.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.Add(System.Object)">
            <summary>
            Adds the specified <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> object to the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection">NpgsqlParameterCollection</see>.
            </summary>
            <param name="value">The <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> to add to the collection.</param>
            <returns>The zero-based index of the new <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> object.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> objects from the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection">NpgsqlParameterCollection</see> to the specified array.
            </summary>
            <param name="array">An <see cref="T:System.Array">Array</see> to which to copy the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> objects in the collection.</param>
            <param name="index">The starting index of the array.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through the collection.
            </summary>
            <returns>An <see cref="T:System.Collections.IEnumerator">IEnumerator</see> that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.CheckType(System.Object)">
            <summary>
            In methods taking an object as argument this method is used to verify
            that the argument has the type <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see>
            </summary>
            <param name="Object">The object to verify</param>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.Item(System.String)">
            <summary>
            Gets the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> with the specified name.
            </summary>
            <param name="parameterName">The name of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> to retrieve.</param>
            <value>The <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> with the specified name, or a null reference if the parameter is not found.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> at the specified index.
            </summary>
            <param name="index">The zero-based index of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> to retrieve.</param>
            <value>The <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> at the specified index.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection.Count">
            <summary>
            Gets the number of <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> objects in the collection.
            </summary>
            <value>The number of <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> objects in the collection.</value>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand">
            <summary>
            Represents a SQL statement or function (stored procedure) to execute
            against a PostgreSQL database. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand">NpgsqlCommand</see> class.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand">NpgsqlCommand</see> class with the text of the query.
            </summary>
            <param name="cmdText">The text of the query.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.#ctor(System.String,Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand">NpgsqlCommand</see> class with the text of the query and a <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection">NpgsqlConnection</see>.
            </summary>
            <param name="cmdText">The text of the query.</param>
            <param name="connection">A <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection">NpgsqlConnection</see> that represents the connection to a PostgreSQL server.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.#ctor(System.String,Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection,Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlTransaction)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand">NpgsqlCommand</see> class with the text of the query, a <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection">NpgsqlConnection</see>, and the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlTransaction">NpgsqlTransaction</see>.
            </summary>
            <param name="cmdText">The text of the query.</param>
            <param name="connection">A <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection">NpgsqlConnection</see> that represents the connection to a PostgreSQL server.</param>
            <param name="transaction">The <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlTransaction">NpgsqlTransaction</see> in which the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand">NpgsqlCommand</see> executes.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.#ctor(System.String,Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector)">
            <summary>
            Used to execute internal commands.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.Cancel">
            <summary>
            Attempts to cancel the execution of a <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand">NpgsqlCommand</see>.
            </summary>
            <remarks>This Method isn't implemented yet.</remarks>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.System#ICloneable#Clone">
            <summary>
            Create a new command based on this one.
            </summary>
            <returns>A new NpgsqlCommand object.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.Clone">
            <summary>
            Create a new command based on this one.
            </summary>
            <returns>A new NpgsqlCommand object.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.CreateDbParameter">
            <summary>
            Creates a new instance of an <see cref="T:System.Data.Common.DbParameter">DbParameter</see> object.
            </summary>
            <returns>An <see cref="T:System.Data.Common.DbParameter">DbParameter</see> object.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.CreateParameter">
            <summary>
            Creates a new instance of a <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> object.
            </summary>
            <returns>A <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> object.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.ExecuteBlind">
            <summary>
            Slightly optimised version of ExecuteNonQuery() for internal ues in cases where the number
            of affected rows is of no interest.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.ExecuteNonQuery">
            <summary>
            Executes a SQL statement against the connection and returns the number of rows affected.
            </summary>
            <returns>The number of rows affected if known; -1 otherwise.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.ExecuteDbDataReader(System.Data.CommandBehavior)">
            <summary>
            Sends the <see cref="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.CommandText">CommandText</see> to
            the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection">Connection</see> and builds a
            <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader">NpgsqlDataReader</see>
            using one of the <see cref="T:System.Data.CommandBehavior">CommandBehavior</see> values.
            </summary>
            <param name="behavior">One of the <see cref="T:System.Data.CommandBehavior">CommandBehavior</see> values.</param>
            <returns>A <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader">NpgsqlDataReader</see> object.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.ExecuteReader">
            <summary>
            Sends the <see cref="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.CommandText">CommandText</see> to
            the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection">Connection</see> and builds a
            <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader">NpgsqlDataReader</see>.
            </summary>
            <returns>A <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader">NpgsqlDataReader</see> object.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.ExecuteReader(System.Data.CommandBehavior)">
            <summary>
            Sends the <see cref="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.CommandText">CommandText</see> to
            the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection">Connection</see> and builds a
            <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader">NpgsqlDataReader</see>
            using one of the <see cref="T:System.Data.CommandBehavior">CommandBehavior</see> values.
            </summary>
            <param name="cb">One of the <see cref="T:System.Data.CommandBehavior">CommandBehavior</see> values.</param>
            <returns>A <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader">NpgsqlDataReader</see> object.</returns>
            <remarks>Currently the CommandBehavior parameter is ignored.</remarks>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.BindParameters">
            <summary>
             This method binds the parameters from parameters collection to the bind
             message.
             </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.ExecuteScalar">
            <summary>
            Executes the query, and returns the first column of the first row
            in the result set returned by the query. Extra columns or rows are ignored.
            </summary>
            <returns>The first column of the first row in the result set,
            or a null reference if the result set is empty.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.Prepare">
            <summary>
            Creates a prepared version of the command on a PostgreSQL server.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.CheckConnectionState">
            <summary>
             This method checks the connection state to see if the connection
             is set or it is open. If one of this conditions is not met, throws
             an InvalidOperationException
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.GetCommandStream">
            <summary>
            This method substitutes the <see cref="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.Parameters">Parameters</see>, if exist, in the command
            to their actual values.
            The parameter name format is <b>:ParameterName</b>.
            </summary>
            <returns>A version of <see cref="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.CommandText">CommandText</see> with the <see cref="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.Parameters">Parameters</see> inserted.</returns>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.CommandText">
            <summary>
            Gets or sets the SQL statement or function (stored procedure) to execute at the data source.
            </summary>
            <value>The Transact-SQL statement or stored procedure to execute. The default is an empty string.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.CommandTimeout">
            <summary>
            Gets or sets the wait time before terminating the attempt
            to execute a command and generating an error.
            </summary>
            <value>The time (in seconds) to wait for the command to execute.
            The default is 20 seconds.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.CommandType">
            <summary>
            Gets or sets a value indicating how the
            <see cref="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.CommandText">CommandText</see> property is to be interpreted.
            </summary>
            <value>One of the <see cref="T:System.Data.CommandType">CommandType</see> values. The default is <see cref="T:System.Data.CommandType">CommandType.Text</see>.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.Connection">
            <summary>
            Gets or sets the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection">NpgsqlConnection</see>
            used by this instance of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand">NpgsqlCommand</see>.
            </summary>
            <value>The connection to a data source. The default value is a null reference.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.Parameters">
            <summary>
            Gets the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterCollection">NpgsqlParameterCollection</see>.
            </summary>
            <value>The parameters of the SQL statement or function (stored procedure). The default is an empty collection.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.Transaction">
            <summary>
            Gets or sets the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlTransaction">NpgsqlTransaction</see>
            within which the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand">NpgsqlCommand</see> executes.
            </summary>
            <value>The <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlTransaction">NpgsqlTransaction</see>.
            The default value is a null reference.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.UpdatedRowSource">
            <summary>
            Gets or sets how command results are applied to the <see cref="T:System.Data.DataRow">DataRow</see>
            when used by the <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)">Update</see>
            method of the <see cref="T:System.Data.Common.DbDataAdapter">DbDataAdapter</see>.
            </summary>
            <value>One of the <see cref="T:System.Data.UpdateRowSource">UpdateRowSource</see> values.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand.LastInsertedOID">
            <summary>
            Returns oid of inserted row. This is only updated when using executenonQuery and when command inserts just a single row. If table is created without oids, this will always be 0.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCancelRequest">
             <summary>
             This class represents the CancelRequest message sent to PostgreSQL
             server.
             </summary>
            
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Features.GeneratedFactories.GeneratedFactoryActivatorData">
            <summary>
            Data used to create factory activators.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.GeneratedFactories.GeneratedFactoryActivatorData.#ctor(System.Type,Revenj.Extensibility.Autofac.Core.Service)">
            <summary>
            Create a new GeneratedFactoryActivatorData
            </summary>
            <param name="delegateType">The type of the factory.</param>
            <param name="productService">The service used to provide the products of the factory.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Features.GeneratedFactories.GeneratedFactoryActivatorData.ParameterMapping">
            <summary>
            Determines how the parameters of the delegate type are passed on
            to the generated Resolve() call as Parameter objects.
            For Func-based delegates, this defaults to ByType. Otherwise, the
            parameters will be mapped by name.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Features.GeneratedFactories.GeneratedFactoryActivatorData.Activator">
            <summary>
            Activator data that can provide an IInstanceActivator instance.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Registration.ExternalRegistrySource">
            <summary>
            Pulls registrations from another component registry.
            Excludes most auto-generated registrations - currently has issues with
            collection registrations.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Registration.ExternalRegistrySource.#ctor(Revenj.Extensibility.Autofac.Core.IComponentRegistry)">
            <summary>
            Create an external registry source that draws components from
            <paramref name="registry"/>.
            </summary>
            <param name="registry">Component registry to pull registrations from.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Registration.ExternalRegistrySource.RegistrationsFor(Revenj.Extensibility.Autofac.Core.Service,System.Func{Revenj.Extensibility.Autofac.Core.Service,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.IComponentRegistration}})">
            <summary>
            Retrieve registrations for an unregistered service, to be used
            by the container.
            </summary>
            <param name="service">The service that was requested.</param>
            <param name="registrationAccessor">A function that will return existing registrations for a service.</param>
            <returns>Registrations providing the service.</returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Registration.ExternalRegistrySource.IsAdapterForIndividualComponents">
            <summary>
            In this case because the components that are adapted do not come from the same
            logical scope, we must return false to avoid duplicating them.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException">
            <summary>
            A service was requested that cannot be provided by the container. To avoid this exception, either register a component
            to provide the required service, check for service registration using IsRegistered(), or use the ResolveOptional()
            method to resolve an optional dependency.
            </summary>
            <remarks>This exception is fatal. See <see cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/> for more information.</remarks>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException.#ctor(Revenj.Extensibility.Autofac.Core.Service)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/> class.
            </summary>
            <param name="service">The service.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException.#ctor(Revenj.Extensibility.Autofac.Core.Service,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/> class.
            </summary>
            <param name="service">The service.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Activators.Reflection.ReflectionActivator">
            <summary>
            Uses reflection to activate instances of a type.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Activators.InstanceActivator">
            <summary>
            Base class for instance activators.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.InstanceActivator.#ctor(System.Type)">
            <summary>
            Create an instance activator that will return instances compatible
            with <paramref name="limitType"/>.
            </summary>
            <param name="limitType">Most derived type to which instances can be cast.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.InstanceActivator.ToString">
            <summary>
            Gets a string representation of the activator.
            </summary>
            <returns>A string describing the activator.</returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Activators.InstanceActivator.LimitType">
            <summary>
            The most specific type that the component instances are known to be castable to.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.Reflection.ReflectionActivator.#ctor(System.Type,Revenj.Extensibility.Autofac.Core.Activators.Reflection.IConstructorFinder,Revenj.Extensibility.Autofac.Core.Activators.Reflection.IConstructorSelector,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Create an activator for the provided type.
            </summary>
            <param name="implementationType">Type to activate.</param>
            <param name="constructorFinder">Constructor finder.</param>
            <param name="constructorSelector">Constructor selector.</param>
            <param name="configuredParameters">Parameters configured explicitly for this instance.</param>
            <param name="configuredProperties">Properties configured explicitly for this instance.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.Reflection.ReflectionActivator.GetFactory(Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Activate an instance in the provided context.
            </summary>
            <param name="context">Context in which to activate instances.</param>
            <param name="parameters">Parameters to the instance.</param>
            <returns>The activated instance.</returns>
            <remarks>
            The context parameter here should probably be ILifetimeScope in order to reveal Disposer,
            but will wait until implementing a concrete use case to make the decision
            </remarks>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Activators.Reflection.ReflectionActivator.ConstructorSelector">
            <summary>
            The constructor selector.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.ComponentElementCollection">
            <summary>
            A collection of component elements.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.ComponentElementCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Configuration.ComponentElementCollection"/> class.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.ProvideClientCertificatesCallback">
            <summary>
            Represents the method that allows the application to provide a certificate collection to be used for SSL clien authentication
            </summary>
            <param name="certificates">A <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection">X509CertificateCollection</see> to be filled with one or more client certificates.</param>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector">
            <summary>
            !!! Helper class, for compilation only.
            Connector implements the logic for the Connection Objects to
            access the physical connection to the database, and isolate
            the application developer from connection pooling internals.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.#ctor(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectionStringBuilder,System.Boolean,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="Shared">Controls whether the connector can be shared.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.IsValid">
            <summary>
            This method checks if the connector is still ok.
            We try to send a simple query text, select 1 as ConnectionTest;
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.ReleaseResources">
            <summary>
            This method is responsible for releasing all resources associated with this Connector.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.ReleasePlansPortals">
            <summary>
            This method is responsible to release all portals used by this Connector.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.DefaultCertificateSelectionCallback(System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Cryptography.X509Certificates.X509Certificate,System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection)">
            <summary>
            Default SSL CertificateSelectionCallback implementation.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.DefaultCertificateValidationCallback(System.Security.Cryptography.X509Certificates.X509Certificate,System.Int32[])">
            <summary>
            Default SSL CertificateValidationCallback implementation.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.DefaultPrivateKeySelectionCallback(System.Security.Cryptography.X509Certificates.X509Certificate,System.String)">
            <summary>
            Default SSL PrivateKeySelectionCallback implementation.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.DefaultProvideClientCertificatesCallback(System.Security.Cryptography.X509Certificates.X509CertificateCollection)">
            <summary>
            Default SSL ProvideClientCertificatesCallback implementation.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.ProcessServerVersion">
            <summary>
            This method is required to set all the version dependent features flags.
            SupportsPrepare means the server can use prepared query plans (7.3+)
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.Open">
            <summary>
            Opens the physical connection to the server.
            </summary>
            <remarks>Usually called by the RequestConnector
            Method of the connection pool manager.</remarks>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.Close">
            <summary>
            Closes the physical connection to the server.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.NextPortalName">
            <summary>
             Returns next portal index.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.NextPlanName">
            <summary>
             Returns next plan index.
            </summary>
        </member>
        <member name="E:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.Notice">
            <summary>
            Occurs on NoticeResponses from the PostgreSQL backend.
            </summary>
        </member>
        <member name="E:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.Notification">
            <summary>
            Occurs on NotificationResponses from the PostgreSQL backend.
            </summary>
        </member>
        <member name="E:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.ProvideClientCertificatesCallback">
            <summary>
            Called to provide client certificates for SSL handshake.
            </summary>
        </member>
        <member name="E:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.CertificateSelectionCallback">
            <summary>
            Mono.Security.Protocol.Tls.CertificateSelectionCallback delegate.
            </summary>
        </member>
        <member name="E:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.CertificateValidationCallback">
            <summary>
            Mono.Security.Protocol.Tls.CertificateValidationCallback delegate.
            </summary>
        </member>
        <member name="E:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.PrivateKeySelectionCallback">
            <summary>
            Mono.Security.Protocol.Tls.PrivateKeySelectionCallback delegate.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.State">
            <summary>
            Gets the current state of the connection.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.ConnectionString">
            <summary>
            Return Connection String.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.ServerVersion">
            <summary>
            Version of backend server this connector is connected to.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.Stream">
            <summary>
            The physical connection stream to the backend.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.Socket">
            <summary>
            The physical connection socket to the backend.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.IsInitialized">
            <summary>
            Reports if this connector is fully connected.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.Mediator">
            <summary>
            The connection mediator.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.Transaction">
            <summary>
            Report if the connection is in a transaction.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector.SupportsPrepare">
            <summary>
            Report whether the current connection can support prepare functionality.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParse">
             <summary>
             This class represents the Parse message sent to PostgreSQL
             server.
             </summary>
            
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Integration.Mef.ContractBasedService">
            <summary>
            Identifies a service by the MEF contract name it supports.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Service">
            <summary>
            Services are the lookup keys used to locate component instances.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Service.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Service.op_Equality(Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.Core.Service)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="lhs">The LHS.</param>
            <param name="rhs">The RHS.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Service.op_Inequality(Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.Core.Service)">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="lhs">The LHS.</param>
            <param name="rhs">The RHS.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Service.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">The <paramref name="obj"/> parameter is null.</exception>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Service.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Service.Description">
            <summary>
            Gets a human-readable description of the service.
            </summary>
            <value>The description.</value>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Integration.Mef.ContractBasedService.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Integration.Mef.ContractBasedService"/> class.
            </summary>
            <param name="contractName">The contract name.</param>
            <param name="exportTypeIdentity">Type identity of the objects exported under the contract.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Integration.Mef.ContractBasedService.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">The <paramref name="obj"/> parameter is null.</exception>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Integration.Mef.ContractBasedService.GetHashCode">
            <summary>
            Serves as a hash function for a particular ExportDefinition.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Integration.Mef.ContractBasedService.ExportTypeIdentity">
            <summary>
            Type identity of the objects exported under the contract.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Integration.Mef.ContractBasedService.ContractName">
            <summary>
            Gets or sets the name of the contract.
            </summary>
            <value>The name of the contract.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Integration.Mef.ContractBasedService.Description">
            <summary>
            Gets a human-readable description of the service.
            </summary>
            <value>The description.</value>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSource">
            <summary>
            Provides registrations on-the-fly for any concrete type not already registered with
            the container.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSource.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSource"/> class.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSource.#ctor(System.Func{System.Type,System.Boolean})">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSource"/> class.
            </summary>
            <param name="predicate">A predicate that selects types the source will register.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSource.RegistrationsFor(Revenj.Extensibility.Autofac.Core.Service,System.Func{Revenj.Extensibility.Autofac.Core.Service,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.IComponentRegistration}})">
            <summary>
            Retrieve registrations for an unregistered service, to be used
            by the container.
            </summary>
            <param name="service">The service that was requested.</param>
            <param name="registrationAccessor">A function that will return existing registrations for a service.</param>
            <returns>Registrations providing the service.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSource.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSource.IsAdapterForIndividualComponents">
            <summary>
            Gets whether the registrations provided by this source are 1:1 adapters on top
            of other components (I.e. like Meta, Func or Owned.)
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Features.OpenGenerics.OpenGenericDecoratorActivatorData">
            <summary>
            Describes the activator for an open generic decorator.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Builder.ReflectionActivatorData">
            <summary>
            Builder for reflection-based activators.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.ReflectionActivatorData.#ctor(System.Type)">
            <summary>
            Specify a reflection activator for the given type.
            </summary>
            <param name="implementor">Type that will be activated.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.ReflectionActivatorData.ImplementationType">
            <summary>
            Get the implementation type.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.ReflectionActivatorData.ConstructorFinder">
            <summary>
            The constructor finder for the registration.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.ReflectionActivatorData.ConstructorSelector">
            <summary>
            The constructor selector for the registration.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.ReflectionActivatorData.ConfiguredParameters">
            <summary>
            The explicitly bound constructor parameters.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.ReflectionActivatorData.ConfiguredProperties">
            <summary>
            The explicitly bound properties.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.OpenGenerics.OpenGenericDecoratorActivatorData.#ctor(System.Type,Revenj.Extensibility.Autofac.Core.IServiceWithType)">
            <summary>
            Construct an <see cref="T:Revenj.Extensibility.Autofac.Features.OpenGenerics.OpenGenericDecoratorActivatorData"/>.
            </summary>
            <param name="implementor">The decorator type.</param>
            <param name="fromService">The open generic service type to decorate.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Features.OpenGenerics.OpenGenericDecoratorActivatorData.FromService">
            <summary>
            The open generic service type to decorate.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Features.GeneratedFactories.ParameterMapping">
            <summary>
            Determines how the parameters of the delegate type are passed on
            to the generated Resolve() call as Parameter objects.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Features.GeneratedFactories.ParameterMapping.Adaptive">
            <summary>
            Chooses parameter mapping based on the factory type.
            For Func-based factories this is equivalent to ByType, for all
            others ByName will be used.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Features.GeneratedFactories.ParameterMapping.ByName">
            <summary>
            Pass the parameters supplied to the delegate through to the
            underlying registration as NamedParameters based on the parameter
            names in the delegate type's formal argument list.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Features.GeneratedFactories.ParameterMapping.ByType">
            <summary>
            Pass the parameters supplied to the delegate through to the
            underlying registration as TypedParameters based on the parameter
            types in the delegate type's formal argument list.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Features.GeneratedFactories.ParameterMapping.ByPosition">
            <summary>
            Pass the parameters supplied to the delegate through to the
            underlying registration as PositionalParameters based on the parameter
            indices in the delegate type's formal argument list.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.UniqueService">
            <summary>
            A handy unique service identifier type - all instances will be regarded as unequal.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.UniqueService.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Core.UniqueService"/> class.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.UniqueService.#ctor(System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Core.UniqueService"/> class.
            </summary>
            <param name="id">The id.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.UniqueService.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">The <paramref name="obj"/> parameter is null.</exception>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.UniqueService.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.UniqueService.Description">
            <summary>
            Provides a programmer-readable description of the identifying feature of the service.
            </summary>
            <value></value>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Resolving.InstanceLookupCompletionEndingEventArgs">
            <summary>
            Raised when the completion phase of an instance lookup operation ends.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Resolving.InstanceLookupCompletionEndingEventArgs.#ctor(Revenj.Extensibility.Autofac.Core.Resolving.IInstanceLookup)">
            <summary>
            Create an instance of the <see cref="T:Revenj.Extensibility.Autofac.Core.Resolving.InstanceLookupCompletionEndingEventArgs"/> class.
            </summary>
            <param name="instanceLookup">The instance lookup that is ending the completion phase.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Resolving.InstanceLookupCompletionEndingEventArgs.InstanceLookup">
            <summary>
            The instance lookup operation that is ending the completion phase.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.ResolvedParameter">
            <summary>
            Flexible parameter type allows arbitrary values to be retrieved
            from the resolution context.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.ResolvedParameter.#ctor(System.Func{System.Reflection.ParameterInfo,Revenj.Extensibility.Autofac.IComponentContext,System.Boolean},System.Func{System.Reflection.ParameterInfo,Revenj.Extensibility.Autofac.IComponentContext,System.Object})">
            <summary>
            Create an instance of the ResolvedParameter class.
            </summary>
            <param name="predicate">A predicate that determines which parameters on a constructor will be supplied by this instance.</param>
            <param name="valueAccessor">A function that supplies the parameter value given the context.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.ResolvedParameter.CanSupplyValue(System.Reflection.ParameterInfo,Revenj.Extensibility.Autofac.IComponentContext,System.Func{System.Object}@)">
            <summary>
            Returns true if the parameter is able to provide a value to a particular site.
            </summary>
            <param name="pi">Constructor, method, or property-mutator parameter.</param>
            <param name="context">The component context in which the value is being provided.</param>
            <param name="valueProvider">If the result is true, the valueProvider parameter will
            be set to a function that will lazily retrieve the parameter value. If the result is false,
            will be set to null.</param>
            <returns>True if a value can be supplied; otherwise, false.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.ResolvedParameter.ForNamed``1(System.String)">
            <summary>
            Construct a <see cref="T:Revenj.Extensibility.Autofac.Core.ResolvedParameter"/> that will match parameters of type
            <typeparamref name="TService"/> and resolve for those parameters an implementation
            registered with the name <paramref name="serviceName"/>.
            </summary>
            <typeparam name="TService">The type of the parameter to match.</typeparam>
            <param name="serviceName">The name of the matching service to resolve.</param>
            <returns>A configured <see cref="T:Revenj.Extensibility.Autofac.Core.ResolvedParameter"/> instance.</returns>
            <remarks>
            </remarks>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.ResolvedParameter.ForKeyed``1(System.Object)">
            <summary>
            Construct a <see cref="T:Revenj.Extensibility.Autofac.Core.ResolvedParameter"/> that will match parameters of type
            <typeparamref name="TService"/> and resolve for those parameters an implementation
            registered with the key <paramref name="serviceKey"/>.
            </summary>
            <typeparam name="TService">The type of the parameter to match.</typeparam>
            <param name="serviceKey">The key of the matching service to resolve.</param>
            <returns>A configured <see cref="T:Revenj.Extensibility.Autofac.Core.ResolvedParameter"/> instance.</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScope">
            <summary>
            Lifetime scope implementation.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.ISharingLifetimeScope">
            <summary>
            Defines a nested structure of lifetimes.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.ISharingLifetimeScope.GetOrCreateAndShare(System.Guid,System.Func{System.Object})">
            <summary>
            Try to retrieve an instance based on a GUID key. If the instance
            does not exist, invoke <paramref name="creator"/> to create it.
            </summary>
            <param name="id">instance id.</param>
            <param name="creator">Creation function.</param>
            <returns>An instance.</returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.ISharingLifetimeScope.RootLifetimeScope">
            <summary>
            The root of the sharing hierarchy.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.ISharingLifetimeScope.ParentLifetimeScope">
            <summary>
            The parent of this node of the hierarchy, or null.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScope._synchRoot">
            <summary>
            Protects shared instances from concurrent access. Other members and the base class are threadsafe.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScope.RootTag">
            <summary>
            The tag applied to root scopes when no other tag is specified.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScope.#ctor(Revenj.Extensibility.Autofac.Core.IComponentRegistry,Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScope,System.Object)">
            <summary>
            Create a lifetime scope for the provided components and nested beneath a parent.
            </summary>
            <param name="tag">The tag applied to the <see cref="T:Revenj.Extensibility.Autofac.ILifetimeScope"/>.</param>
            <param name="componentRegistry">Components used in the scope.</param>
            <param name="parent">Parent scope.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScope.#ctor(Revenj.Extensibility.Autofac.Core.IComponentRegistry,System.Object)">
            <summary>
            Create a root lifetime scope for the provided components.
            </summary>
            <param name="tag">The tag applied to the <see cref="T:Revenj.Extensibility.Autofac.ILifetimeScope"/>.</param>
            <param name="componentRegistry">Components used in the scope.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScope.#ctor(Revenj.Extensibility.Autofac.Core.IComponentRegistry)">
            <summary>
            Create a root lifetime scope for the provided components.
            </summary>
            <param name="componentRegistry">Components used in the scope.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScope.BeginLifetimeScope">
            <summary>
            Begin a new anonymous sub-scope. Instances created via the sub-scope
            will be disposed along with it.
            </summary>
            <returns>A new lifetime scope.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScope.BeginLifetimeScope(System.Object)">
            <summary>
            Begin a new tagged sub-scope. Instances created via the sub-scope
            will be disposed along with it.
            </summary>
            <param name="tag">The tag applied to the <see cref="T:Revenj.Extensibility.Autofac.ILifetimeScope"/>.</param>
            <returns>A new lifetime scope.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScope.BeginLifetimeScope(System.Action{Revenj.Extensibility.Autofac.ContainerBuilder})">
            <summary>
            Begin a new anonymous sub-scope, with additional components available to it.
            Component instances created via the new scope
            will be disposed along with it.
            </summary>
            <param name="configurationAction">Action on a <see cref="T:Revenj.Extensibility.Autofac.ContainerBuilder"/>
            that adds component registations visible only in the new scope.</param>
            <returns>A new lifetime scope.</returns>
            <example>
            IContainer cr = // ...
            using (var lifetime = cr.BeginLifetimeScope(builder =&gt; {
                    builder.RegisterType&lt;Foo&gt;();
                    builder.RegisterType&lt;Bar&gt;().As&lt;IBar&gt;(); })
            {
                var foo = lifetime.Resolve&lt;Foo&gt;();
            }
            </example>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScope.BeginLifetimeScope(System.Object,System.Action{Revenj.Extensibility.Autofac.ContainerBuilder})">
            <summary>
            Begin a new tagged sub-scope, with additional components available to it.
            Component instances created via the new scope
            will be disposed along with it.
            </summary>
            <param name="tag">The tag applied to the <see cref="T:Revenj.Extensibility.Autofac.ILifetimeScope"/>.</param>
            <param name="configurationAction">Action on a <see cref="T:Revenj.Extensibility.Autofac.ContainerBuilder"/>
            that adds component registations visible only in the new scope.</param>
            <returns>A new lifetime scope.</returns>
            <example>
            IContainer cr = // ...
            using (var lifetime = cr.BeginLifetimeScope("unitOfWork", builder =&gt; {
                    builder.RegisterType&lt;Foo&gt;();
                    builder.RegisterType&lt;Bar&gt;().As&lt;IBar&gt;(); })
            {
                var foo = lifetime.Resolve&lt;Foo&gt;();
            }
            </example>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScope.ResolveLookup(Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.Core.IComponentRegistration,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Resolve an lookup of the provided registration within the context.
            </summary>
            <param name="service">Service which is trying to be resolved</param>
            <param name="registration">The registration.</param>
            <param name="parameters">Parameters for the instance.</param>
            <returns>
            The component lookup.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScope.GetOrCreateAndShare(System.Guid,System.Func{System.Object})">
            <summary>
            Try to retrieve an instance based on a GUID key. If the instance
            does not exist, invoke <paramref name="creator"/> to create it.
            </summary>
            <param name="id">Key to look up.</param>
            <param name="creator">Creation function.</param>
            <returns>An instance.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScope.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScope.System#IServiceProvider#GetService(System.Type)">
            <summary>
            Gets the service object of the specified type.
            </summary>
            <param name="serviceType">An object that specifies the type of service object 
            to get.</param>
            <returns>
            A service object of type <paramref name="serviceType"/>.-or- null if there is 
            no service object of type <paramref name="serviceType"/>.
            </returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScope.ParentLifetimeScope">
            <summary>
            The parent of this node of the hierarchy, or null.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScope.RootLifetimeScope">
            <summary>
            The root of the sharing hierarchy.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScope.Disposer">
            <summary>
            The disposer associated with this container. Instances can be associated
            with it manually if required.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScope.Tag">
            <summary>
            Tag applied to the lifetime scope.
            </summary>
            <remarks>The tag applied to this scope and the contexts generated when
            it resolves component dependencies.</remarks>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScope.ComponentRegistry">
            <summary>
            Associates services with the components that provide them.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.ComponentRegisteredEventArgs">
            <summary>
            Information about the ocurrence of a component being registered
            with a container.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.ComponentRegisteredEventArgs.#ctor(Revenj.Extensibility.Autofac.Core.IComponentRegistry,Revenj.Extensibility.Autofac.Core.IComponentRegistration)">
            <summary>
            Create a new instance with a valid container and component registration.
            </summary>
            <param name="registry">The container into which the registration 
            was made.</param>
            <param name="componentRegistration">The component registration.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.ComponentRegisteredEventArgs.ComponentRegistry">
            <summary>
            The container into which the registration was made.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.ComponentRegisteredEventArgs.ComponentRegistration">
            <summary>
            The component registration.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.PropertyElement">
            <summary>
            Element describing a component property.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.PropertyElement.CoerceValue">
            <summary>
            Get the value of this element
            </summary>
            <returns></returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.PropertyElement.Name">
            <summary>
            Gets the name of the property.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.PropertyElement.Value">
            <summary>
            Gets the value to be set (will be converted.)
            </summary>
            <value>The value.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.PropertyElement.List">
            <summary>
            If this property's value is a list of values
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.PropertyElement.Dictionary">
            <summary>
            If this property's value is a dictionary
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.FileElement">
            <summary>
            Element describing an additional configuration file.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.FileElement.Name">
            <summary>
            Gets the filename of the file.
            </summary>
            <value>The filename.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.FileElement.Section">
            <summary>
            Gets the section name of the section in the configuration
            file.
            </summary>
            <value>The section name.</value>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlPromotableSinglePhaseNotification.Prepare">
            <summary>
            Used when a connection is closed
            </summary>
        </member>
        <member name="T:Revenj.Utility.StableHashCode">
            <summary>
            Hash code utility.
            Stable hash code across versions and architectures
            </summary>
        </member>
        <member name="M:Revenj.Utility.StableHashCode.HashString(System.String)">
            <summary>
            Provide uniquish hash code for string value.
            TODO: convert to proven hash algorithm
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="T:Revenj.Utility.DynamicOrderBy">
            <summary>
            Utility class for conversion from dynamic order to static order.
            </summary>
        </member>
        <member name="M:Revenj.Utility.DynamicOrderBy.OrderBy``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Boolean}})">
            <summary>
            Order by provided properties using specified direction.
            Properties (or paths) are specified as string.
            </summary>
            <typeparam name="T">collection type</typeparam>
            <param name="collection">collection projection</param>
            <param name="orderBy">order configuration</param>
            <returns>sorted projection</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Util.Enforce">
            <summary>
            Helper methods used throughout the codebase.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Util.Enforce.ArgumentNotNull``1(``0,System.String)">
            <summary>
            Enforce that an argument is not null. Returns the
            value if valid so that it can be used inline in
            base initialiser syntax.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="name"></param>
            <returns><paramref name="value"/></returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Util.Enforce.ArgumentElementNotNull``1(``0,System.String)">
            <summary>
            Enforce that sequence does not contain null. Returns the
            value if valid so that it can be used inline in
            base initialiser syntax.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value">The value.</param>
            <param name="name">The name.</param>
            <returns><paramref name="value"/></returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Util.Enforce.NotNull``1(``0)">
            <summary>
            Enforces that the provided object is non-null.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value">The value.</param>
            <returns><paramref name="value"/></returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Util.Enforce.ArgumentNotNullOrEmpty(System.String,System.String)">
            <summary>
            Enforce that an argument is not null or empty. Returns the
            value if valid so that it can be used inline in
            base initialiser syntax.
            </summary>
            <param name="value">The value.</param>
            <param name="description">The description.</param>
            <returns><paramref name="value"/></returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Util.Enforce.ArgumentTypeIsFunction(System.Type)">
            <summary>
            Enforce that the argument is a delegate type.
            </summary>
            <param name="delegateType">The type to test.</param>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScopeEndingEventArgs">
            <summary>
            Describes when a lifetime scope is ending.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScopeEndingEventArgs.#ctor(Revenj.Extensibility.Autofac.ILifetimeScope)">
            <summary>
            Create an instance of the <see cref="T:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScopeEndingEventArgs"/> class.
            </summary>
            <param name="lifetimeScope">The lifetime scope that is ending.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScopeEndingEventArgs.LifetimeScope">
            <summary>
            The lifetime scope that is ending.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Diagnostics.IContainerAwareComponent">
            <summary>
            Marks a module as container-aware (for the purposes of attaching to diagnostic events.)
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Diagnostics.IContainerAwareComponent.SetContainer(Revenj.Extensibility.Autofac.IContainer)">
            <summary>
            Initialise the module with the container into which it is being registered.
            </summary>
            <param name="container">The container.</param>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Activators.Reflection.BindingFlagsConstructorFinder">
            <summary>
            Finds constructors based on their binding flags.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Activators.Reflection.IConstructorFinder">
            <summary>
            Find suitable constructors from which to select.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.Reflection.IConstructorFinder.FindConstructors(System.Type)">
            <summary>
            Finds suitable constructors on the target type.
            </summary>
            <param name="targetType">Type to search for constructors.</param>
            <returns>Suitable constructors.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.Reflection.BindingFlagsConstructorFinder.#ctor(System.Reflection.BindingFlags)">
            <summary>
            Create an instance matching constructors with the supplied binding flags.
            </summary>
            <param name="bindingFlags">Binding flags to match.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.Reflection.BindingFlagsConstructorFinder.FindConstructors(System.Type)">
            <summary>
            Finds suitable constructors on the target type.
            </summary>
            <param name="targetType">Type to search for constructors.</param>
            <returns>Suitable constructors.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.Reflection.BindingFlagsConstructorFinder.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.SectionHandler">
            <summary>
            Section handler for Autofac configuration in app.config files.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.SectionHandler.Modules">
            <summary>
            Gets the modules to be registered.
            </summary>
            <value>The modules.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.SectionHandler.Components">
            <summary>
            Gets the components to be registered.
            </summary>
            <value>The components.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.SectionHandler.Files">
            <summary>
            Gets additional configuration files.
            </summary>
            <value>The files.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.SectionHandler.DefaultAssembly">
            <summary>
            Gets the default assembly to search for types in when not explicitly
            provided with the type name.
            </summary>
            <value>The default assembly.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.SectionHandler.Assemblies">
            <summary>
            Gets the assemblies to be registered.
            </summary>
            <value>The assemblies.</value>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.ParameterElement">
            <summary>
            Element describing a component constructor parameter.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.ParameterElement.CoerceValue">
            <summary>
            Get the value of this element
            </summary>
            <returns></returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ParameterElement.Name">
            <summary>
            Gets the name of the parameter.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ParameterElement.Value">
            <summary>
            Gets the value used to set the parameter (type will be converted.)
            </summary>
            <value>The value.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ParameterElement.List">
            <summary>
            If this parameter's value is a list of values
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ParameterElement.Dictionary">
            <summary>
            If this parameter's value is a dictionary
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlRow">
            <summary>
            This is the abstract base class for NpgsqlAsciiRow and NpgsqlBinaryRow.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.IStreamOwner">
            <summary>
            Marker interface which identifies a class which may take possession of a stream for the duration of
            it's lifetime (possibly temporarily giving that possession to another class for part of that time.
            
            It inherits from IDisposable, since any such class must make sure it leaves the stream in a valid state.
            
            The most important such class is that compiler-generated from ProcessBackendResponsesEnum. Of course
            we can't make that inherit from this interface, alas.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Revenj.DatabasePersistence.Postgres.Npgsql.IServerResponseObject" -->
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.RowReader">
            <summary>
            Reads a row, field by field, allowing a DataRow to be built appropriately.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.RowReader.Streamer">
            <summary>
            Reads part of a field, as needed (for <see cref="!:System.Data.IDataRecord.GetChars()"/>
            and <see cref="!:System.Data.IDataRecord.GetBytes()"/>
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.RowReader.Streamer`1">
            <summary>
            Adds further functionality to stream that is dependant upon the type of data read.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.RowReader.CharStreamer">
            <summary>
            Completes the implementation of Streamer for char data.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.RowReader.ByteStreamer">
            <summary>
            Completes the implementation of Streamer for byte data.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectorPool">
            <summary>
            This class manages all connector objects, pooled AND non-pooled.
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectorPool.ConnectorPoolMgr">
            <value>Unique static instance of the connector pool
            mamager.</value>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectorPool.PooledConnectors">
            <value>Map of index to unused pooled connectors, avaliable to the
            next RequestConnector() call.</value>
            <remarks>This hashmap will be indexed by connection string.
            This key will hold a list of queues of pooled connectors available to be used.</remarks>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectorPool.Timer">
            <value>Timer for tracking unused connections in pools.</value>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectorPool.RequestConnector(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection)">
            <summary>
            Searches the shared and pooled connector lists for a
            matching connector object or creates a new one.
            </summary>
            <param name="Connection">The NpgsqlConnection that is requesting
            the connector. Its ConnectionString will be used to search the
            pool for available connectors.</param>
            <returns>A connector object.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectorPool.RequestPooledConnectorInternal(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection)">
            <summary>
            Find a pooled connector.  Handle shared/non-shared here.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectorPool.ReleaseConnector(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection,Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector)">
            <summary>
            Releases a connector, possibly back to the pool for future use.
            </summary>
            <remarks>
            Pooled connectors will be put back into the pool if there is room.
            Shared connectors should just have their use count decremented
            since they always stay in the shared pool.
            </remarks>
            <param name="Connector">The connector to release.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectorPool.ReleaseConnectorInternal(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection,Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector)">
            <summary>
            Release a pooled connector.  Handle shared/non-shared here.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectorPool.GetPooledConnector(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection)">
            <summary>
            Find an available pooled connector in the non-shared pool, or create
            a new one if none found.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectorPool.FixPoolCountBecauseOfConnectionDisposeFalse(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection)">
            <summary>
            This method is only called when NpgsqlConnection.Dispose(false) is called which means a
            finalization. This also means, an NpgsqlConnection was leak. We clear pool count so that
            client doesn't end running out of connections from pool. When the connection is finalized, its underlying
            socket is closed.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectorPool.UngetConnector(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection,Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector)">
            <summary>
            Put a pooled connector into the pool queue.
            </summary>
            <param name="Connector">Connector to pool</param>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectorPool.ConnectorQueue">
            <summary>
            A queue with an extra Int32 for keeping track of busy connections.
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectorPool.ConnectorQueue.Available">
            <summary>
            Connections available to the end user
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectorPool.ConnectorQueue.Busy">
            <summary>
            Connections currently in use
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlBackEndKeyData">
            <summary>
            This class represents a BackEndKeyData message received
            from PostgreSQL
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlPasswordPacket">
            <summary>
            This class represents a PasswordPacket message sent to backend
            PostgreSQL.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOutStream">
            <summary>
            Stream for reading data from a table or select on a PostgreSQL version 7.4 or newer database during an active COPY TO STDOUT operation.
            <b>Passes data exactly as provided by the server.</b>
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOutStream.#ctor(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector)">
            <summary>
            Created only by NpgsqlCopyOutState.StartCopy()
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOutStream.Close">
            <summary>
            Discards copy data as long as server pushes it. Returns after operation is finished.
            Does nothing if this stream is not the active copy operation reader.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOutStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Not writable.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOutStream.Flush">
            <summary>
            Not flushable.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOutStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies data read from server to given byte buffer.
            Since server returns data row by row, length will differ each time, but it is only zero once the operation ends.
            Can be mixed with calls to the more efficient NpgsqlCopyOutStream.Read() : byte[] though that would not make much sense.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOutStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Not seekable
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOutStream.SetLength(System.Int64)">
            <summary>
            Not supported
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOutStream.Read">
            <summary>
            Returns a whole row of data from server without extra work.
            If standard Stream.Read(...) has been called before, it's internal buffers remains are returned.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOutStream.IsActive">
            <summary>
            True while this stream can be used to read copy data from server
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOutStream.CanRead">
            <summary>
            True
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOutStream.CanWrite">
            <summary>
            False
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOutStream.CanSeek">
            <summary>
            False
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOutStream.Length">
            <summary>
            Number of bytes read so far
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyOutStream.Position">
            <summary>
            Number of bytes read so far; can not be set.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlPoint">
            <summary>
            Represents a PostgreSQL Point type
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlLSeg">
            <summary>
            Represents a PostgreSQL Line Segment type.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlPath">
            <summary>
            Represents a PostgreSQL Path type.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlPolygon">
            <summary>
            Represents a PostgreSQL Polygon type.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlCircle">
            <summary>
            Represents a PostgreSQL Circle type.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInet">
            <summary>
            Represents a PostgreSQL inet type.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlMacAddress">
            <summary>
            Represents a PostgreSQL MacAddress type.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlMacAddress.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="macAddr">The macAddr parameter must contain a string that can only consist of numbers
            and upper-case letters as hexadecimal digits. (See PhysicalAddress.Parse method on MSDN)</param>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.LargeObjectManager">
            <summary>
            Summary description for LargeObjectManager.
            </summary>
        </member>
        <member name="T:Revenj.TreePath">
            <summary>
            Structure for hierarchical modeling.
            Supports labels separated by dots. Only alphanumeric values allowed for labels.
            eg: Level1.Level2.Level3
            </summary>
        </member>
        <member name="F:Revenj.TreePath.Empty">
            <summary>
            Empty path
            </summary>
        </member>
        <member name="M:Revenj.TreePath.#ctor(System.String)">
            <summary>
            Construct path from string value, eg: top.middle.bottom
            </summary>
            <param name="path">string representation</param>
        </member>
        <member name="M:Revenj.TreePath.Create(System.String)">
            <summary>
            Create path from string value, eg: top.middle.bottom
            </summary>
            <param name="path">string representation</param>
            <returns>TreePath instance</returns>
        </member>
        <member name="M:Revenj.TreePath.GetHashCode">
            <summary>
            Hash code is calculated of string representation
            </summary>
            <returns>string value hash code</returns>
        </member>
        <member name="M:Revenj.TreePath.Equals(System.Object)">
            <summary>
            Check for equality. Same as checking for string representation equality.
            </summary>
            <param name="obj">string or TreePath</param>
            <returns>is string representation equal</returns>
        </member>
        <member name="M:Revenj.TreePath.ToString">
            <summary>
            Return string representation of the value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Revenj.TreePath.op_Implicit(Revenj.TreePath)~System.String">
            <summary>
            Implicit conversion to string. Same as calling .ToString()
            </summary>
            <param name="path">TreePath structure</param>
            <returns>string representation.</returns>
        </member>
        <member name="M:Revenj.TreePath.op_Implicit(System.String)~Revenj.TreePath">
            <summary>
            Implicit conversion to TreePath. Same as calling new TreePath(string)
            </summary>
            <param name="path">string value</param>
            <returns>TreePath structure</returns>
        </member>
        <member name="M:Revenj.TreePath.op_Addition(Revenj.TreePath,Revenj.TreePath)">
            <summary>
            Concatenate two paths
            </summary>
            <param name="left">parent path</param>
            <param name="right">child path</param>
            <returns>combined path</returns>
        </member>
        <member name="T:Revenj.Utility.ChunkedMemoryStream">
            <summary>
            In memory stream with 8192 blocks to avoid LOH issues.
            Since .NET places objects larger that 85000 bytes into LOH, 
            avoid it as much as possible by using list of smaller blocks.
            </summary>
        </member>
        <member name="F:Revenj.Utility.ChunkedMemoryStream.SmallBuffer">
            <summary>
            Temporary small char buffer for reuse (64 chars)
            </summary>
        </member>
        <member name="F:Revenj.Utility.ChunkedMemoryStream.CharBuffer">
            <summary>
            Temporary char buffer for reuse (8192*4/3 + 2 chars)
            </summary>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.Create">
            <summary>
            Create or get a new instance of memory stream
            Stream is bound to thread and must be released from the same thread
            </summary>
            <returns>usable memory stream instance</returns>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.Static">
            <summary>
            Create reusable stream.
            Disposing the stream only has the effect of resetting it.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.#ctor">
            <summary>
            Create new empty stream
            Stream is bound to thread and must be released from the same thread
            </summary>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.#ctor(System.IO.Stream)">
            <summary>
            Create in memory stream based on another stream.
            Provided stream will not be disposed.
            </summary>
            <param name="another">stream to copy</param>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.#ctor(System.IO.Stream,System.Boolean,System.Boolean)">
            <summary>
            Create in memory stream based on another stream.
            Specify whether should provided stream be disposed after copying.
            </summary>
            <param name="another">stream to copy</param>
            <param name="dispose">dispose provided stream</param>
            <param name="reset">reset provided stream to original position</param>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.Flush">
            <summary>
            Flush stream. Does nothing.
            </summary>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.ReadByte">
            <summary>
            Read a single byte
            </summary>
            <returns>byte value or -1 for end</returns>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read buffer from the stream. 
            Can return less then specified count if remaining block size is less than specified count
            </summary>
            <param name="buffer">copy to buffer</param>
            <param name="offset">offset in the buffer</param>
            <param name="count">maximum size to read</param>
            <returns>length of bytes read</returns>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seek to position in the stream.
            </summary>
            <param name="offset">offset at stream</param>
            <param name="origin">position type</param>
            <returns>current position</returns>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.Reset">
            <summary>
            Set length and position to 0
            </summary>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.SetLength(System.Int64)">
            <summary>
            Set new length of the stream.
            Adjusts the current position if new length is larger then it.
            </summary>
            <param name="value">new length</param>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.Matches(System.Byte[])">
            <summary>
            Check if stream starts with provided byte[] and matches it's length
            Provided byte[] must be smaller than 8192 bytes
            </summary>
            <returns>stream matches provided byte[]</returns>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.WriteByte(System.Byte)">
            <summary>
            Write byte to stream.
            Advances current position by one.
            Adds a new block if necessary.
            </summary>
            <param name="value">byte to write</param>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write buffer to stream.
            Advances current position by count.
            Increases length if necessary.
            New blocks will be added as required.
            It's best to use buffer of size 8192
            </summary>
            <param name="buffer">provided bytes</param>
            <param name="offset">offset in bytes</param>
            <param name="count">total length</param>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.Equals(System.IO.Stream)">
            <summary>
            Compare two streams. 
            Length and content will be compared.
            </summary>
            <param name="another">stream to compare</param>
            <returns>are streams equal</returns>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.ToBase64Stream">
            <summary>
            Convert stream to Base 64 String representation in stream.
            </summary>
            <returns>created stream</returns>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.ToBase64Writer(System.IO.TextWriter)">
            <summary>
            Convert stream to Base 64 String representation in the provided writer.
            </summary>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.ToPostgresBytea(System.IO.TextWriter)">
            <summary>
            Convert stream to Postgres representation of bytea
            </summary>
            <param name="sw"></param>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.CopyTo(System.IO.Stream)">
            <summary>
            Optimized version of copy to stream
            </summary>
            <param name="stream">destination stream</param>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copy stream to target buffer
            </summary>
            <param name="target">target array buffer</param>
            <param name="offset">start at offset</param>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.Send(System.Net.Sockets.Socket)">
            <summary>
            Send entire stream to provided socket.
            </summary>
            <param name="socket">where to send</param>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.GetWriter">
            <summary>
            Reuse same text writer on this stream.
            </summary>
            <returns>stream writer</returns>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.GetReader">
            <summary>
            Reuse same text reader on this stream.
            </summary>
            <returns>stream reader</returns>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.UseBufferedReader(System.IO.TextReader)">
            <summary>
            Reuse buffered text reader associated with this stream.
            Provide input text reader as data source.
            Buffered text reader will be initialized with provided input
            </summary>
            <param name="reader">input for processing</param>
            <returns>initialized buffered text reader</returns>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.UseBufferedReader(System.String)">
            <summary>
            Reuse buffered text reader associated with this stream.
            Provide input string as data source.
            Buffered text reader will be initialized with provided input
            </summary>
            <param name="value">input for processing</param>
            <returns>initialized buffered text reader</returns>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.Close">
            <summary>
            Close current stream.
            Stream will be added to pool if required.
            Doesn't release allocated buffers
            </summary>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.Dispose(System.Boolean)">
            <summary>
            Dispose current stream.
            Stream will be added to pool if required.
            Used to reset position and length. Doesn't release allocated buffers
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:Revenj.Utility.ChunkedMemoryStream.ToString">
            <summary>
            Show content of the stream as string
            </summary>
            <returns></returns>
        </member>
        <member name="P:Revenj.Utility.ChunkedMemoryStream.CanRead">
            <summary>
            Can this stream be read? Always true
            </summary>
        </member>
        <member name="P:Revenj.Utility.ChunkedMemoryStream.CanSeek">
            <summary>
            Can this stream be sought? Always true
            </summary>
        </member>
        <member name="P:Revenj.Utility.ChunkedMemoryStream.CanWrite">
            <summary>
            Can this stream be written to? Always true
            </summary>
        </member>
        <member name="P:Revenj.Utility.ChunkedMemoryStream.Length">
            <summary>
            Get the length of the stream.
            </summary>
        </member>
        <member name="P:Revenj.Utility.ChunkedMemoryStream.Position">
            <summary>
            Current position in the stream.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Integration.Mef.RegistrationExtensions">
            <summary>
            Extension methods that add MEF hosting capabilities to the container building classes.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Integration.Mef.RegistrationExtensions.Exported``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Action{Revenj.Extensibility.Autofac.Integration.Mef.ExportConfigurationBuilder})">
            <summary>
            Expose the registered service to MEF parts as an export.
            </summary>
            <param name="registration">The component being registered.</param>
            <param name="configurationAction">Action on an object that configures the export.</param>
            <returns>A registration allowing registration to continue.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Integration.Mef.RegistrationExtensions.RegisterComposablePartType(Revenj.Extensibility.Autofac.ContainerBuilder,System.Type)">
            <summary>
            Register a MEF-attributed type as a component.
            </summary>
            <param name="builder">The container builder.</param>
            <param name="partType">The attributed type to register.</param>
            <remarks>
            A simple heuristic/type scanning technique will be used to determine which MEF exports
            are exposed to other components in the Autofac container.
            </remarks>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Integration.Mef.RegistrationExtensions.RegisterComposablePartType(Revenj.Extensibility.Autofac.ContainerBuilder,System.Type,System.Func{System.ComponentModel.Composition.Primitives.ExportDefinition,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Service}})">
            <summary>
            Register a MEF-attributed type as a component.
            </summary>
            <param name="builder">The container builder.</param>
            <param name="partType">The attributed type to register.</param>
            <param name="exposedServicesMapper">A mapping function to transform ExportDefinitions into Services.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Integration.Mef.RegistrationExtensions.RegisterComposablePartCatalog(Revenj.Extensibility.Autofac.ContainerBuilder,System.ComponentModel.Composition.Primitives.ComposablePartCatalog)">
            <summary>
            Register a MEF catalog.
            </summary>
            <param name="builder">The container builder.</param>
            <param name="catalog">The catalog to register.</param>
            <remarks>
            A simple heuristic/type scanning technique will be used to determine which MEF exports
            are exposed to other components in the Autofac container.
            </remarks>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Integration.Mef.RegistrationExtensions.RegisterComposablePartCatalog(Revenj.Extensibility.Autofac.ContainerBuilder,System.ComponentModel.Composition.Primitives.ComposablePartCatalog,Revenj.Extensibility.Autofac.Core.Service[])">
            <summary>
            Register a MEF catalog.
            </summary>
            <param name="builder">The container builder.</param>
            <param name="catalog">The catalog to register.</param>
            <param name="interchangeServices">The services that will be exposed to other components in the container.</param>
            <remarks>
            Named and typed services only can be matched in the <paramref name="interchangeServices"/> collection.
            </remarks>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Integration.Mef.RegistrationExtensions.RegisterComposablePartCatalog(Revenj.Extensibility.Autofac.ContainerBuilder,System.ComponentModel.Composition.Primitives.ComposablePartCatalog,System.Func{System.ComponentModel.Composition.Primitives.ExportDefinition,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Service}})">
            <summary>
            Register a MEF catalog.
            </summary>
            <param name="builder">The container builder.</param>
            <param name="catalog">The catalog to register.</param>
            <param name="exposedServicesMapper">A mapping function to transform ExportDefinitions into Services.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Integration.Mef.RegistrationExtensions.RegisterComposablePartDefinition(Revenj.Extensibility.Autofac.ContainerBuilder,System.ComponentModel.Composition.Primitives.ComposablePartDefinition,System.Func{System.ComponentModel.Composition.Primitives.ExportDefinition,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Service}})">
            <summary>
            Register a MEF part definition.
            </summary>
            <param name="builder">The container builder.</param>
            <param name="partDefinition">The part definition to register.</param>
            <param name="exposedServicesMapper">A mapping function to transform ExportDefinitions into Services.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Integration.Mef.RegistrationExtensions.ResolveExports``1(Revenj.Extensibility.Autofac.IComponentContext)">
            <summary>
            Locate all of the MEF exports registered as supplying contract type T.
            </summary>
            <typeparam name="T">The contract type.</typeparam>
            <param name="context">The context to resolve exports from.</param>
            <returns>A list of exports.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Integration.Mef.RegistrationExtensions.ResolveExports``1(Revenj.Extensibility.Autofac.IComponentContext,System.String)">
            <summary>
            Locate all of the MEF exports registered as supplying contract type T.
            </summary>
            <param name="contractName">The contract name.</param>
            <param name="context">The context to resolve exports from.</param>
            <returns>A list of exports.</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Features.Scanning.ScanningActivatorData">
            <summary>
            Activation data for types located by scanning assemblies.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.Scanning.ScanningActivatorData.#ctor">
            <summary>
            Create an instance of <see cref="T:Revenj.Extensibility.Autofac.Features.Scanning.ScanningActivatorData"/>.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Features.Scanning.ScanningActivatorData.Filters">
            <summary>
            The filters applied to the types from the scanned assembly.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Features.Scanning.ScanningActivatorData.ConfigurationActions">
            <summary>
            Additional actions to be performed on the concrete type registrations.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Features.Scanning.ScanningActivatorData.PostScanningCallbacks">
            <summary>
            Actions to be called once the scanning operation is complete.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Features.GeneratedFactories.FactoryGenerator">
            <summary>
            Generates context-bound closures that represent factories from
            a set of heuristics based on delegate type signatures.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.GeneratedFactories.FactoryGenerator.#ctor(System.Type,Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.Features.GeneratedFactories.ParameterMapping)">
            <summary>
            Create a factory generator.
            </summary>
            <param name="service">The service that will be activated in
            order to create the products of the factory.</param>
            <param name="delegateType">The delegate to provide as a factory.</param>
            <param name="parameterMapping">The parameter mapping mode to use.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.GeneratedFactories.FactoryGenerator.#ctor(System.Type,Revenj.Extensibility.Autofac.Features.GeneratedFactories.ParameterMapping)">
            <summary>
            Create a factory generator.
            </summary>
            <param name="delegateType">The delegate to provide as a factory.</param>
            <param name="parameterMapping">The parameter mapping mode to use.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.GeneratedFactories.FactoryGenerator.GenerateFactory(Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.Core.IComponentRegistration,Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Generates a factory delegate that closes over the provided context.
            </summary>
            <param name="service">Service which is resolving</param>
            <param name="context">The context in which the factory will be used.</param>
            <param name="registration">Component registration</param>
            <param name="parameters">Parameters provided to the resolve call for the factory itself.</param>
            <returns>A factory delegate that will work within the context.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.GeneratedFactories.FactoryGenerator.GenerateFactory``1(Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.Core.IComponentRegistration,Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Generates a factory delegate that closes over the provided context.
            </summary>
            <param name="service">Service which is resolving</param>
            <param name="registration">Component registration</param>
            <param name="context">The context in which the factory will be used.</param>
            <param name="parameters">Parameters provided to the resolve call for the factory itself.</param>
            <returns>A factory delegate that will work within the context.</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.PreparingEventArgs">
            <summary>
            Fired before the activation process to allow parameters to be changed or an alternative
            instance to be provided.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.PreparingEventArgs.#ctor(Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.IComponentContext,Revenj.Extensibility.Autofac.Core.IComponentRegistration,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Core.PreparingEventArgs"/> class.
            </summary>
            <param name="service">Service which is preparing</param>
            <param name="context">The context.</param>
            <param name="component">The component.</param>
            <param name="parameters">The parameters.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.PreparingEventArgs.Service">
            <summary>
            The service on which the activation is occuring.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.PreparingEventArgs.Context">
            <summary>
            The context in which the activation is occurring.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.PreparingEventArgs.Component">
            <summary>
            The component providing the instance being activated.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.PreparingEventArgs.Parameters">
            <summary>
            The parameters supplied to the activator.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.TypeManipulation">
            <summary>
            Some handy type conversion routines.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.TypeManipulation.ChangeToCompatibleType(System.Object,System.Type)">
            <summary>
            Does its best to convert whatever the value is into the destination
            type. Null in yields null out for value types and the default(T)
            for value types (this may change.)
            </summary>
            <param name="value">The value.</param>
            <param name="destinationType">Type of the destination.</param>
            <returns>An object of the destination type.</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.FileElementCollection">
            <summary>
            A collection of file elements.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.FileElementCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Configuration.FileElementCollection"/> class.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Builder.RegistrationData">
            <summary>
            Data common to all registrations made in the container, both direct (IComponentRegistration)
            and dynamic (IRegistrationSource.)
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationData.#ctor(Revenj.Extensibility.Autofac.Core.Service)">
            <summary>
            Construct a RegistrationData instance.
            </summary>
            <param name="defaultService">The default service that will be used if no others
            are added.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationData.AddServices(System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Service})">
            <summary>
            Add multiple services for the registration, overriding the default.
            </summary>
            <param name="services">The services to add.</param>
            <remarks>If an empty collection is specified, this will still
            clear the default service.</remarks>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationData.AddService(Revenj.Extensibility.Autofac.Core.Service)">
            <summary>
            Add a service to the registration, overriding the default.
            </summary>
            <param name="service">The service to add.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationData.CopyFrom(Revenj.Extensibility.Autofac.Builder.RegistrationData,System.Boolean)">
            <summary>
            Copies the contents of another RegistrationData object into this one.
            </summary>
            <param name="that">The data to copy.</param>
            <param name="includeDefaultService">When true, the default service
            will be changed to that of the other.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationData.ClearServices">
            <summary>
            Empties the configured services.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.RegistrationData.Services">
            <summary>
            The services explicitly assigned to the component.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.RegistrationData.Ownership">
            <summary>
            The instance ownership assigned to the component.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.RegistrationData.Lifetime">
            <summary>
            The lifetime assigned to the component.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.RegistrationData.Sharing">
            <summary>
            The sharing mode assigned to the component.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.RegistrationData.Metadata">
            <summary>
            Extended properties assigned to the component.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.RegistrationData.PreparingHandlers">
            <summary>
            Handlers for the Preparing event.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.RegistrationData.ActivatingHandlers">
            <summary>
            Handlers for the Activating event.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.RegistrationData.ActivatedHandlers">
            <summary>
            Handlers for the Activated event.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.MD5">
            <summary>
            Common base class for all derived MD5 implementations.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.MD5.#ctor">
            <summary>
            Called from constructor of derived class.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.MD5.Create">
            <summary>
            Creates the default derived class.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlMediator">
            <summary>
             This class is responsible for serving as bridge between the backend
             protocol handling and the core classes. It is used as the mediator for
             exchanging data generated/sent from/to backend.
             </summary>
            
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDescribe">
             <summary>
             This class represents the Parse message sent to PostgreSQL
             server.
             </summary>
            
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Features.Metadata.Meta`2">
            <summary>
            Provides a value along with metadata describing the value.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <typeparam name="TMetadata">An interface to which metadata values can be bound.</typeparam>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.Metadata.Meta`2.#ctor(`0,`1)">
            <summary>
            Create a new instance.
            </summary>
            <param name="value">The value described by the instance.</param>
            <param name="metadata">The metadata describing the value.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Features.Metadata.Meta`2.Value">
            <summary>
            The value described by <see cref="P:Revenj.Extensibility.Autofac.Features.Metadata.Meta`2.Metadata"/>.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Features.Metadata.Meta`2.Metadata">
            <summary>
            Metadata describing the value.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Features.LazyDependencies.LazyRegistrationSource">
            <summary>
            Support the <see cref="T:System.Lazy`1"/> 
            type automatically whenever type T is registered with the container.
            When a dependency of a lazy type is used, the instantiation of the underlying
            component will be delayed until the Value property is first accessed.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.IDisposer">
            <summary>
            Provided on an object that will dispose of other objects when it is
            itself disposed.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.IDisposer.AddInstanceForDisposal(System.IDisposable)">
            <summary>
            Adds an object to the disposer. When the disposer is
            disposed, so will the object be.
            </summary>
            <param name="instance">The instance.</param>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Activators.Reflection.AutowiringParameter">
            <summary>
            Supplies values based on the target parameter type.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.Reflection.AutowiringParameter.CanSupplyValue(System.Reflection.ParameterInfo,Revenj.Extensibility.Autofac.IComponentContext,System.Func{System.Object}@)">
            <summary>
            Returns true if the parameter is able to provide a value to a particular site.
            </summary>
            <param name="pi">Constructor, method, or property-mutator parameter.</param>
            <param name="context">The component context in which the value is being provided.</param>
            <param name="valueProvider">If the result is true, the valueProvider parameter will
            be set to a function that will lazily retrieve the parameter value. If the result is false,
            will be set to null.</param>
            <returns>True if a value can be supplied; otherwise, false.</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.ParameterElementCollection">
            <summary>
            A collection of parameter elements.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.ParameterElementCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Configuration.ParameterElementCollection"/> class.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.ParameterElementCollection.ToParameters">
            <summary>
            Convert to the Autofac parameter type.
            </summary>
            <returns>The parameters represented by this collection.</returns>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">
            <summary>
             This class represents a parameter to a command that will be sent to server
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> class.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.#ctor(System.String,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see>
            class with the parameter m_Name and a value of the new <b>NpgsqlParameter</b>.
            </summary>
            <param m_Name="parameterName">The m_Name of the parameter to map.</param>
            <param m_Name="value">An <see cref="T:System.Object">Object</see> that is the value of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see>.</param>
            <remarks>
            <p>When you specify an <see cref="T:System.Object">Object</see>
            in the value parameter, the <see cref="T:System.Data.DbType">DbType</see> is
            inferred from the .NET Framework type of the <b>Object</b>.</p>
            <p>When using this constructor, you must be aware of a possible misuse of the constructor which takes a DbType parameter.
            This happens when calling this constructor passing an int 0 and the compiler thinks you are passing a value of DbType.
            Use <code> Convert.ToInt32(value) </code> for example to have compiler calling the correct constructor.</p>
            </remarks>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.#ctor(System.String,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlDbType)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see>
            class with the parameter m_Name and the data type.
            </summary>
            <param m_Name="parameterName">The m_Name of the parameter to map.</param>
            <param m_Name="parameterType">One of the <see cref="T:System.Data.DbType">DbType</see> values.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.#ctor(System.String,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlDbType,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see>
            class with the parameter m_Name, the <see cref="T:System.Data.DbType">DbType</see>, and the size.
            </summary>
            <param m_Name="parameterName">The m_Name of the parameter to map.</param>
            <param m_Name="parameterType">One of the <see cref="T:System.Data.DbType">DbType</see> values.</param>
            <param m_Name="size">The length of the parameter.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.#ctor(System.String,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlDbType,System.Int32,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see>
            class with the parameter m_Name, the <see cref="T:System.Data.DbType">DbType</see>, the size,
            and the source column m_Name.
            </summary>
            <param m_Name="parameterName">The m_Name of the parameter to map.</param>
            <param m_Name="parameterType">One of the <see cref="T:System.Data.DbType">DbType</see> values.</param>
            <param m_Name="size">The length of the parameter.</param>
            <param m_Name="sourceColumn">The m_Name of the source column.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.#ctor(System.String,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlDbType,System.Int32,System.String,System.Data.ParameterDirection,System.Boolean,System.Byte,System.Byte,System.Data.DataRowVersion,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see>
            class with the parameter m_Name, the <see cref="T:System.Data.DbType">DbType</see>, the size,
            the source column m_Name, a <see cref="T:System.Data.ParameterDirection">ParameterDirection</see>,
            the precision of the parameter, the scale of the parameter, a
            <see cref="T:System.Data.DataRowVersion">DataRowVersion</see> to use, and the
            value of the parameter.
            </summary>
            <param m_Name="parameterName">The m_Name of the parameter to map.</param>
            <param m_Name="parameterType">One of the <see cref="T:System.Data.DbType">DbType</see> values.</param>
            <param m_Name="size">The length of the parameter.</param>
            <param m_Name="sourceColumn">The m_Name of the source column.</param>
            <param m_Name="direction">One of the <see cref="T:System.Data.ParameterDirection">ParameterDirection</see> values.</param>
            <param m_Name="isNullable"><b>true</b> if the value of the field can be null, otherwise <b>false</b>.</param>
            <param m_Name="precision">The total number of digits to the left and right of the decimal point to which
            <see cref="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.Value">Value</see> is resolved.</param>
            <param m_Name="scale">The total number of decimal places to which
            <see cref="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.Value">Value</see> is resolved.</param>
            <param m_Name="sourceVersion">One of the <see cref="T:System.Data.DataRowVersion">DataRowVersion</see> values.</param>
            <param m_Name="value">An <see cref="T:System.Object">Object</see> that is the value
            of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see>.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.Clone">
            <summary>
            Creates a new <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> that
            is a copy of the current instance.
            </summary>
            <returns>A new <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see> that is a copy of this instance.</returns>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.Precision">
            <summary>
            Gets or sets the maximum number of digits used to represent the
            <see cref="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.Value">Value</see> property.
            </summary>
            <value>The maximum number of digits used to represent the
            <see cref="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.Value">Value</see> property.
            The default value is 0, which indicates that the data provider
            sets the precision for <b>Value</b>.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.Scale">
            <summary>
            Gets or sets the number of decimal places to which
            <see cref="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.Value">Value</see> is resolved.
            </summary>
            <value>The number of decimal places to which
            <see cref="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.Value">Value</see> is resolved. The default is 0.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.Size">
            <summary>
            Gets or sets the maximum size, in bytes, of the data within the column.
            </summary>
            <value>The maximum size, in bytes, of the data within the column.
            The default value is inferred from the parameter value.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.DbType">
            <summary>
            Gets or sets the <see cref="T:System.Data.DbType">DbType</see> of the parameter.
            </summary>
            <value>One of the <see cref="T:System.Data.DbType">DbType</see> values. The default is <b>String</b>.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.NpgsqlDbType">
            <summary>
            Gets or sets the <see cref="T:System.Data.DbType">DbType</see> of the parameter.
            </summary>
            <value>One of the <see cref="T:System.Data.DbType">DbType</see> values. The default is <b>String</b>.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.Direction">
            <summary>
            Gets or sets a value indicating whether the parameter is input-only,
            output-only, bidirectional, or a stored procedure return value parameter.
            </summary>
            <value>One of the <see cref="T:System.Data.ParameterDirection">ParameterDirection</see>
            values. The default is <b>Input</b>.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.IsNullable">
            <summary>
            Gets or sets a value indicating whether the parameter accepts null values.
            </summary>
            <value><b>true</b> if null values are accepted; otherwise, <b>false</b>. The default is <b>false</b>.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.ParameterName">
            <summary>
            Gets or sets the m_Name of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see>.
            </summary>
            <value>The m_Name of the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter">NpgsqlParameter</see>.
            The default is an empty string.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.CleanName">
            <summary>
            The m_Name scrubbed of any optional marker
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.SourceColumn">
            <summary>
            Gets or sets the m_Name of the source column that is mapped to the
            <see cref="T:System.Data.DataSet">DataSet</see> and used for loading or
            returning the <see cref="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.Value">Value</see>.
            </summary>
            <value>The m_Name of the source column that is mapped to the
            <see cref="T:System.Data.DataSet">DataSet</see>. The default is an empty string.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.SourceVersion">
            <summary>
            Gets or sets the <see cref="T:System.Data.DataRowVersion">DataRowVersion</see>
            to use when loading <see cref="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.Value">Value</see>.
            </summary>
            <value>One of the <see cref="T:System.Data.DataRowVersion">DataRowVersion</see> values.
            The default is <b>Current</b>.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.Value">
            <summary>
            Gets or sets the value of the parameter.
            </summary>
            <value>An <see cref="T:System.Object">Object</see> that is the value of the parameter.
            The default value is null.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameter.NpgsqlValue">
            <summary>
            Gets or sets the value of the parameter.
            </summary>
            <value>An <see cref="T:System.Object">Object</see> that is the value of the parameter.
            The default value is null.</value>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlRowUpdatedEventHandler">
            <summary>
            Represents the method that handles the <see cref="E:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataAdapter.RowUpdated">RowUpdated</see> events.
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="e">A <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlRowUpdatedEventArgs">NpgsqlRowUpdatedEventArgs</see> that contains the event data.</param>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlRowUpdatingEventHandler">
            <summary>
            Represents the method that handles the <see cref="E:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataAdapter.RowUpdating">RowUpdating</see> events.
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="e">A <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlRowUpdatingEventArgs">NpgsqlRowUpdatingEventArgs</see> that contains the event data.</param>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataAdapter">
            <summary>
            This class represents an adapter from many commands: select, update, insert and delete to fill <see cref="T:System.Data.DataSet">Datasets.</see>
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlExecute">
             <summary>
             This class represents the Parse message sent to PostgreSQL
             server.
             </summary>
            
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.Cache`1.CacheSize">
            <summary>
            Set Cache Size. The default value is 20.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.Cache`1.Item(System.String)">
            <summary>
            Lookup cached entity. null will returned if not match.
            For both get{} and set{} apply LRU rule.
            </summary>
            <param name="key">key</param>
            <returns></returns>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.TypeConverter">
            <summary>
            Exposed type converter for outside usage.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.TypeConverter.CanConvert(System.Type)">
            <summary>
            Check if Npgsql support .NET type conversion to Postgres type
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.TypeConverter.Convert(System.Type,System.Object)">
            <summary>
            Convert .NET type to Postgres string representation
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.TypeConverter.GetTypeName(System.Type)">
            <summary>
            Convert Postgres type name for .NET type
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Util.ReflectionExtensions">
            <summary>
            Extension methods for reflection-related types.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Util.ReflectionExtensions.TryGetDeclaringProperty(System.Reflection.ParameterInfo,System.Reflection.PropertyInfo@)">
            <summary>
            Maps from a property-set-value parameter to the declaring property.
            </summary>
            <param name="pi">Parameter to the property setter.</param>
            <param name="prop">The property info on which the setter is specified.</param>
            <returns>True if the parameter is a property setter.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Util.ReflectionExtensions.GetProperty``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Get a PropertyInfo object from an expression of the form
            x =&gt; x.P.
            </summary>
            <typeparam name="TDeclaring">Type declaring the property.</typeparam>
            <typeparam name="TProperty">The type of the property.</typeparam>
            <param name="propertyAccessor">Expression mapping an instance of the
            declaring type to the property value.</param>
            <returns>Property info.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Util.ReflectionExtensions.GetMethod``1(System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>
            Get the MethodInfo for a method called in the
            expression.
            </summary>
            <typeparam name="TDeclaring">Type on which the method is called.</typeparam>
            <param name="methodCallExpression">Expression demonstrating how the method appears.</param>
            <returns>The method info for the called method.</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.NamedParameter">
            <summary>
            A parameter identified by name. When applied to a reflection-based
            component, <see cref="P:Revenj.Extensibility.Autofac.NamedParameter.Name"/> will be matched against
            the name of the component's constructor arguments. When applied to
            a delegate-based component, the parameter can be accessed using
            <see cref="M:Revenj.Extensibility.Autofac.ParameterExtensions.Named``1(System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},System.String)"/>.
            </summary>
            <example>
            Component with parameter:
            <code>
            public class MyComponent
            {
                public MyComponent(int amount) { ... }
            }
            </code>
            Providing the parameter:
            <code>
            var builder = new ContainerBuilder();
            builder.RegisterType&lt;MyComponent&gt;();
            var container = builder.Build();
            var myComponent = container.Resolve&lt;MyComponent&gt;(new NamedParameter("amount", 123));
            </code>
            </example>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.NamedParameter.#ctor(System.String,System.Object)">
            <summary>
            Create a <see cref="T:Revenj.Extensibility.Autofac.NamedParameter"/> with the specified constant value.
            </summary>
            <param name="name">The name of the parameter.</param>
            <param name="value">The parameter value.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.NamedParameter.Name">
            <summary>
            The name of the parameter.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Features.Metadata.StronglyTypedMetaRegistrationSource">
            <summary>
            Support the <see cref="T:Revenj.Extensibility.Autofac.Features.Metadata.Meta`2"/>
            types automatically whenever type T is registered with the container.
            Metadata values come from the component registration's metadata.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScopeBeginningEventArgs">
            <summary>
            Describes when a lifetime scope is beginning.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScopeBeginningEventArgs.#ctor(Revenj.Extensibility.Autofac.ILifetimeScope)">
            <summary>
            Create an instance of the <see cref="T:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScopeBeginningEventArgs"/> class.
            </summary>
            <param name="lifetimeScope">The lifetime scope that is beginning.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Lifetime.LifetimeScopeBeginningEventArgs.LifetimeScope">
            <summary>
            The lifetime scope that is beginning.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Activators.Delegate.DelegateActivator">
            <summary>
            Activate instances using a delegate.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.Delegate.DelegateActivator.#ctor(System.Type,System.Func{Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},System.Object})">
            <summary>
            Create a delegate activator.
            </summary>
            <param name="limitType">The most specific type to which activated instances can be cast.</param>
            <param name="activationFunction">Activation delegate.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.Delegate.DelegateActivator.GetFactory(Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Activate an instance in the provided context.
            </summary>
            <param name="context">Context in which to activate instances.</param>
            <param name="parameters">Parameters to the instance.</param>
            <returns>The activated instance.</returns>
            <remarks>
            The context parameter here should probably be ILifetimeScope in order to reveal Disposer,
            but will wait until implementing a concrete use case to make the decision
            </remarks>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.AssemblyElement">
            <summary>
            Element describing a module registration.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.AssemblyElement.Assembly">
            <summary>
            Gets the name of the assembly
            </summary>
            <value>The assembly name.</value>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder">
            <summary>
            Static factory methods to simplify the creation and handling of IRegistrationBuilder{L,A,R}.
            </summary>
            <example>
            To create an <see cref="T:Revenj.Extensibility.Autofac.Core.IComponentRegistration"/> for a specific type, use:
            <code>
            var cr = RegistrationBuilder.ForType(t).CreateRegistration();
            </code>
            The full builder syntax is supported:
            <code>
            var cr = RegistrationBuilder.ForType(t).Named("foo").ExternallyOwned().CreateRegistration();
            </code>
            </example>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder.ForDelegate``1(System.Func{Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},``0})">
            <summary>
            Creates a registration builder for the provided delegate.
            </summary>
            <typeparam name="T">Instance type returned by delegate.</typeparam>
            <param name="delegate">Delegate to register.</param>
            <returns>A registration builder.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder.ForDelegate(System.Type,System.Func{Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},System.Object})">
            <summary>
            Creates a registration builder for the provided delegate.
            </summary>
            <param name="delegate">Delegate to register.</param>
            <param name="limitType">Most specific type return value of delegate can be cast to.</param>
            <returns>A registration builder.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder.ForType``1">
            <summary>
            Creates a registration builder for the provided type.
            </summary>
            <typeparam name="TImplementor">Implementation type to register.</typeparam>
            <returns>A registration builder.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder.ForType(System.Type)">
            <summary>
            Creates a registration builder for the provided type.
            </summary>
            <param name="implementationType">Implementation type to register.</param>
            <returns>A registration builder.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder.CreateRegistration``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2})">
            <summary>
            Create an <see cref="T:Revenj.Extensibility.Autofac.Core.IComponentRegistration"/> from a <see cref="T:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder"/>.
            (There is no need to call
            this method when registering components through a <see cref="T:Revenj.Extensibility.Autofac.ContainerBuilder"/>.)
            </summary>
            <remarks>
            When called on the result of one of the <see cref="T:Revenj.Extensibility.Autofac.ContainerBuilder"/> methods,
            the returned registration will be different from the one the builder itself registers
            in the container.
            </remarks>
            <example>
            <code>
            var registration = RegistrationBuilder.ForType&lt;Foo&gt;().CreateRegistration();
            </code>
            </example>
            <typeparam name="TLimit"></typeparam>
            <typeparam name="TActivatorData"></typeparam>
            <typeparam name="TSingleRegistrationStyle"></typeparam>
            <param name="rb">The registration builder.</param>
            <returns>An IComponentRegistration.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder.CreateRegistration(System.Guid,Revenj.Extensibility.Autofac.Builder.RegistrationData,Revenj.Extensibility.Autofac.Core.IInstanceActivator,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Service})">
            <summary>
            Create an IComponentRegistration from data.
            </summary>
            <param name="id">Id of the registration.</param>
            <param name="data">Registration data.</param>
            <param name="activator">Activator.</param>
            <param name="services">Services provided by the registration.</param>
            <returns>An IComponentRegistration.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder.CreateRegistration(System.Guid,Revenj.Extensibility.Autofac.Builder.RegistrationData,Revenj.Extensibility.Autofac.Core.IInstanceActivator,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Service},Revenj.Extensibility.Autofac.Core.IComponentRegistration)">
            <summary>
            Create an IComponentRegistration from data.
            </summary>
            <param name="id">Id of the registration.</param>
            <param name="data">Registration data.</param>
            <param name="activator">Activator.</param>
            <param name="services">Services provided by the registration.</param>
            <param name="target">Optional; target registration.</param>
            <returns>An IComponentRegistration.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder.RegisterSingleComponent``3(Revenj.Extensibility.Autofac.Core.IComponentRegistry,Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2})">
            <summary>
            Register a component in the component registry. This helper method is necessary
            in order to execute OnRegistered hooks and respect PreserveDefaults. 
            </summary>
            <remarks>Hoping to refactor this out.</remarks>
            <typeparam name="TLimit"></typeparam>
            <typeparam name="TActivatorData"></typeparam>
            <typeparam name="TSingleRegistrationStyle"></typeparam>
            <param name="cr">Component registry to make registration in.</param>
            <param name="rb">Registration builder with data for new registration.</param>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Builder.MetadataConfiguration`1">
            <summary>
            Used with the WithMetadata configuration method to
            associate key-value pairs with an <see cref="T:Revenj.Extensibility.Autofac.Core.IComponentRegistration"/>.
            </summary>
            <typeparam name="TMetadata">Interface with properties whose names correspond to
            the property keys.</typeparam>
            <remarks>This feature was suggested by OJ Reeves (@TheColonial).</remarks>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.MetadataConfiguration`1.For``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},``0)">
            <summary>
            Set one of the property values.
            </summary>
            <typeparam name="TProperty">The type of the property.</typeparam>
            <param name="propertyAccessor">An expression that accesses the property to set.</param>
            <param name="value">The property value to set.</param>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInState">
            <summary>
            Represents an ongoing COPY FROM STDIN operation.
            Provides methods to push data to server and end or cancel the operation.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInState.StartCopy(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector,Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyFormat)">
            <summary>
            Called from NpgsqlState.ProcessBackendResponses upon CopyInResponse.
            If CopyStream is already set, it is used to read data to push to server, after which the copy is completed.
            Otherwise CopyStream is set to a writable NpgsqlCopyInStream that calls SendCopyData each time it is written to.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInState.SendCopyData(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sends given packet to server as a CopyData message.
            Does not check for notifications! Use another thread for that.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInState.SendCopyDone(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector)">
            <summary>
            Sends CopyDone message to server. Handles responses, ie. may throw an exception.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInState.SendCopyFail(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector,System.String)">
            <summary>
            Sends CopyFail message to server. Handles responses, ie. should always throw an exception:
            in CopyIn state the server responds to CopyFail with an error response;
            outside of a CopyIn state the server responds to CopyFail with an error response;
            without network connection or whatever, there's going to eventually be a failure, timeout or user intervention.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInState.CopyFormat">
            <summary>
            Copy format information returned from server.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlTransaction">
            <summary>
            Represents a transaction to be made in a PostgreSQL database. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlTransaction.Commit">
            <summary>
            Commits the database transaction.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlTransaction.Rollback">
            <summary>
            Rolls back a transaction from a pending state.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlTransaction.Rollback(System.String)">
            <summary>
            Rolls back a transaction from a pending savepoint state.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlTransaction.Save(System.String)">
            <summary>
            Creates a transaction save point.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlTransaction.Cancel">
            <summary>
            Cancel the transaction without telling the backend about it.  This is
            used to make the transaction go away when closing a connection.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlTransaction.Connection">
            <summary>
            Gets the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection">NpgsqlConnection</see>
            object associated with the transaction, or a null reference if the
            transaction is no longer valid.
            </summary>
            <value>The <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection">NpgsqlConnection</see>
            object associated with the transaction.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlTransaction.IsolationLevel">
            <summary>
            Specifies the <see cref="T:System.Data.IsolationLevel">IsolationLevel</see> for this transaction.
            </summary>
            <value>The <see cref="T:System.Data.IsolationLevel">IsolationLevel</see> for this transaction.
            The default is <b>ReadCommitted</b>.</value>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopySerializer">
            <summary>
            Writes given objects into a stream for PostgreSQL COPY in default copy format (not CSV or BINARY).
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTypesHelper">
            <summary>
            This class contains helper methods for type conversion between
            the .Net type system and postgresql.
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTypesHelper.BackendTypeMappingCache">
            <summary>
            A cache of basic datatype mappings keyed by server version.  This way we don't
            have to load the basic type mappings for every connection.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTypesHelper.TryGetBackendTypeInfo(System.String,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo@)">
            <summary>
            Find a NpgsqlNativeTypeInfo in the default types map that can handle objects
            of the given NpgsqlDbType.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTypesHelper.TryGetNativeTypeInfo(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlDbType,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo@)">
            <summary>
            Find a NpgsqlNativeTypeInfo in the default types map that can handle objects
            of the given NpgsqlDbType.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTypesHelper.TryGetNativeTypeInfo(System.Data.DbType,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo@)">
            <summary>
            Find a NpgsqlNativeTypeInfo in the default types map that can handle objects
            of the given DbType.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTypesHelper.TryGetNativeTypeInfo(System.Type,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo@)">
            <summary>
            Find a NpgsqlNativeTypeInfo in the default types map that can handle objects
            of the given System.Type.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTypesHelper.ConvertBackendStringToSystemType(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo,System.IO.StreamReader,System.Int16,System.Int32)">
            <summary>
             This method is responsible to convert the string received from the backend
             to the corresponding NpgsqlType.
             The given TypeInfo is called upon to do the conversion.
             If no TypeInfo object is provided, no conversion is performed.
             </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTypesHelper.PrepareDefaultTypesMap">
            <summary>
            Create the one and only native to backend type map.
            This map is used when formatting native data
            types to backend representations.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTypesHelper.CreateAndLoadInitialTypesMapping(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector)">
            <summary>
             This method creates (or retrieves from cache) a mapping between type and OID 
             of all natively supported postgresql data types.
             This is needed as from one version to another, this mapping can be changed and
             so we avoid hardcoding them.
             </summary>
             <returns>NpgsqlTypeMapping containing all known data types.  The mapping must be
             cloned before it is modified because it is cached; changes made by one connection may
             effect another connection.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTypesHelper.LoadTypesMappings(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeMapping,System.Collections.Generic.IEnumerable{Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo})">
            <summary>
            Attempt to map types by issuing a query against pg_type.
            This function takes a list of NpgsqlTypeInfo and attempts to resolve the OID field
            of each by querying pg_type.  If the mapping is found, the type info object is
            updated (OID) and added to the provided NpgsqlTypeMapping object.
            </summary>
            <param name="conn">NpgsqlConnector to send query through.</param>
            <param name="TypeMappings">Mapping object to add types too.</param>
            <param name="TypeInfoList">List of types that need to have OID's mapped.</param>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ConvertBackendToNativeHandler">
            <summary>
            Delegate called to convert the given backend data to its native representation.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ConvertNativeToBackendHandler">
            <summary>
            Delegate called to convert the given native data to its backand representation.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo">
            <summary>
            Represents a backend data type.
            This class can be called upon to convert a backend field representation to a native object.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo.#ctor(System.Int32,System.String,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlDbType,System.Data.DbType,System.Type,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ConvertBackendToNativeHandler)">
            <summary>
            Construct a new NpgsqlTypeInfo with the given attributes and conversion handlers.
            </summary>
            <param name="OID">Type OID provided by the backend server.</param>
            <param name="Name">Type name provided by the backend server.</param>
            <param name="NpgsqlDbType">NpgsqlDbType</param>
            <param name="Type">System type to convert fields of this type to.</param>
            <param name="ConvertBackendToNative">Data conversion handler.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo.ConvertToNative(System.String,System.Int16,System.Int32)">
            <summary>
            Perform a data conversion from a backend representation to 
            a native object.
            </summary>
            <param name="BackendData">Data sent from the backend.</param>
            <param name="TypeModifier">Type modifier field sent from the backend.</param>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo.OID">
            <summary>
            Type OID provided by the backend server.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo.Name">
            <summary>
            Type name provided by the backend server.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo.NpgsqlDbType">
            <summary>
            NpgsqlDbType.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo.DbType">
            <summary>
            NpgsqlDbType.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo.Type">
            <summary>
            Provider type to convert fields of this type to.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo.FrameworkType">
            <summary>
            System type to convert fields of this type to.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo">
            <summary>
            Represents a backend data type.
            This class can be called upon to convert a native object to its backend field representation,
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo.ArrayOf(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo)">
            <summary>
            Returns an NpgsqlNativeTypeInfo for an array where the elements are of the type
            described by the NpgsqlNativeTypeInfo supplied.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo.#ctor(System.String,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlDbType,System.Data.DbType,System.Boolean,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ConvertNativeToBackendHandler)">
            <summary>
            Construct a new NpgsqlTypeInfo with the given attributes and conversion handlers.
            </summary>
            <param name="Name">Type name provided by the backend server.</param>
            <param name="NpgsqlDbType">NpgsqlDbType</param>
            <param name="ConvertNativeToBackend">Data conversion handler.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo.ConvertToBackend(System.Object,System.Boolean)">
            <summary>
            Perform a data conversion from a native object to
            a backend representation.
            DBNull and null values are handled differently depending if a plain query is used
            When 
            </summary>
            <param name="NativeData">Native .NET object to be converted.</param>
            <param name="ForExtendedQuery">Flag indicating if the conversion has to be done for 
            plain queries or extended queries</param>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo.Name">
            <summary>
            Type name provided by the backend server.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo.NpgsqlDbType">
            <summary>
            NpgsqlDbType.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo.DbType">
            <summary>
            DbType.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo.Quote">
            <summary>
            Apply quoting.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo.UseSize">
            <summary>
            Use parameter size information.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeMapping">
            <summary>
            Provide mapping between type OID, type name, and a NpgsqlBackendTypeInfo object that represents it.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeMapping.#ctor">
            <summary>
            Construct an empty mapping.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeMapping.#ctor(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeMapping)">
            <summary>
            Copy constuctor.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeMapping.AddType(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo)">
            <summary>
            Add the given NpgsqlBackendTypeInfo to this mapping.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeMapping.AddType(System.Int32,System.String,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlDbType,System.Data.DbType,System.Type,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ConvertBackendToNativeHandler)">
            <summary>
            Add a new NpgsqlBackendTypeInfo with the given attributes and conversion handlers to this mapping.
            </summary>
            <param name="OID">Type OID provided by the backend server.</param>
            <param name="Name">Type name provided by the backend server.</param>
            <param name="NpgsqlDbType">NpgsqlDbType</param>
            <param name="Type">System type to convert fields of this type to.</param>
            <param name="BackendConvert">Data conversion handler.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeMapping.Clone">
            <summary>
            Make a shallow copy of this type mapping.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeMapping.ContainsOID(System.Int32)">
            <summary>
            Determine if a NpgsqlBackendTypeInfo with the given backend type OID exists in this mapping.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeMapping.ContainsName(System.String)">
            <summary>
            Determine if a NpgsqlBackendTypeInfo with the given backend type name exists in this mapping.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeMapping.Count">
            <summary>
            Get the number of type infos held.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeMapping.Item(System.Int32)">
            <summary>
            Retrieve the NpgsqlBackendTypeInfo with the given backend type OID, or null if none found.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeMapping.Item(System.String)">
            <summary>
            Retrieve the NpgsqlBackendTypeInfo with the given backend type name, or null if none found.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeMapping">
            <summary>
            Provide mapping between type Type, NpgsqlDbType and a NpgsqlNativeTypeInfo object that represents it.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeMapping.AddType(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo)">
            <summary>
            Add the given NpgsqlNativeTypeInfo to this mapping.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeMapping.AddType(System.String,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlDbType,System.Data.DbType,System.Boolean,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ConvertNativeToBackendHandler)">
            <summary>
            Add a new NpgsqlNativeTypeInfo with the given attributes and conversion handlers to this mapping.
            </summary>
            <param name="Name">Type name provided by the backend server.</param>
            <param name="NpgsqlDbType">NpgsqlDbType</param>
            <param name="NativeConvert">Data conversion handler.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeMapping.TryGetValue(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlDbType,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo@)">
            <summary>
            Retrieve the NpgsqlNativeTypeInfo with the given NpgsqlDbType.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeMapping.TryGetValue(System.Data.DbType,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo@)">
            <summary>
            Retrieve the NpgsqlNativeTypeInfo with the given DbType.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeMapping.TryGetValue(System.Type,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo@)">
            <summary>
            Retrieve the NpgsqlNativeTypeInfo with the given Type.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeMapping.ContainsName(System.String)">
            <summary>
            Determine if a NpgsqlNativeTypeInfo with the given backend type name exists in this mapping.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeMapping.ContainsNpgsqlDbType(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlDbType)">
            <summary>
            Determine if a NpgsqlNativeTypeInfo with the given NpgsqlDbType exists in this mapping.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeMapping.ContainsType(System.Type)">
            <summary>
            Determine if a NpgsqlNativeTypeInfo with the given Type name exists in this mapping.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeMapping.Count">
            <summary>
            Get the number of type infos held.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Util.WindowsPhone.Wp7FactoryGenerator">
            <summary>
            Generates context-bound closures that represent factories from
            a set of heuristics based on delegate type signatures.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Util.WindowsPhone.Wp7FactoryGenerator.#ctor(System.Type,Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.Features.GeneratedFactories.ParameterMapping)">
            <summary />
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Util.WindowsPhone.Wp7FactoryGenerator.#ctor(System.Type,Revenj.Extensibility.Autofac.Core.IComponentRegistration,Revenj.Extensibility.Autofac.Features.GeneratedFactories.ParameterMapping)">
            <summary />
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Util.WindowsPhone.Wp7FactoryGenerator.GenerateFactory(Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Generates a factory delegate that closes over the provided context.
            </summary>
            <param name="context">The context in which the factory will be used.</param>
            <param name="parameters">Parameters provided to the resolve call for the factory itself.</param>
            <returns>A factory delegate that will work within the context.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Util.WindowsPhone.Wp7FactoryGenerator.GenerateFactory``1(Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Generates a factory delegate that closes over the provided context.
            </summary>
            <param name="context">The context in which the factory will be used.</param>
            <param name="parameters">Parameters provided to the resolve call for the factory itself.</param>
            <returns>A factory delegate that will work within the context.</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.TypedParameter">
            <summary>
            A parameter that can supply values to sites that exactly
            match a specified type. When applied to a reflection-based
            component, <see cref="P:Revenj.Extensibility.Autofac.TypedParameter.Type"/> will be matched against
            the types of the component's constructor arguments. When applied to
            a delegate-based component, the parameter can be accessed using
            <see cref="M:Revenj.Extensibility.Autofac.ParameterExtensions.TypedAs``1(System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})"/>.
            </summary>
            <example>
            Component with parameter:
            <code>
            public class MyComponent
            {
                public MyComponent(int amount) { ... }
            }
            </code>
            Providing the parameter:
            <code>
            var builder = new ContainerBuilder();
            builder.RegisterType&lt;MyComponent&gt;();
            var container = builder.Build();
            var myComponent = container.Resolve&lt;MyComponent&gt;(new TypedParameter(typeof(int), 123));
            </code>
            </example>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.TypedParameter.#ctor(System.Type,System.Object)">
            <summary>
            Create a typed parameter with the specified constant value.
            </summary>
            <param name="type">The exact type to match.</param>
            <param name="value">The parameter value.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.TypedParameter.From``1(``0)">
            <summary>
            Shortcut for creating <see cref="T:Revenj.Extensibility.Autofac.TypedParameter"/> 
            by using the <typeparamref name="T"/>
            </summary>
            <typeparam name="T">type to be used for the parameter</typeparam>
            <param name="value">The parameter value.</param>
            <returns>new typed parameter</returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.TypedParameter.Type">
            <summary>
            The type against which targets are matched.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.KeyedService">
            <summary>
            Identifies a service using a key in addition to its type.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.IServiceWithType">
            <summary>
            Interface supported by services that carry type information.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.IServiceWithType.ChangeType(System.Type)">
            <summary>
            Return a new service of the same kind, but carrying
            <paramref name="newType"/> as the <see cref="P:Revenj.Extensibility.Autofac.Core.IServiceWithType.ServiceType"/>.
            </summary>
            <param name="newType">The new service type.</param>
            <returns>A new service with the service type.</returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IServiceWithType.ServiceType">
            <summary>
            Gets the type of the service.
            </summary>
            <value>The type of the service.</value>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.KeyedService.#ctor(System.Object,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Core.KeyedService"/> class.
            </summary>
            <param name="serviceKey">Key of the service.</param>
            <param name="serviceType">Type of the service.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.KeyedService.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">The <paramref name="obj"/> parameter is null.</exception>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.KeyedService.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.KeyedService.ChangeType(System.Type)">
            <summary>
            Return a new service of the same kind, but carrying
            <paramref name="newType"/> as the <see cref="P:Revenj.Extensibility.Autofac.Core.KeyedService.ServiceType"/>.
            </summary>
            <param name="newType">The new service type.</param>
            <returns>A new service with the service type.</returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.KeyedService.ServiceKey">
            <summary>
            Gets or sets the key of the service.
            </summary>
            <value>The key of the service.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.KeyedService.ServiceType">
            <summary>
            Gets the type of the service.
            </summary>
            <value>The type of the service.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.KeyedService.Description">
            <summary>
            Gets a human-readable description of the service.
            </summary>
            <value>The description.</value>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Activators.Reflection.DefaultValueParameter">
            <summary>
            Provides parameters that have a default value, set with an optional parameter
            declaration in C# or VB.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.Reflection.DefaultValueParameter.CanSupplyValue(System.Reflection.ParameterInfo,Revenj.Extensibility.Autofac.IComponentContext,System.Func{System.Object}@)">
            <summary>
            Returns true if the parameter is able to provide a value to a particular site.
            </summary>
            <param name="pi">Constructor, method, or property-mutator parameter.</param>
            <param name="context">The component context in which the value is being provided.</param>
            <param name="valueProvider">If the result is true, the valueProvider parameter will
            be set to a function that will lazily retrieve the parameter value. If the result is false,
            will be set to null.</param>
            <returns>True if a value can be supplied; otherwise, false.</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Activators.ProvidedInstance.ProvidedInstanceActivator">
            <summary>
            Provides a pre-constructed instance.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.ProvidedInstance.ProvidedInstanceActivator.#ctor(System.Object)">
            <summary>
            Provide the specified instance.
            </summary>
            <param name="instance">The instance to provide.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.ProvidedInstance.ProvidedInstanceActivator.GetFactory(Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Activate an instance in the provided context.
            </summary>
            <param name="context">Context in which to activate instances.</param>
            <param name="parameters">Parameters to the instance.</param>
            <returns>The activated instance.</returns>
            <remarks>
            The context parameter here should probably be ILifetimeScope in order to reveal Disposer,
            but will wait until implementing a concrete use case to make the decision
            </remarks>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.ProvidedInstance.ProvidedInstanceActivator.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Activators.ProvidedInstance.ProvidedInstanceActivator.DisposeInstance">
            <summary>
            Determines whether the activator disposes the instance that it holds.
            Necessary because otherwise instances that are never resolved will never be
            disposed.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Builder.SingleRegistrationStyle">
            <summary>
            Registration style for individual components.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.SingleRegistrationStyle.Id">
            <summary>
            The id used for the registration.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.SingleRegistrationStyle.RegisteredHandlers">
            <summary>
            Handlers to notify of the component registration event.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.SingleRegistrationStyle.PreserveDefaults">
            <summary>
            By default, new registrations override existing registrations as defaults.
            If set to true, new registrations will not change existing defaults.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.SingleRegistrationStyle.Target">
            <summary>
            The component upon which this registration is based.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Builder.DynamicRegistrationStyle">
            <summary>
            Registration style for dynamic registrations.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlStartupPacket">
             <summary>
             This class represents a StartupPacket message of PostgreSQL
             protocol.
             </summary>
            
        </member>
        <member name="T:DryIoc.MefAttributedModel.ReuseAttribute">
            <summary>Base attribute to specify type of reuse (implementing <see cref="T:DryIoc.IReuse"/>) for annotated class.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.ReuseAttribute.ReuseType">
            <summary>Implementation of reuse. Could be null to specify transient or no reuse.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.ReuseAttribute.ReuseName">
            <summary>Optional name, valid only for Current Scope Reuse.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.ReuseAttribute.#ctor(System.Type,System.String)">
            <summary>Create attribute with specified type implementing reuse.</summary>
            <param name="reuseType">Could be null to specify transient or no reuse.</param>
            <param name="reuseName">(optional) Name is valid only for Current Scope Reuse and will be ignored by the rest of reuse types.</param>
        </member>
        <member name="T:DryIoc.MefAttributedModel.TransientReuseAttribute">
            <summary>Defines the Transient reuse for exported service.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.TransientReuseAttribute.#ctor">
            <summary>Creates attribute by specifying null as <see cref="F:DryIoc.MefAttributedModel.ReuseAttribute.ReuseType"/>.</summary>
        </member>
        <member name="T:DryIoc.MefAttributedModel.SingletonReuseAttribute">
            <summary>Denotes exported type with Singleton reuse.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.SingletonReuseAttribute.#ctor">
            <summary>Creates attribute.</summary>
        </member>
        <member name="T:DryIoc.MefAttributedModel.CurrentScopeReuseAttribute">
            <summary>Denotes exported type with Current Scope Reuse.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.CurrentScopeReuseAttribute.#ctor(System.String)">
            <summary>Creates attribute.</summary> <param name="reuseName">(optional)</param>
        </member>
        <member name="T:DryIoc.MefAttributedModel.WebRequestReuseAttribute">
            <summary>Marks exported type with Reuse.InWebRequest. 
            Basically it is CurrentScopeReuse with predefined name <see cref="F:DryIoc.Reuse.WebRequestScopeName"/>.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.WebRequestReuseAttribute.#ctor">
            <summary>Creates attribute.</summary>
        </member>
        <member name="T:DryIoc.MefAttributedModel.ThreadReuseAttribute">
            <summary>Marks exported type with Reuse.InThread. 
            Basically it is CurrentScopeReuse with predefined name <see cref="F:DryIoc.ThreadScopeContext.ScopeContextName"/>.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.ThreadReuseAttribute.#ctor">
            <summary>Creates attribute.</summary>
        </member>
        <member name="T:DryIoc.MefAttributedModel.ResolutionScopeReuseAttribute">
            <summary>Denotes exported type with Resolution Scope Reuse.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.ResolutionScopeReuseAttribute.#ctor">
            <summary>Creates attribute.</summary>
        </member>
        <member name="T:DryIoc.MefAttributedModel.ReuseWrappersAttribute">
            <summary>Represents Reuse Wrappers defined for exported type.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.ReuseWrappersAttribute.#ctor(System.Type[])">
            <summary>Creates attribute.</summary> <param name="wrapperTypes">Reuse Wrapper types.</param>
        </member>
        <member name="P:DryIoc.MefAttributedModel.ReuseWrappersAttribute.WrapperTypes">
            <summary>Reuse Wrapper types.</summary>
        </member>
        <member name="T:DryIoc.MefAttributedModel.ExportWithKeyAttribute">
            <summary>Defines export with arbitrary object key.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.ExportWithKeyAttribute.#ctor(System.Object,System.Type)">
            <summary>Creates attribute.</summary>
            <param name="contractKey">Service key object, should implement <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/></param> 
            <param name="contractType">Service type.</param>
        </member>
        <member name="M:DryIoc.MefAttributedModel.ExportWithKeyAttribute.#ctor(System.Object)">
            <summary>Creates attribute using implementation type as <see cref="P:System.ComponentModel.Composition.ExportAttribute.ContractType"/></summary>
            <param name="contractKey">Service key object, should implement <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/></param> 
        </member>
        <member name="P:DryIoc.MefAttributedModel.ExportWithKeyAttribute.ContractKey">
            <remarks>Specifies service key if <see cref="P:System.ComponentModel.Composition.ExportAttribute.ContractName"/> is not specified.</remarks>
        </member>
        <member name="T:DryIoc.MefAttributedModel.ExportManyAttribute">
            <summary>Specifies to export all implemented contract types automatically.</summary>
        </member>
        <member name="P:DryIoc.MefAttributedModel.ExportManyAttribute.ContractKey">
            <summary>Specifies service key if <see cref="P:DryIoc.MefAttributedModel.ExportManyAttribute.ContractName"/> is not specified.</summary>
        </member>
        <member name="P:DryIoc.MefAttributedModel.ExportManyAttribute.ContractName">
            <summary>If specified has more priority over <see cref="P:DryIoc.MefAttributedModel.ExportManyAttribute.ContractKey"/>.</summary>
        </member>
        <member name="P:DryIoc.MefAttributedModel.ExportManyAttribute.Except">
            <summary>Excludes specified contract types.</summary>
        </member>
        <member name="P:DryIoc.MefAttributedModel.ExportManyAttribute.NonPublic">
            <summary>Public types by default.</summary>
        </member>
        <member name="T:DryIoc.MefAttributedModel.AsFactoryAttribute">
            <summary>Specifies that class exporting static or instance method factories</summary>
        </member>
        <member name="T:DryIoc.MefAttributedModel.AsWrapperAttribute">
            <summary>Exports service as custom wrapper.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.AsWrapperAttribute.#ctor(System.Int32)">
            <summary>Creates attribute with <see cref="P:DryIoc.MefAttributedModel.AsWrapperAttribute.WrappedServiceTypeArgIndex"/>.</summary>
            <param name="wrappedServiceTypeArgIndex">(optional) To use single generic type arg.</param>
        </member>
        <member name="P:DryIoc.MefAttributedModel.AsWrapperAttribute.WrappedServiceTypeArgIndex">
            <summary>For open-generic wrapper indicates wrapped argument type index.</summary>
        </member>
        <member name="P:DryIoc.MefAttributedModel.AsWrapperAttribute.WrapsRequiredServiceType">
            <summary>Per name.</summary>
        </member>
        <member name="T:DryIoc.MefAttributedModel.AsDecoratorAttribute">
            <summary>Specifies that exported service is decorator of services of <see cref="P:System.ComponentModel.Composition.ExportAttribute.ContractType"/>.</summary>
        </member>
        <member name="P:DryIoc.MefAttributedModel.AsDecoratorAttribute.ContractName">
            <summary>If <see cref="P:DryIoc.MefAttributedModel.AsDecoratorAttribute.ContractName"/> specified, it has more priority over <see cref="P:DryIoc.MefAttributedModel.AsDecoratorAttribute.ContractKey"/>. </summary>
        </member>
        <member name="P:DryIoc.MefAttributedModel.AsDecoratorAttribute.ContractKey">
            <summary>Contract key of decorated type.</summary>
        </member>
        <member name="T:DryIoc.MefAttributedModel.ExportConditionAttribute">
            <summary>Base type for exported type Setup Condition.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.ExportConditionAttribute.Evaluate(DryIoc.Request)">
            <summary>Returns true to use exported service for request.</summary>
            <param name="request"></param> <returns>True to use exported service for request.</returns>
        </member>
        <member name="T:DryIoc.MefAttributedModel.ImportWithKeyAttribute">
            <summary>Imports service Only with equal <see cref="P:DryIoc.MefAttributedModel.ImportWithKeyAttribute.ContractKey"/>.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.ImportWithKeyAttribute.#ctor(System.Object,System.Type)">
            <summary>Creates attribute object service key.</summary> <param name="contractKey"></param>
            <param name="contractType">(optional) If missing then imported member type will be used as service type.</param>
        </member>
        <member name="M:DryIoc.MefAttributedModel.ImportWithKeyAttribute.#ctor(System.String,System.Type)">
            <summary>Creates attribute with string service name.</summary> <param name="contractKey"></param>
            <param name="contractType">(optional) If missing then imported member type will be used as service type.</param>
        </member>
        <member name="P:DryIoc.MefAttributedModel.ImportWithKeyAttribute.ContractKey">
            <summary>Arbitrary object to match with service key.</summary>
        </member>
        <member name="T:DryIoc.MefAttributedModel.WithMetadataAttribute">
            <summary>Exports service with associated metadata object.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.WithMetadataAttribute.Metadata">
            <summary>Metadata object</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.WithMetadataAttribute.#ctor(System.Object)">
            <summary>Creates attribute</summary> <param name="metadata"></param>
        </member>
        <member name="T:DryIoc.MefAttributedModel.ImportExternalAttribute">
            <summary>Indicate to import service and in case it is not registered, register it using provided
            implementation info. Useful for ad-hoc/quick-prototyping registration of types from not controlled libraries.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.ImportExternalAttribute.#ctor(System.Type,System.Type[],System.Object,System.Object,System.Type)">
            <summary>Creates attributes.</summary>
            <param name="implementationType">(optional) Implementation type of registered service.</param>
            <param name="constructorSignature">(optional) Use specific constructor for registration.</param>
            <param name="metadata">(optional) Metadata associated with registration.</param>
            <param name="contractKey">(optional) Registering (and importing) with specified service key.</param>
            <param name="contractType">(optional) Registering (and importing) with specified service type.</param>
        </member>
        <member name="P:DryIoc.MefAttributedModel.ImportExternalAttribute.ImplementationType">
            <summary>Implementation type of registered service.</summary>
        </member>
        <member name="P:DryIoc.MefAttributedModel.ImportExternalAttribute.ConstructorSignature">
            <summary>Use specific constructor for registration.</summary>
        </member>
        <member name="P:DryIoc.MefAttributedModel.ImportExternalAttribute.Metadata">
            <summary>Metadata associated with registration.</summary>
        </member>
        <member name="P:DryIoc.MefAttributedModel.ImportExternalAttribute.ContractKey">
            <summary>Registering (and importing) with specified service key.</summary>
        </member>
        <member name="P:DryIoc.MefAttributedModel.ImportExternalAttribute.ContractType">
            <summary>Registering (and importing) with specified service type.</summary>
        </member>
        <member name="T:DryIoc.MefAttributedModel.OpenResolutionScopeAttribute">
            <summary>Specifies that exported service setup to <see cref="P:DryIoc.Setup.OpenResolutionScope"/>.</summary>
        </member>
        <member name="T:DryIoc.MefAttributedModel.AttributedModel">
            <summary>Implements MEF Attributed Programming Model. 
            Documentation is available at https://bitbucket.org/dadhi/dryioc/wiki/MefAttributedModel. </summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.AttributedModel.DefaultReuseType">
            <summary>Default reuse policy is Singleton, the same as in MEF.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.AttributedModel.SupportedReuseTypes">
            <summary>Map of supported reuse types: so the reuse type specified by <see cref="T:DryIoc.MefAttributedModel.ReuseAttribute"/> 
            could be mapped to corresponding <see cref="T:DryIoc.Reuse"/> members.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.AttributedModel.WithMefAttributedModel(DryIoc.Rules)">
            <summary>Returns new rules with attributed model importing rules appended.</summary>
            <param name="rules">Source rules to append importing rules to.</param>
            <returns>New rules with attributed model rules.</returns>
        </member>
        <member name="M:DryIoc.MefAttributedModel.AttributedModel.WithMefAttributedModel(DryIoc.IContainer)">
            <summary>Appends attributed model rules to passed container.</summary>
            <param name="container">Source container to apply attributed model importing rules to.</param>
            <returns>Returns new container with new rules.</returns>
        </member>
        <member name="M:DryIoc.MefAttributedModel.AttributedModel.RegisterExports(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>Registers implementation type(s) with provided registrator/container. Expects that
            implementation type are annotated with <see cref="T:System.ComponentModel.Composition.ExportAttribute"/>, or <see cref="T:DryIoc.MefAttributedModel.ExportManyAttribute"/>.</summary>
            <param name="registrator">Container to register types into.</param>
            <param name="types">Provides types to peek exported implementation types from.</param>
        </member>
        <member name="M:DryIoc.MefAttributedModel.AttributedModel.RegisterExports(DryIoc.IRegistrator,System.Type[])">
            <summary>Registers implementation type(s) with provided registrator/container. Expects that
            implementation type are annotated with <see cref="T:System.ComponentModel.Composition.ExportAttribute"/>, or <see cref="T:DryIoc.MefAttributedModel.ExportManyAttribute"/>.</summary>
            <param name="registrator">Container to register types into.</param>
            <param name="types">Implementation types to register.</param>
        </member>
        <member name="M:DryIoc.MefAttributedModel.AttributedModel.RegisterExports(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>First scans (<see cref="M:DryIoc.MefAttributedModel.AttributedModel.Scan(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})"/>) provided assemblies to find types annotated with
            <see cref="T:System.ComponentModel.Composition.ExportAttribute"/>, or <see cref="T:DryIoc.MefAttributedModel.ExportManyAttribute"/>.
            Then registers found types into registrator/container.</summary>
            <param name="registrator">Container to register into</param>
            <param name="assemblies">Provides assemblies to scan for exported implementation types.</param>
            <remarks>In case of <see cref="T:System.Reflection.ReflectionTypeLoadException"/> try get type with <see cref="M:DryIoc.ReflectionTools.GetLoadedTypes(System.Reflection.Assembly)"/>.</remarks>
        </member>
        <member name="M:DryIoc.MefAttributedModel.AttributedModel.RegisterExports(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{DryIoc.MefAttributedModel.ExportedRegistrationInfo})">
            <summary>Registers new factories into registrator/container based on provided registration info's, which
            is serializable DTO for registration.</summary>
            <param name="registrator">Container to register into.</param>
            <param name="infos">Registrations to register.</param>
        </member>
        <member name="M:DryIoc.MefAttributedModel.AttributedModel.RegisterInfo(DryIoc.IRegistrator,DryIoc.MefAttributedModel.ExportedRegistrationInfo)">
            <summary>Registers factories into registrator/container based on single provided info, which could
            contain multiple exported services with single implementation.</summary>
            <param name="registrator">Container to register into.</param>
            <param name="info">Registration information provided.</param>
        </member>
        <member name="M:DryIoc.MefAttributedModel.AttributedModel.Scan(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>Scans assemblies to find concrete type annotated with <see cref="T:System.ComponentModel.Composition.ExportAttribute"/>, or <see cref="T:DryIoc.MefAttributedModel.ExportManyAttribute"/>
            attributes, and create serializable DTO with all information required for registering of exported types.</summary>
            <param name="assemblies">Assemblies to scan.</param>
            <returns>Lazy collection of registration info DTOs.</returns>
        </member>
        <member name="M:DryIoc.MefAttributedModel.AttributedModel.GetRegistrationInfoOrDefault(System.Type)">
            <summary>Creates registration info DTO for provided type. To find this info checks type attributes:
            <see cref="T:System.ComponentModel.Composition.ExportAttribute"/>, or <see cref="T:DryIoc.MefAttributedModel.ExportManyAttribute"/>.
            If type is not concrete or is value type, then return null.</summary>
            <param name="implementationType">Type to convert into registration info.</param>
            <returns>Created DTO.</returns>
        </member>
        <member name="M:DryIoc.MefAttributedModel.AttributedModel.GetReuse(System.Type,System.String)">
            <summary>Returns reuse object by mapping provided type to <see cref="F:DryIoc.MefAttributedModel.AttributedModel.SupportedReuseTypes"/>.
            Returns null (transient or no reuse) if null provided reuse type.</summary>
            <param name="reuseType">Reuse type to find in supported.</param>
            <param name="reuseName">(optional) Reuse name to match with scope name.</param>
            <returns>Supported reuse object.</returns>
        </member>
        <member name="T:DryIoc.MefAttributedModel.Error">
            <summary>Defines error codes and messages for <see cref="T:DryIoc.MefAttributedModel.AttributedModelException"/>.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.Error.Messages">
            <summary>Error messages for corresponding codes.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.Error.FirstErrorCode">
            <summary>Codes are starting from this value.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.Error.GetMessage(System.Int32)">
            <summary>Returns message by provided error code.</summary>
            <param name="error">Code starting from <see cref="F:DryIoc.MefAttributedModel.Error.FirstErrorCode"/></param> <returns>String message.</returns>
        </member>
        <member name="T:DryIoc.MefAttributedModel.AttributedModelException">
            <summary>Specific exception type to be thrown by MefAttributedModel extension. Check <see cref="T:DryIoc.MefAttributedModel.Error"/> for possible error cases.</summary>
        </member>
        <member name="T:DryIoc.ContainerException">
            <summary>Exception that container throws in case of error. Dedicated exception type simplifies
            filtering or catching container relevant exceptions from client code.</summary>
        </member>
        <member name="F:DryIoc.ContainerException.Error">
            <summary>Error code of exception, possible values are listed in <see cref="F:DryIoc.ContainerException.Error"/> class.</summary>
        </member>
        <member name="M:DryIoc.ContainerException.Of(DryIoc.ErrorCheck,System.Int32,System.Object,System.Object,System.Object,System.Object,System.Exception)">
            <summary>Creates exception by wrapping <paramref name="errorCode"/> and its message,
            optionally with <paramref name="inner"/> exception.</summary>
            <param name="errorCheck">Type of check</param>
            <param name="errorCode">Error code, check <see cref="F:DryIoc.ContainerException.Error"/> for possible values.</param>
            <param name="arg0">(optional) Arguments for formatted message.</param> <param name="arg1"></param> <param name="arg2"></param> <param name="arg3"></param>
            <param name="inner">(optional) Inner exception.</param>
            <returns>Created exception.</returns>
        </member>
        <member name="M:DryIoc.ContainerException.#ctor(System.Int32,System.String)">
            <summary>Creates exception with message describing cause and context of error.</summary>
            <param name="error"></param>
            <param name="message">Error message.</param>
        </member>
        <member name="M:DryIoc.ContainerException.#ctor(System.Int32,System.String,System.Exception)">
            <summary>Creates exception with message describing cause and context of error,
            and leading/system exception causing it.</summary>
            <param name="error"></param>
            <param name="message">Error message.</param>
            <param name="innerException">Underlying system/leading exception.</param>
        </member>
        <member name="M:DryIoc.ContainerException.Print(System.Object)">
            <summary>Prints argument for formatted message.</summary> <param name="arg">To print.</param> <returns>Printed string.</returns>
        </member>
        <member name="M:DryIoc.MefAttributedModel.AttributedModelException.Of(DryIoc.ErrorCheck,System.Int32,System.Object,System.Object,System.Object,System.Object,System.Exception)">
            <summary>Creates exception by wrapping <paramref name="errorCode"/> and with message corresponding to code.</summary>
            <param name="errorCheck">Type of check was done.</param> <param name="errorCode">Error code to wrap, <see cref="T:DryIoc.MefAttributedModel.Error"/> for codes defined.</param>
            <param name="arg0">(optional) Arguments for formatted message.</param> <param name="arg1"></param> <param name="arg2"></param> <param name="arg3"></param> 
            <param name="inner">(optional) Inner exception to wrap.</param>
            <returns>Create exception object.</returns>
        </member>
        <member name="T:DryIoc.MefAttributedModel.PrintCode">
            <summary>Converts provided literal into valid C# code. Used for generating registration code 
            from <see cref="T:DryIoc.MefAttributedModel.ExportedRegistrationInfo"/> DTOs.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.PrintCode.AppendBool(System.Text.StringBuilder,System.Boolean)">
            <summary>Prints valid c# Boolean literal: true/false.</summary>
            <param name="code">Code to print to.</param> <param name="x">Value to print.</param> <returns>Code with appended literal.</returns>
        </member>
        <member name="M:DryIoc.MefAttributedModel.PrintCode.AppendString(System.Text.StringBuilder,System.String)">
            <summary>Prints valid c# string constant.</summary>
            <param name="code">Code to print to.</param> <param name="x">Value to print.</param> <returns>Code with appended literal.</returns>
        </member>
        <member name="M:DryIoc.MefAttributedModel.PrintCode.AppendType(System.Text.StringBuilder,System.Type)">
            <summary>Prints valid c# Type literal: typeof(Namespace.Type).</summary>
            <param name="code">Code to print to.</param> <param name="x">Value to print.</param> <returns>Code with appended literal.</returns>
        </member>
        <member name="M:DryIoc.MefAttributedModel.PrintCode.AppendEnum(System.Text.StringBuilder,System.Type,System.Object)">
            <summary>Prints valid c# Enum literal: Enum.Value.</summary>
            <param name="code">Code to print to.</param>
            <param name="enumType">Enum type of the value.</param>
            <param name="x">Value to print.</param> <returns>Code with appended literal.</returns>
        </member>
        <member name="M:DryIoc.MefAttributedModel.PrintCode.AppendCode(System.Text.StringBuilder,System.Object,System.Action{System.Text.StringBuilder,System.Object})">
            <summary>Prints valid c# literal depending of <paramref name="x"/> type.</summary>
            <param name="code">Code to print to.</param> <param name="x">Value to print.</param>
            <param name="ifNotRecognized">(optional) Delegate to print unrecognized value.</param>
            <returns>Code with appended literal.</returns>
        </member>
        <member name="T:DryIoc.MefAttributedModel.ExportedRegistrationInfo">
            <summary>Serializable DTO of all registration information.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.ExportedRegistrationInfo.Exports">
            <summary>All exports defined for implementation type (registration).</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.ExportedRegistrationInfo.ImplementationType">
            <summary>Concrete type on what exports are defined: exported type.</summary>
            <remarks>May be null if <see cref="F:DryIoc.MefAttributedModel.ExportedRegistrationInfo.ImplementationTypeFullName"/> specified.</remarks>
        </member>
        <member name="F:DryIoc.MefAttributedModel.ExportedRegistrationInfo.ImplementationTypeFullName">
            <summary>Full name of exported type. Enables type lazy-loading scenario.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.ExportedRegistrationInfo.ReuseType">
            <summary>One of <see cref="F:DryIoc.MefAttributedModel.AttributedModel.SupportedReuseTypes"/>.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.ExportedRegistrationInfo.ReuseName">
            <summary>Name to pass to reuse factory from <see cref="F:DryIoc.MefAttributedModel.AttributedModel.SupportedReuseTypes"/>.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.ExportedRegistrationInfo.OpenResolutionScope">
            <summary>Corresponds to <see cref="P:DryIoc.Setup.OpenResolutionScope"/>.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.ExportedRegistrationInfo.ReusedWrappers">
            <summary>Reuse wrappers defined for exported type.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.ExportedRegistrationInfo.HasMetadataAttribute">
            <summary>True if exported type has metadata.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.ExportedRegistrationInfo.FactoryType">
            <summary>Factory type to specify <see cref="T:DryIoc.Setup"/>.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.ExportedRegistrationInfo.Decorator">
            <summary>Not null if exported with <see cref="T:DryIoc.MefAttributedModel.AsDecoratorAttribute"/>, contains info about decorator.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.ExportedRegistrationInfo.Wrapper">
            <summary>Not null if exported with <see cref="T:DryIoc.MefAttributedModel.AsWrapperAttribute"/>, contains info about wrapper.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.ExportedRegistrationInfo.IsFactory">
            <summary>True if exported with <see cref="T:DryIoc.MefAttributedModel.AsFactoryAttribute"/>.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.ExportedRegistrationInfo.ConditionType">
            <summary>Type consisting of single method compatible with <see cref="P:DryIoc.Setup.Condition"/> type.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.ExportedRegistrationInfo.CreateFactory(DryIoc.Made)">
            <summary>Creates factory out of registration info.</summary>
            <param name="made">(optional) Injection rules. Used if registration <see cref="F:DryIoc.MefAttributedModel.ExportedRegistrationInfo.IsFactory"/> to specify factory methods.</param>
            <returns>Created factory.</returns>
        </member>
        <member name="M:DryIoc.MefAttributedModel.ExportedRegistrationInfo.GetSetup(System.Attribute[])">
            <summary>Create factory setup from DTO data.</summary>
            <param name="attributes">Implementation type attributes provided to get optional metadata.</param>
            <returns>Created factory setup.</returns>
        </member>
        <member name="M:DryIoc.MefAttributedModel.ExportedRegistrationInfo.Equals(System.Object)">
            <summary>Compares with another info for equality.</summary>
            <param name="obj">Other info to compare.</param> <returns>True if equal.</returns>
        </member>
        <member name="M:DryIoc.MefAttributedModel.ExportedRegistrationInfo.ToCode(System.Text.StringBuilder)">
            <summary>Generate valid c# code for instantiating of info from its state. Supposed be used in compile-time scenarios.</summary>
            <param name="code">Code to append "new RegistrationInfo(...)" to.</param>
            <returns>Code with "new info".</returns>
        </member>
        <member name="T:DryIoc.MefAttributedModel.ExportInfo">
            <summary>Defines DTO for exported service type and key.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.ExportInfo.ServiceType">
            <summary>Contract type.</summary>
            <remarks>may be null if <see cref="F:DryIoc.MefAttributedModel.ExportInfo.ServiceTypeFullName"/> specified.</remarks>
        </member>
        <member name="F:DryIoc.MefAttributedModel.ExportInfo.ServiceTypeFullName">
            <summary>Full contract type name. Supposed to be used in lazy-loading scenario.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.ExportInfo.ServiceKeyInfo">
            <summary>Wrapped contract name or service key. It is wrapped in order to be serializable.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.ExportInfo.#ctor">
            <summary>Default constructor is usually required by deserializer.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.ExportInfo.#ctor(System.Type,System.Object)">
            <summary>Creates exported info out of type and optional key.</summary>
            <param name="serviceType">Contract type to store.</param>
            <param name="serviceKey">(optional) ContractName string or service key.</param>
        </member>
        <member name="M:DryIoc.MefAttributedModel.ExportInfo.Equals(System.Object)">
            <summary>Compares with another info for equality.</summary>
            <param name="obj">Other info to compare.</param> <returns>True if equal.</returns>
        </member>
        <member name="M:DryIoc.MefAttributedModel.ExportInfo.ToCode(System.Text.StringBuilder)">
            <summary>Generates valid c# code to "new <see cref="T:DryIoc.MefAttributedModel.ExportInfo"/>() { ... };" from its state.</summary>
            <param name="code">Code to append generated code to.</param>
            <returns>Code with appended generated info.</returns>
        </member>
        <member name="T:DryIoc.MefAttributedModel.WrapperInfo">
            <summary>Defines wrapper setup in serializable way.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.WrapperInfo.WrappedServiceTypeArgIndex">
            <summary>Index of wrapped type argument in open-generic wrapper.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.WrapperInfo.WrapsRequiredServiceType">
            <summary>Per name.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.WrapperInfo.GetSetup">
            <summary>Creates Wrapper setup from this info.</summary> <returns>Setup.</returns>
        </member>
        <member name="M:DryIoc.MefAttributedModel.WrapperInfo.Equals(System.Object)">
            <summary>Used to compare wrappers info for equality.</summary> <param name="obj">Other info to compare.</param>
            <returns>True if equal</returns>
        </member>
        <member name="M:DryIoc.MefAttributedModel.WrapperInfo.ToCode(System.Text.StringBuilder)">
            <summary>Converts info to valid C# code to be used in generation scenario.</summary>
            <param name="code">Code to append to.</param> <returns>Code with appended info code.</returns>
        </member>
        <member name="T:DryIoc.MefAttributedModel.DecoratorInfo">
            <summary>Provides serializable info about Decorator setup.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.DecoratorInfo.DecoratedServiceKeyInfo">
            <summary>Decorated service key info. Info wrapper is required for serialization.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.DecoratorInfo.GetSetup(System.Func{System.Object},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Converts info to corresponding decorator setup.</summary>
            <param name="lazyMetadata">(optional) Metadata that may be associated by decorator.</param>
            <param name="condition">(optional) <see cref="P:DryIoc.Setup.Condition"/>.</param>
            <returns>Setup.</returns>
        </member>
        <member name="M:DryIoc.MefAttributedModel.DecoratorInfo.Equals(System.Object)">
            <summary>Compares this info to other info for equality.</summary> <param name="obj">Other info to compare.</param>
            <returns>true if equal.</returns>
        </member>
        <member name="M:DryIoc.MefAttributedModel.DecoratorInfo.ToCode(System.Text.StringBuilder)">
            <summary>Converts info to valid C# code to be used in generation scenario.</summary>
            <param name="code">Code to append to.</param> <returns>Code with appended info code.</returns>
        </member>
        <member name="T:DryIoc.MefAttributedModel.ServiceKeyInfo">
            <summary>Wrapper on un-typed key object for serialization purposes.</summary>
            <remarks>May be unnecessary and only required by ProtocolBufferers. NOTE: Require further checks.</remarks>
        </member>
        <member name="F:DryIoc.MefAttributedModel.ServiceKeyInfo.Default">
            <summary>Default key to represent null key object.</summary>
        </member>
        <member name="F:DryIoc.MefAttributedModel.ServiceKeyInfo.Key">
            <summary>Original key.</summary>
        </member>
        <member name="M:DryIoc.MefAttributedModel.ServiceKeyInfo.Of(System.Object)">
            <summary>Wraps key.</summary> <param name="key">Input key.</param> <returns>Wrapper.</returns>
        </member>
        <member name="T:DryIoc.Container">
            <summary>IoC Container. Documentation is available at https://bitbucket.org/dadhi/dryioc. </summary>
        </member>
        <member name="T:DryIoc.IContainer">
            <summary>Exposes operations required for internal registry access. 
            That's why most of them are implemented explicitly by <see cref="T:DryIoc.Container"/>.</summary>
        </member>
        <member name="T:DryIoc.IRegistrator">
            <summary>Defines operations that for changing registry, and checking if something exist in registry.</summary>
        </member>
        <member name="M:DryIoc.IRegistrator.GetServiceRegistrations">
            <summary>Returns all registered service factories with their Type and optional Key.</summary>
            <returns>Existing registrations.</returns>
            <remarks>Decorator and Wrapper types are not included.</remarks>
        </member>
        <member name="M:DryIoc.IRegistrator.Register(DryIoc.Factory,System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean)">
            <summary>Registers factory in registry with specified service type and key for lookup.
            Returns true if factory was added to registry, false otherwise. False may be in case of <see cref="F:DryIoc.IfAlreadyRegistered.Keep"/> 
            setting and already existing factory</summary>
            <param name="factory">To register.</param>
            <param name="serviceType">Service type as unique key in registry for lookup.</param>
            <param name="serviceKey">Service key as complementary lookup for the same service type.</param>
            <param name="ifAlreadyRegistered">Policy how to deal with already registered factory with same service type and key.</param>
            <param name="isStaticallyChecked">Confirms that service and implementation types are statically checked by compiler.</param>
            <returns>True if factory was added to registry, false otherwise. 
            False may be in case of <see cref="F:DryIoc.IfAlreadyRegistered.Keep"/> setting and already existing factory.</returns>
        </member>
        <member name="M:DryIoc.IRegistrator.IsRegistered(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if expected factory is registered with specified service key and type.</summary>
            <param name="serviceType">Type to lookup.</param>
            <param name="serviceKey">Key to lookup for the same type.</param>
            <param name="factoryType">Expected factory type.</param>
            <param name="condition">Expected factory condition.</param>
            <returns>True if expected factory found in registry.</returns>
        </member>
        <member name="M:DryIoc.IRegistrator.Unregister(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes factory with specified service type and key from registry.</summary>
            <param name="serviceType">Type to lookup.</param>
            <param name="serviceKey">Key to lookup for the same type.</param>
            <param name="factoryType">Expected factory type.</param>
            <param name="condition">Expected factory condition.</param>
        </member>
        <member name="T:DryIoc.IResolver">
            <summary>Declares minimal API for service resolution.
            The user friendly convenient methods are implemented as extension methods in <see cref="T:DryIoc.Resolver"/> class.</summary>
            <remarks>Resolve default and keyed is separated because of micro optimization for faster resolution.</remarks>
        </member>
        <member name="M:DryIoc.IResolver.ResolveDefault(System.Type,DryIoc.IfUnresolved,DryIoc.IScope)">
            <summary>Resolves service from container and returns created service object.</summary>
            <param name="serviceType">Service type to search and to return.</param>
            <param name="ifUnresolved">Says what to do if service is unresolved.</param>
            <param name="scope">Propagated resolution scope.</param>
            <returns>Created service object or default based on <paramref name="ifUnresolved"/> provided.</returns>
        </member>
        <member name="M:DryIoc.IResolver.ResolveKeyed(System.Type,System.Object,DryIoc.IfUnresolved,System.Type,DryIoc.IScope)">
            <summary>Resolves service from container and returns created service object.</summary>
            <param name="serviceType">Service type to search and to return.</param>
            <param name="serviceKey">Optional service key used for registering service.</param>
            <param name="ifUnresolved">Says what to do if service is unresolved.</param>
            <param name="requiredServiceType">Actual registered service type to use instead of <paramref name="serviceType"/>, 
                or wrapped type for generic wrappers.  The type should be assignable to return <paramref name="serviceType"/>.</param>
            <param name="scope">Propagated resolution scope.</param>
            <returns>Created service object or default based on <paramref name="ifUnresolved"/> provided.</returns>
            <remarks>
            This method covers all possible resolution input parameters comparing to <see cref="M:DryIoc.IResolver.ResolveDefault(System.Type,DryIoc.IfUnresolved,DryIoc.IScope)"/>, and
            by specifying the same parameters as for <see cref="M:DryIoc.IResolver.ResolveDefault(System.Type,DryIoc.IfUnresolved,DryIoc.IScope)"/> should return the same result.
            </remarks>
        </member>
        <member name="M:DryIoc.IResolver.ResolveMany(System.Type,System.Object,System.Type,System.Object,DryIoc.IScope)">
            <summary>Resolves all services registered for specified <paramref name="serviceType"/>, or if not found returns
            empty enumerable. If <paramref name="serviceType"/> specified then returns only (single) service registered with
            this type. Excludes for result composite parent identified by <paramref name="compositeParentKey"/>.</summary>
            <param name="serviceType">Return type of an service item.</param>
            <param name="serviceKey">(optional) Resolve only single service registered with the key.</param>
            <param name="requiredServiceType">(optional) Actual registered service to search for.</param>
            <param name="compositeParentKey">(optional) Parent service key to exclude to support Composite pattern.</param>
            <param name="scope">propagated resolution scope, may be null.</param>
            <returns>Enumerable of found services or empty. Does Not throw if no service found.</returns>
        </member>
        <member name="T:DryIoc.IScopeAccess">
            <summary>Provides access to scopes.</summary>
        </member>
        <member name="M:DryIoc.IScopeAccess.GetCurrentNamedScope(System.Object,System.Boolean)">
            <summary>Gets current scope matching the <paramref name="name"/>. 
            If name is null then current scope is returned, or if there is no current scope then exception thrown.</summary>
            <param name="name">May be null</param> <returns>Found scope or throws exception.</returns>
            <param name="throwIfNotFound">Says to throw if no scope found.</param>
            <exception cref="T:DryIoc.ContainerException"> with code <see cref="F:DryIoc.Error.NoMatchedScopeFound"/>.</exception>
        </member>
        <member name="M:DryIoc.IScopeAccess.GetOrCreateResolutionScope(DryIoc.IScope@,System.Type,System.Object)">
            <summary>Check if scope is not null, then just returns it, otherwise will create and return it.</summary>
            <param name="scope">May be null scope.</param>
            <param name="serviceType">Marking scope with resolved service type.</param> 
            <param name="serviceKey">Marking scope with resolved service key.</param>
            <returns>Input <paramref name="scope"/> ensuring it is not null.</returns>
        </member>
        <member name="M:DryIoc.IScopeAccess.GetMatchingResolutionScope(DryIoc.IScope,System.Type,System.Object,System.Boolean,System.Boolean)">
            <summary>If both <paramref name="assignableFromServiceType"/> and <paramref name="serviceKey"/> are null, 
            then returns input <paramref name="scope"/>.
            Otherwise searches scope hierarchy to find first scope with: Type assignable <paramref name="assignableFromServiceType"/> and 
            Key equal to <paramref name="serviceKey"/>.</summary>
            <param name="scope">Scope to start matching with Type and Key specified.</param>
            <param name="assignableFromServiceType">Type to match.</param> <param name="serviceKey">Key to match.</param>
            <param name="outermost">If true - commands to look for outermost match instead of nearest.</param>
            <param name="throwIfNotFound">Says to throw if no scope found.</param>
            <returns>Matching scope or throws <see cref="T:DryIoc.ContainerException"/>.</returns>
        </member>
        <member name="P:DryIoc.IScopeAccess.SingletonScope">
            <summary>Scope containing container singletons.</summary>
        </member>
        <member name="M:DryIoc.IContainer.With(System.Func{DryIoc.Rules,DryIoc.Rules},DryIoc.IScopeContext)">
            <summary>Copies all of container state except Cache and specifies new rules.</summary>
            <param name="configure">(optional) Configure rules, if not specified then uses Rules from current container.</param> 
            <param name="scopeContext">(optional) New scope context, if not specified then uses context from current container.</param>
            <returns>New container.</returns>
        </member>
        <member name="M:DryIoc.IContainer.WithoutCache">
            <summary>Returns new container with all expression, delegate, items cache removed/reset.
            It will preserve resolved services in Singleton/Current scope.</summary>
            <returns>New container with empty cache.</returns>
        </member>
        <member name="M:DryIoc.IContainer.WithoutSingletonsAndCache">
            <summary>Creates new container with whole state shared with original except singletons.</summary>
            <returns>New container with empty Singleton Scope.</returns>
        </member>
        <member name="M:DryIoc.IContainer.WithRegistrationsCopy(System.Boolean)">
            <summary>Shares all parts with original container But copies registration, so the new registration
            won't be visible in original. Registrations include decorators and wrappers as well.</summary>
            <param name="preserveCache">(optional) If set preserves cache if you know what to do.</param>
            <returns>New container with copy of all registrations.</returns>
        </member>
        <member name="M:DryIoc.IContainer.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})">
            <summary>Creates new container with new opened scope and set this scope as current in ambient scope context.</summary>
            <param name="name">(optional) Name for opened scope to allow reuse to identify the scope.</param>
            <param name="configure">(optional) Configure rules, if not specified then uses Rules from current container.</param> 
            <returns>New container with different current scope.</returns>
            <example><code lang="cs"><![CDATA[
            using (var scoped = container.OpenScope())
            {
                var handler = scoped.Resolve<IHandler>();
                handler.Handle(data);
            }
            ]]></code></example>
        </member>
        <member name="M:DryIoc.IContainer.OpenScopeWithoutContext(System.Object)">
            <summary>Creates scoped container with scope bound to container itself, and not some ambient context.
            Current container scope will become parent for new scope.</summary>
            <param name="scopeName">(optional) Scope name.</param>
            <returns>New container with all state shared except new created scope and context.</returns>
        </member>
        <member name="M:DryIoc.IContainer.CreateFacade">
            <summary>Creates container (facade) that fallbacks to this container for unresolved services.
            Facade shares rules with this container, everything else is its own. 
            It could be used for instance to create Test facade over original container with replacing some services with test ones.</summary>
            <remarks>Singletons from container are not reused by facade, to achieve that rather use <see cref="M:DryIoc.IContainer.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})"/> with <see cref="F:DryIoc.Reuse.InCurrentScope"/>.</remarks>
            <returns>New facade container.</returns>
        </member>
        <member name="M:DryIoc.IContainer.ResolveFactory(DryIoc.Request)">
            <summary>Searches for requested factory in registry, and then using <see cref="P:DryIoc.Rules.UnknownServiceResolvers"/>.</summary>
            <param name="request">Factory request.</param>
            <returns>Found factory, otherwise null if <see cref="P:DryIoc.Request.IfUnresolved"/> is set to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetServiceFactoryOrDefault(DryIoc.Request)">
            <summary>Searches for registered service factory and returns it, or null if not found.</summary>
            <param name="request">Factory request.</param>
            <returns>Found registered factory or null.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetAllServiceFactories(System.Type)">
            <summary>Finds all registered default and keyed service factories and returns them.
            It skips decorators and wrappers.</summary>
            <param name="serviceType"></param>
            <returns>Enumerable of found pairs.</returns>
            <remarks>Returned Key item should not be null - it should be <see cref="F:DryIoc.DefaultKey.Value"/>.</remarks>
        </member>
        <member name="M:DryIoc.IContainer.GetWrapperFactoryOrDefault(System.Type)">
            <summary>Searches for registered wrapper factory and returns it, or null if not found.</summary>
            <param name="serviceType">Service type to look for.</param> <returns>Found wrapper factory or null.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetDecoratorFactoriesOrDefault(System.Type)">
            <summary>Returns all decorators registered for the service type.</summary> <returns>Decorator factories.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetDecoratorExpressionOrDefault(DryIoc.Request)">
            <summary>Creates decorator expression: it could be either Func{TService,TService}, 
            or service expression for replacing decorators.</summary>
            <param name="request">Decorated service request.</param>
            <returns>Decorator expression.</returns>
        </member>
        <member name="M:DryIoc.IContainer.InjectPropertiesAndFields(System.Object,DryIoc.PropertiesAndFieldsSelector)">
            <summary>For given instance resolves and sets properties and fields.</summary>
            <param name="instance">Service instance with properties to resolve and initialize.</param>
            <param name="propertiesAndFields">(optional) Function to select properties and fields, overrides all other rules if specified.</param>
            <returns>Instance with assigned properties and fields.</returns>
            <remarks>Different Rules could be combined together using <see cref="M:DryIoc.PropertiesAndFields.And(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)"/> method.</remarks>     
        </member>
        <member name="M:DryIoc.IContainer.UnwrapServiceType(System.Type)">
            <summary>If <paramref name="serviceType"/> is generic type then this method checks if the type registered as generic wrapper,
            and recursively unwraps and returns its type argument. This type argument is the actual service type we want to find.
            Otherwise, method returns the input <paramref name="serviceType"/>.</summary>
            <param name="serviceType">Type to unwrap. Method will return early if type is not generic.</param>
            <returns>Unwrapped service type in case it corresponds to registered generic wrapper, or input type in all other cases.</returns>
        </member>
        <member name="M:DryIoc.IContainer.CacheFactoryExpression(System.Int32,System.Linq.Expressions.Expression)">
            <summary>Adds factory expression to cache identified by factory ID (<see cref="P:DryIoc.Factory.FactoryID"/>).</summary>
            <param name="factoryID">Key in cache.</param>
            <param name="factoryExpression">Value to cache.</param>
        </member>
        <member name="M:DryIoc.IContainer.GetCachedFactoryExpressionOrDefault(System.Int32)">
            <summary>Searches and returns cached factory expression, or null if not found.</summary>
            <param name="factoryID">Factory ID to lookup by.</param> <returns>Found expression or null.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetOrAddStateItemExpression(System.Object,System.Type,System.Boolean)">
            <summary>If possible wraps added item in <see cref="T:System.Linq.Expressions.ConstantExpression"/> (possible for primitive type, Type, strings), 
            otherwise invokes <see cref="M:DryIoc.Container.GetOrAddStateItem(System.Object)"/> and wraps access to added item (by returned index) into expression: state =&gt; state.Get(index).</summary>
            <param name="item">Item to wrap or to add.</param> <param name="itemType">(optional) Specific type of item, otherwise item <see cref="M:System.Object.GetType"/>.</param>
            <param name="throwIfStateRequired">(optional) Enable filtering of stateful items.</param>
            <returns>Returns constant or state access expression for added items.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetOrAddStateItem(System.Object)">
            <summary>Adds item if it is not already added to state, returns added or existing item index.</summary>
            <param name="item">Item to find in existing items with <see cref="M:System.Object.Equals(System.Object,System.Object)"/> or add if not found.</param>
            <returns>Index of found or added item.</returns>
        </member>
        <member name="P:DryIoc.IContainer.IsDisposed">
            <summary>Returns true if container is disposed.</summary>
        </member>
        <member name="P:DryIoc.IContainer.ContainerWeakRef">
            <summary>Self weak reference, with readable message when container is GCed/Disposed.</summary>
        </member>
        <member name="P:DryIoc.IContainer.Rules">
            <summary>Rules for defining resolution/registration behavior throughout container.</summary>
        </member>
        <member name="P:DryIoc.IContainer.EmptyRequest">
            <summary>Empty request bound to container. All other requests are created by pushing to empty request.</summary>
        </member>
        <member name="P:DryIoc.IContainer.ResolutionStateCache">
            <summary>State item objects which may include: singleton instances for fast access, reuses, reuse wrappers, factory delegates, etc.</summary>
        </member>
        <member name="P:DryIoc.IContainer.OpenedScope">
            <summary>Container opened scope. May or may not be equal to Current Scope.</summary>
        </member>
        <member name="P:DryIoc.IContainer.ScopeContext">
            <summary>Returns scope context associated with container.</summary>
        </member>
        <member name="M:DryIoc.Container.#ctor(DryIoc.Rules,DryIoc.IScopeContext)">
            <summary>Creates new container, optionally providing <see cref="P:DryIoc.Container.Rules"/> to modify default container behavior.</summary>
            <param name="rules">(optional) Rules to modify container default resolution behavior. 
            If not specified, then <see cref="F:DryIoc.Rules.Default"/> will be used.</param>
            <param name="scopeContext">(optional) Scope context to use for <see cref="F:DryIoc.Reuse.InCurrentScope"/>, default is <see cref="T:DryIoc.ThreadScopeContext"/>.</param>
        </member>
        <member name="M:DryIoc.Container.#ctor(System.Func{DryIoc.Rules,DryIoc.Rules},DryIoc.IScopeContext)">
            <summary>Creates new container with configured rules.</summary>
            <param name="configure">Delegate gets <see cref="F:DryIoc.Rules.Default"/> as input and may return configured rules.</param>
            <param name="scopeContext">(optional) Scope context to use for <see cref="F:DryIoc.Reuse.InCurrentScope"/>, default is <see cref="T:DryIoc.ThreadScopeContext"/>.</param>
        </member>
        <member name="M:DryIoc.Container.With(System.Func{DryIoc.Rules,DryIoc.Rules},DryIoc.IScopeContext)">
            <summary>Shares all of container state except Cache and specifies new rules.</summary>
            <param name="configure">(optional) Configure rules, if not specified then uses Rules from current container.</param> 
            <param name="scopeContext">(optional) New scope context, if not specified then uses context from current container.</param>
            <returns>New container.</returns>
        </member>
        <member name="M:DryIoc.Container.WithoutCache">
            <summary>Returns new container with all expression, delegate, items cache removed/reset.
            It will preserve resolved services in Singleton/Current scope.</summary>
            <returns>New container with empty cache.</returns>
        </member>
        <member name="M:DryIoc.Container.WithoutSingletonsAndCache">
            <summary>Creates new container with state shared with original except singletons and cache.
            Dropping cache is required because singletons are cached in resolution state.</summary>
            <returns>New container with empty Singleton Scope.</returns>
        </member>
        <member name="M:DryIoc.Container.WithRegistrationsCopy(System.Boolean)">
            <summary>Shares all parts with original container But copies registration, so the new registration
            won't be visible in original. Registrations include decorators and wrappers as well.</summary>
            <param name="preserveCache">(optional) If set preserves cache if you know what to do.</param>
            <returns>New container with copy of all registrations.</returns>
        </member>
        <member name="M:DryIoc.Container.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})">
            <summary>Creates new container with new opened scope and set this scope as current in ambient scope context.</summary>
            <param name="scopeName">(optional) Name for opened scope to allow reuse to identify the scope.</param>
            <param name="configure">(optional) Configure rules, if not specified then uses Rules from current container.</param> 
            <returns>New container with different current scope and optionally Rules.</returns>
            <example><code lang="cs"><![CDATA[
            using (var scoped = container.OpenScope())
            {
                var handler = scoped.Resolve<IHandler>();
                handler.Handle(data);
            }
            ]]></code></example>
            <remarks>Be sure to Dispose returned scope, because if not - ambient context will keep scope with it's items
            introducing memory leaks and likely preventing to open other scopes.</remarks>
        </member>
        <member name="M:DryIoc.Container.OpenScopeWithoutContext(System.Object)">
            <summary>Creates scoped container with scope bound to container itself, and not some ambient context.
            Current container scope will become parent for new scope.</summary>
            <param name="scopeName">(optional) Scope name.</param>
            <returns>New container with all state shared except new created scope and context.</returns>
        </member>
        <member name="F:DryIoc.Container.NoContextRootScopeName">
            <summary>Provide root scope name for <see cref="M:DryIoc.Container.OpenScopeWithoutContext(System.Object)"/></summary>
        </member>
        <member name="M:DryIoc.Container.CreateFacade">
            <summary>Creates container (facade) that fallbacks to this container for unresolved services.
            Facade is the new empty container, with the same rules and scope context as current container. 
            It could be used for instance to create Test facade over original container with replacing some services with test ones.</summary>
            <remarks>Singletons from container are not reused by facade - when you resolve singleton directly from parent and then ask for it from child, it will return another object.
            To achieve that you may use <see cref="M:DryIoc.IContainer.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})"/> with <see cref="F:DryIoc.Reuse.InCurrentScope"/>.</remarks>
            <returns>New facade container.</returns>
        </member>
        <member name="M:DryIoc.Container.Dispose">
            <summary>Disposes container current scope and that means container itself.</summary>
        </member>
        <member name="M:DryIoc.Container.GetServiceRegistrations">
            <summary>Returns all registered service factories with their Type and optional Key.</summary>
            <returns>Existing registrations.</returns>
            <remarks>Decorator and Wrapper types are not included.</remarks>
        </member>
        <member name="M:DryIoc.Container.Register(DryIoc.Factory,System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean)">
            <summary>Stores factory into container using <paramref name="serviceType"/> and <paramref name="serviceKey"/> as key
            for later lookup.</summary>
            <param name="factory">Any subtypes of <see cref="T:DryIoc.Factory"/>.</param>
            <param name="serviceType">Type of service to resolve later.</param>
            <param name="serviceKey">(optional) Service key of any type with <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>
            implemented.</param>
            <param name="ifAlreadyRegistered">(optional) Says how to handle existing registration with the same 
            <paramref name="serviceType"/> and <paramref name="serviceKey"/>.</param>
            <param name="isStaticallyChecked">Confirms that service and implementation types are statically checked by compiler.</param>
            <returns>True if factory was added to registry, false otherwise. 
            False may be in case of <see cref="F:DryIoc.IfAlreadyRegistered.Keep"/> setting and already existing factory.</returns>
        </member>
        <member name="M:DryIoc.Container.IsRegistered(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if there is registered factory with the service type and key.
            To check if only default factory is registered specify <see cref="F:DryIoc.DefaultKey.Value"/> as <paramref name="serviceKey"/>.
            Otherwise, if no <paramref name="serviceKey"/> specified then True will returned for any registered factories, even keyed.
            Additionally you can specify <paramref name="condition"/> to be applied to registered factories.</summary>
            <param name="serviceType">Service type to look for.</param>
            <param name="serviceKey">Service key to look for.</param>
            <param name="factoryType">Expected registered factory type.</param>
            <param name="condition">Expected factory condition.</param>
            <returns>True if factory is registered, false if not.</returns>
        </member>
        <member name="M:DryIoc.Container.Unregister(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes specified factory from registry. 
            Factory is removed only from registry, if there is relevant cache, it will be kept.
            Use <see cref="M:DryIoc.Container.WithoutCache"/> to remove all the cache.</summary>
            <param name="serviceType">Service type to look for.</param>
            <param name="serviceKey">Service key to look for.</param>
            <param name="factoryType">Expected factory type.</param>
            <param name="condition">Expected factory condition.</param>
        </member>
        <member name="M:DryIoc.Container.DryIoc#IScopeAccess#GetCurrentNamedScope(System.Object,System.Boolean)">
            <summary>Gets current scope matching the <paramref name="name"/>. 
            If name is null then current scope is returned, or if there is no current scope then exception thrown.</summary>
            <param name="name">May be null</param> <param name="throwIfNotFound">Says to throw if no scope found.</param>
            <returns>Found scope or throws exception.</returns>
            <exception cref="T:DryIoc.ContainerException"> with code <see cref="F:DryIoc.Error.NoMatchedScopeFound"/>.</exception>
        </member>
        <member name="M:DryIoc.Container.DryIoc#IScopeAccess#GetOrCreateResolutionScope(DryIoc.IScope@,System.Type,System.Object)">
            <summary>Check if scope is not null, then just returns it, otherwise will create and return it.</summary>
            <param name="scope">May be null scope.</param>
            <param name="serviceType">Marking scope with resolved service type.</param> 
            <param name="serviceKey">Marking scope with resolved service key.</param>
            <returns>Input <paramref name="scope"/> ensuring it is not null.</returns>
        </member>
        <member name="M:DryIoc.Container.DryIoc#IScopeAccess#GetMatchingResolutionScope(DryIoc.IScope,System.Type,System.Object,System.Boolean,System.Boolean)">
            <summary>If both <paramref name="assignableFromServiceType"/> and <paramref name="serviceKey"/> are null, 
            then returns input <paramref name="scope"/>.
            Otherwise searches scope hierarchy to find first scope with: Type assignable <paramref name="assignableFromServiceType"/> and 
            Key equal to <paramref name="serviceKey"/>.</summary>
            <param name="scope">Scope to start matching with Type and Key specified.</param>
            <param name="assignableFromServiceType">Type to match.</param> <param name="serviceKey">Key to match.</param>
            <param name="outermost">If true - commands to look for outermost match instead of nearest.</param>
            <param name="throwIfNotFound">Says to throw if no scope found.</param>
            <returns>Matching scope or throws <see cref="T:DryIoc.ContainerException"/>.</returns>
        </member>
        <member name="M:DryIoc.Container.InjectPropertiesAndFields(System.Object,DryIoc.PropertiesAndFieldsSelector)">
            <summary>For given instance resolves and sets properties and fields.</summary>
            <param name="instance">Service instance with properties to resolve and initialize.</param>
            <param name="propertiesAndFields">(optional) Function to select properties and fields, overrides all other rules if specified.</param>
            <returns>Instance with assigned properties and fields.</returns>
            <remarks>Different Rules could be combined together using <see cref="M:DryIoc.PropertiesAndFields.And(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)"/> method.</remarks>        
        </member>
        <member name="M:DryIoc.Container.CacheFactoryExpression(System.Int32,System.Linq.Expressions.Expression)">
            <summary>Adds factory expression to cache identified by factory ID (<see cref="P:DryIoc.Factory.FactoryID"/>).</summary>
            <param name="factoryID">Key in cache.</param>
            <param name="factoryExpression">Value to cache.</param>
        </member>
        <member name="M:DryIoc.Container.GetCachedFactoryExpressionOrDefault(System.Int32)">
            <summary>Searches and returns cached factory expression, or null if not found.</summary>
            <param name="factoryID">Factory ID to lookup by.</param> <returns>Found expression or null.</returns>
        </member>
        <member name="M:DryIoc.Container.GetOrAddStateItem(System.Object)">
            <summary>Adds item if it is not already added to state, returns added or existing item index.</summary>
            <param name="item">Item to find in existing items with <see cref="M:System.Object.Equals(System.Object,System.Object)"/> or add if not found.</param>
            <returns>Index of found or added item.</returns>
        </member>
        <member name="M:DryIoc.Container.GetOrAddStateItemExpression(System.Object,System.Type,System.Boolean)">
            <summary>If possible wraps added item in <see cref="T:System.Linq.Expressions.ConstantExpression"/> (possible for primitive type, Type, strings), 
            otherwise invokes <see cref="M:DryIoc.Container.GetOrAddStateItem(System.Object)"/> and wraps access to added item (by returned index) into expression: state =&gt; state.Get(index).</summary>
            <param name="item">Item to wrap or to add.</param> <param name="itemType">(optional) Specific type of item, otherwise item <see cref="M:System.Object.GetType"/>.</param>
            <param name="throwIfStateRequired">(optional) Enable filtering of stateful items.</param>
            <returns>Returns constant or state access expression for added items.</returns>
        </member>
        <member name="P:DryIoc.Container.OpenedScope">
            <summary>Container opened scope. May or may not be equal to Current Scope.</summary>
        </member>
        <member name="P:DryIoc.Container.ScopeContext">
            <summary>Returns scope context associated with container.</summary>
        </member>
        <member name="P:DryIoc.Container.DryIoc#IScopeAccess#SingletonScope">
            <summary>Scope containing container singletons.</summary>
        </member>
        <member name="P:DryIoc.Container.Rules">
            <summary>The rules object defines policies per container for registration and resolution.</summary>
        </member>
        <member name="P:DryIoc.Container.IsDisposed">
            <summary>Indicates that container is disposed.</summary>
        </member>
        <member name="P:DryIoc.Container.DryIoc#IContainer#EmptyRequest">
            <summary>Empty request bound to container. All other requests are created by pushing to empty request.</summary>
        </member>
        <member name="P:DryIoc.Container.DryIoc#IContainer#ContainerWeakRef">
            <summary>Self weak reference, with readable message when container is GCed/Disposed.</summary>
        </member>
        <member name="P:DryIoc.Container.ResolutionStateCache">
            <summary>State item objects which may include: singleton instances for fast access, reuses, reuse wrappers, factory delegates, etc.</summary>
        </member>
        <member name="T:DryIoc.ContainerTools">
            <summary>Extension methods for automating common use-cases.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackResolution(DryIoc.IContainer,System.Collections.Generic.IEnumerable{System.Type},System.Func{DryIoc.IReuse,DryIoc.Request,DryIoc.IReuse},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Adds rule to register unknown service when it is resolved.</summary>
            <param name="container">Container to add rule to.</param>
            <param name="implTypes">Provider of implementation types.</param>
            <param name="changeDefaultReuse">(optional) Delegate to change auto-detected (Singleton or Current) scope reuse to another reuse.</param>
            <param name="condition">(optional) condition.</param>
            <returns>Container with new rule.</returns>
            <remarks>Types provider will be asked on each rule evaluation.</remarks>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackResolution(DryIoc.IContainer,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Func{DryIoc.IReuse,DryIoc.Request,DryIoc.IReuse},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Adds rule to register unknown service when it is resolved.</summary>
            <param name="container">Container to add rule to.</param>
            <param name="implTypeAssemblies">Provides assembly with implementation types.</param>
            <param name="changeDefaultReuse">(optional) Delegate to change auto-detected (Singleton or Current) scope reuse to another reuse.</param>
            <param name="condition">(optional) condition.</param>
            <returns>Container with new rule.</returns>
            <remarks>Implementation types will be requested from assemblies only once, in this method call.</remarks>
        </member>
        <member name="M:DryIoc.ContainerTools.AutoRegisterUnknownServiceRule(System.Collections.Generic.IEnumerable{System.Type},System.Func{DryIoc.IReuse,DryIoc.Request,DryIoc.IReuse},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Fallback rule to automatically register requested service with Reuse based on resolution source.</summary>
            <param name="implTypes">Assemblies to look for implementation types.</param>
            <param name="changeDefaultReuse">(optional) Delegate to change auto-detected (Singleton or Current) scope reuse to another reuse.</param>
            <param name="condition">(optional) condition.</param>
            <returns>Rule.</returns>
        </member>
        <member name="T:DryIoc.DefaultKey">
            <summary>Used to represent multiple default service keys. 
            Exposes <see cref="F:DryIoc.DefaultKey.RegistrationOrder"/> to determine order of service added.</summary>
        </member>
        <member name="F:DryIoc.DefaultKey.Value">
            <summary>Default value.</summary>
        </member>
        <member name="F:DryIoc.DefaultKey.RegistrationOrder">
            <summary>Allows to determine service registration order.</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.Of(System.Int32)">
            <summary>Create new default key with specified registration order.</summary>
            <param name="registrationOrder"></param> <returns>New default key.</returns>
        </member>
        <member name="M:DryIoc.DefaultKey.Next">
            <summary>Returns next default key with increased <see cref="F:DryIoc.DefaultKey.RegistrationOrder"/>.</summary>
            <returns>New key.</returns>
        </member>
        <member name="M:DryIoc.DefaultKey.Equals(System.Object)">
            <summary>Compares keys based on registration order.</summary>
            <param name="key">Key to compare with.</param>
            <returns>True if keys have the same order.</returns>
        </member>
        <member name="M:DryIoc.DefaultKey.GetHashCode">
            <summary>Returns registration order as hash.</summary> <returns>Hash code.</returns>
        </member>
        <member name="M:DryIoc.DefaultKey.ToString">
            <summary>Prints registration order to string.</summary> <returns>Printed string.</returns>
        </member>
        <member name="T:DryIoc.ImTreeArray">
            <summary>Immutable array based on wide hash tree, where each node is sub-array with predefined size: 32 is by default.
            Array supports only append, no remove.</summary>
        </member>
        <member name="F:DryIoc.ImTreeArray.NODE_ARRAY_SIZE">
            <summary>Node array size. When the item added to same node, array will be copied. 
            So if array is too big performance will degrade. Should be power of two: e.g. 2, 4, 8, 16, 32...</summary>
        </member>
        <member name="F:DryIoc.ImTreeArray.Empty">
            <summary>Empty/default value to start from.</summary>
        </member>
        <member name="F:DryIoc.ImTreeArray.Length">
            <summary>Number of items in array.</summary>
        </member>
        <member name="M:DryIoc.ImTreeArray.Append(System.Object)">
            <summary>Appends value and returns new array.</summary>
            <param name="value">Value to append.</param> <returns>New array.</returns>
        </member>
        <member name="M:DryIoc.ImTreeArray.Get(System.Int32)">
            <summary>Returns item stored at specified index. Method relies on underlying array for index range checking.</summary>
            <param name="index">Index to look for item.</param> <returns>Found item.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">from underlying node array.</exception>
        </member>
        <member name="M:DryIoc.ImTreeArray.IndexOf(System.Object)">
            <summary>Returns index of first equal value in array if found, or -1 otherwise.</summary>
            <param name="value">Value to look for.</param> <returns>Index of first equal value, or -1 otherwise.</returns>
        </member>
        <member name="T:DryIoc.IResolverContext">
            <summary>Returns reference to actual resolver implementation. 
            Minimizes <see cref="T:DryIoc.FactoryDelegate"/> dependency on container.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.Resolver">
            <summary>Provides access to resolver implementation.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.Scopes">
            <summary>Scopes access.</summary>
        </member>
        <member name="T:DryIoc.ContainerWeakRef">
            <summary>Wraps <see cref="T:DryIoc.IContainer"/> WeakReference with more specialized exceptions on access to GCed or disposed container.</summary>
        </member>
        <member name="M:DryIoc.ContainerWeakRef.GetTarget">
            <summary>Retrieves container instance if it is not GCed or disposed</summary>
        </member>
        <member name="M:DryIoc.ContainerWeakRef.#ctor(DryIoc.IContainer)">
            <summary>Creates weak reference wrapper over passed container object.</summary> <param name="container">Object to wrap.</param>
        </member>
        <member name="P:DryIoc.ContainerWeakRef.Resolver">
            <summary>Provides access to resolver implementation.</summary>
        </member>
        <member name="P:DryIoc.ContainerWeakRef.Scopes">
            <summary>Scope access.</summary>
        </member>
        <member name="T:DryIoc.FactoryDelegate">
            <summary>The delegate type which is actually used to create service instance by container.
            Delegate instance required to be static with all information supplied by <paramref name="state"/> and <paramref name="scope"/>
            parameters. The requirement is due to enable compilation to DynamicMethod in DynamicAssembly, and also to simplify
            state management and minimizes memory leaks.</summary>
            <param name="state">All the state items available in resolution root.</param>
            <param name="r">Provides access to <see cref="T:DryIoc.IResolver"/> implementation to enable nested/dynamic resolve inside:
            registered delegate factory, <see cref="T:System.Lazy`1"/>, and <see cref="T:DryIoc.LazyEnumerable`1"/>.</param>
            <param name="scope">Resolution root scope: initially passed value will be null, but then the actual will be created on demand.</param>
            <returns>Created service object.</returns>
        </member>
        <member name="T:DryIoc.FactoryCompiler">
            <summary>Handles default conversation of expression into <see cref="T:DryIoc.FactoryDelegate"/>.</summary>
        </member>
        <member name="M:DryIoc.FactoryCompiler.WrapInFactoryExpression(System.Linq.Expressions.Expression)">
            <summary>Wraps service creation expression (body) into <see cref="T:DryIoc.FactoryDelegate"/> and returns result lambda expression.</summary>
            <param name="expression">Service expression (body) to wrap.</param> <returns>Created lambda expression.</returns>
        </member>
        <member name="M:DryIoc.FactoryCompiler.CompileToDelegate(System.Linq.Expressions.Expression,DryIoc.Rules)">
            <summary>First wraps the input service creation expression into lambda expression and
            then compiles lambda expression to actual <see cref="T:DryIoc.FactoryDelegate"/> used for service resolution.
            By default it is using Expression.Compile but if corresponding rule specified (available on .Net 4.0 and higher),
            it will compile to DymanicMethod/Assembly.</summary>
            <param name="expression">Service expression (body) to wrap.</param>
            <param name="rules">Specify requirement to compile expression to DynamicAssembly (available on .Net 4.0 and higher).</param>
            <returns>Compiled factory delegate to use for service resolution.</returns>
        </member>
        <member name="T:DryIoc.WrappersSupport">
            <summary>Adds to Container support for:
            <list type="bullet">
            <item>Open-generic services</item>
            <item>Service generics wrappers and arrays using <see cref="P:DryIoc.Rules.UnknownServiceResolvers"/> extension point.
            Supported wrappers include: Func of <see cref="F:DryIoc.WrappersSupport.FuncTypes"/>, Lazy, Many, IEnumerable, arrays, Meta, KeyValuePair, DebugExpression.
            All wrapper factories are added into collection <see cref="F:DryIoc.WrappersSupport.Wrappers"/> and searched by <see cref="F:DryIoc.WrappersSupport.ResolveWrappers"/>
            unregistered resolution rule.</item>
            </list></summary>
        </member>
        <member name="F:DryIoc.WrappersSupport.FuncTypes">
            <summary>Supported Func types up to 4 input parameters.</summary>
        </member>
        <member name="F:DryIoc.WrappersSupport.Wrappers">
            <summary>Registered wrappers by their concrete or generic definition service type.</summary>
        </member>
        <member name="F:DryIoc.WrappersSupport.ResolveWrappers">
            <summary>Unregistered/fallback wrapper resolution rule.</summary>
        </member>
        <member name="M:DryIoc.WrappersSupport.IsNestedInFuncWithArgs(DryIoc.Request)">
            <summary>Checks if request has parent with service type of Func with arguments. 
            Often required to check in lazy scenarios.</summary>
            <param name="request">Request too check.</param>
            <returns>True if has Func parent.</returns>
        </member>
        <member name="M:DryIoc.WrappersSupport.GetMetaExpressionOrDefault(DryIoc.Request)">
            <remarks>If service key is not specified in request then it will search for all
            registered factory with the same metadata type, despite keys.</remarks>
        </member>
        <member name="M:DryIoc.WrappersSupport.IsFunc(System.Type)">
            <summary>Returns true if type is supported <see cref="F:DryIoc.WrappersSupport.FuncTypes"/>, and false otherwise.</summary>
            <param name="type">Type to check.</param><returns>True for func type, false otherwise.</returns>
        </member>
        <member name="M:DryIoc.WrappersSupport.IsFuncWithArgs(System.Type)">
            <summary>Returns true if type is func with 1 or more input arguments.</summary>
            <param name="type">Type to check.</param><returns>True for func type, false otherwise.</returns>
        </member>
        <member name="T:DryIoc.Rules">
            <summary> Defines resolution/registration rules associated with Container instance. They may be different for different containers.</summary>
        </member>
        <member name="F:DryIoc.Rules.Empty">
            <summary>No rules specified.</summary>
            <remarks>Rules <see cref="P:DryIoc.Rules.UnknownServiceResolvers"/> are empty too.</remarks>
        </member>
        <member name="F:DryIoc.Rules.Default">
            <summary>Default rules with support for generic wrappers: IEnumerable, Many, arrays, Func, Lazy, Meta, KeyValuePair, DebugExpression.
            Check <see cref="F:DryIoc.WrappersSupport.ResolveWrappers"/> for details.</summary>
        </member>
        <member name="M:DryIoc.Rules.With(DryIoc.FactoryMethodSelector,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Returns new instance of the rules with specified <see cref="T:DryIoc.Made"/>.</summary>
            <returns>New rules with specified <see cref="T:DryIoc.Made"/>.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithFactorySelector(DryIoc.Rules.FactorySelectorRule)">
            <summary>Sets <see cref="P:DryIoc.Rules.FactorySelector"/></summary> 
            <param name="rule">Selectors to set, could be null to use default approach.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Rules.SelectLastRegisteredFactory">
            <summary>Select last registered factory from multiple default.</summary>
            <returns>Factory selection rule.</returns>
        </member>
        <member name="M:DryIoc.Rules.SelectKeyedOverDefaultFactory(System.Object)">
            <summary>Prefer specified service key (if found) over default key.
            Help to override default registrations in Open Scope scenarios: I may register service with key and resolve it as default in current scope.</summary>
            <param name="serviceKey">Service key to look for instead default.</param>
            <returns>Found factory or null.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithUnknownServiceResolver(DryIoc.Rules.UnknownServiceResolver[])">
            <summary>Appends resolver to current unknown service resolvers.</summary>
            <param name="rules">Rules to append.</param> <returns>New Rules.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithFallbackContainer(DryIoc.IContainer)">
            <summary>Appends WeakReference fallback container to end of the list.</summary>
            <param name="container">To append.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithoutFallbackContainer(DryIoc.IContainer)">
            <summary>Removes WeakReference to fallback container from the list.</summary>
            <param name="container">To remove.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithoutUnknownServiceResolver(DryIoc.Rules.UnknownServiceResolver)">
            <summary>Removes specified resolver from unknown service resolvers, and returns new Rules.
            If no resolver was found then <see cref="P:DryIoc.Rules.UnknownServiceResolvers"/> will stay the same instance, 
            so it could be check for remove success or fail.</summary>
            <param name="rule">Rule tor remove.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithoutThrowIfDependencyHasShorterReuseLifespan">
            <summary>Returns new rules with <see cref="P:DryIoc.Rules.ThrowIfDependencyHasShorterReuseLifespan"/> set to specified value.</summary>
            <returns>New rules with new setting value.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithReuseMapping(DryIoc.Rules.ReuseMappingRule)">
            <summary>Sets the <see cref="P:DryIoc.Rules.ReuseMapping"/> rule.</summary> <param name="rule">Rule to set, may be null.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithoutSingletonOptimization">
            <summary>Disables <see cref="P:DryIoc.Rules.SingletonOptimization"/></summary>
            <returns>New rules with singleton optimization turned off.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithItemToExpressionConverter(DryIoc.Rules.ItemToExpressionConverterRule)">
            <summary>Overrides previous rule. You may return null from new rule to fallback to old one.</summary>
            <param name="itemToExpressionOrDefault">Converts item to expression or returns null to fallback to old rule.</param>
            <returns>New rules</returns>
        </member>
        <member name="M:DryIoc.Rules.WithoutImplicitCheckForReuseMatchingScope">
            <summary>Removes <see cref="P:DryIoc.Rules.ImplicitCheckForReuseMatchingScope"/></summary>
            <returns>New rules.</returns>
        </member>
        <member name="P:DryIoc.Rules.FactoryMethod">
            <summary>Shorthand to <see cref="P:DryIoc.Made.FactoryMethod"/></summary>
        </member>
        <member name="P:DryIoc.Rules.Parameters">
            <summary>Shorthand to <see cref="P:DryIoc.Made.Parameters"/></summary>
        </member>
        <member name="P:DryIoc.Rules.PropertiesAndFields">
            <summary>Shorthand to <see cref="P:DryIoc.Made.PropertiesAndFields"/></summary>
        </member>
        <member name="P:DryIoc.Rules.FactorySelector">
            <summary>Rules to select single matched factory default and keyed registered factory/factories. 
            Selectors applied in specified array order, until first returns not null <see cref="T:DryIoc.Factory"/>.
            Default behavior is throw on multiple registered default factories, cause it is not obvious what to use.</summary>
        </member>
        <member name="P:DryIoc.Rules.UnknownServiceResolvers">
            <summary>Gets rules for resolving not-registered services. Null by default.</summary>
        </member>
        <member name="P:DryIoc.Rules.FallbackContainers">
            <summary>List of containers to fallback resolution to.</summary>
        </member>
        <member name="P:DryIoc.Rules.ThrowIfDependencyHasShorterReuseLifespan">
            <summary>Turns on/off exception throwing when dependency has shorter reuse lifespan than its parent.</summary>
        </member>
        <member name="P:DryIoc.Rules.ReuseMapping">
            <summary>Gets rule to retrieve actual reuse from registered one. May be null, so the registered reuse will be used.
            Could be used to specify different reuse container wide, for instance <see cref="F:DryIoc.Reuse.Singleton"/> instead of <see cref="F:DryIoc.Reuse.Transient"/>.</summary>
        </member>
        <member name="P:DryIoc.Rules.SingletonOptimization">
            <summary>Allow to instantiate singletons during resolution (but not inside of Func). Instantiated singletons
            will be copied to <see cref="P:DryIoc.IContainer.ResolutionStateCache"/> for faster access.</summary>
        </member>
        <member name="P:DryIoc.Rules.ItemToExpressionConverter">
            <summary>Mapping between Type and its ToExpression converter delegate.</summary>
        </member>
        <member name="P:DryIoc.Rules.ImplicitCheckForReuseMatchingScope">
            <summary>Flag acting in implicit <see cref="P:DryIoc.Setup.Condition"/> for service registered with not null <see cref="T:DryIoc.IReuse"/>.
            Condition skips resolution if no matching scope found.</summary>
        </member>
        <member name="T:DryIoc.Rules.FactorySelectorRule">
            <summary>Defines single factory selector delegate.</summary>
            <param name="request">Provides service request leading to factory selection.</param>
            <param name="factories">Registered factories with corresponding key to select from.</param>
            <returns>Single selected factory, or null if unable to select.</returns>
        </member>
        <member name="T:DryIoc.Rules.UnknownServiceResolver">
            <summary>Defines delegate to return factory for request not resolved by registered factories or prior rules.
            Applied in specified array order until return not null <see cref="T:DryIoc.Factory"/>.</summary> 
            <param name="request">Request to return factory for</param> <returns>Factory to resolve request, or null if unable to resolve.</returns>
        </member>
        <member name="T:DryIoc.Rules.ReuseMappingRule">
            <summary>Defines mapping from registered reuse to what will be actually used.</summary>
            <param name="reuse">Service registered reuse</param> <param name="request">Context.</param> <returns>Mapped result reuse to use.</returns>
        </member>
        <member name="T:DryIoc.Rules.ItemToExpressionConverterRule">
            <summary>Given item object and its type should return item "pure" expression presentation, 
            without side-effects or external dependencies. 
            e.g. for string "blah" <code lang="cs"><![CDATA[]]>Expression.Constant("blah", typeof(string))</code>.
            If unable to convert should return null.</summary>
            <param name="item">Item object. Item is not null.</param> 
            <param name="itemType">Item type. Item type is not null.</param>
            <returns>Expression or null.</returns>
        </member>
        <member name="T:DryIoc.FactoryMethod">
            <summary>Wraps constructor or factory method optionally with factory instance to create service.</summary>
        </member>
        <member name="F:DryIoc.FactoryMethod.ConstructorOrMethodOrMember">
            <summary>Constructor or method to use for service creation.</summary>
        </member>
        <member name="F:DryIoc.FactoryMethod.FactoryInfo">
            <summary>Factory info to resolve if factory method is instance member.</summary>
        </member>
        <member name="M:DryIoc.FactoryMethod.Of(System.Reflection.MemberInfo,DryIoc.ServiceInfo)">
            <summary>Wraps method and factory instance.</summary>
            <param name="ctorOrMethodOrMember">Constructor, static or instance method, property or field.</param>
            <param name="factoryInfo">Factory info to resolve in case of instance <paramref name="ctorOrMethodOrMember"/>.</param>
            <returns>New factory method wrapper.</returns>
        </member>
        <member name="M:DryIoc.FactoryMethod.op_Implicit(DryIoc.FactoryMethod)~DryIoc.FactoryMethodSelector">
            <summary>Converts method to selector when selector parameter is not required.</summary>
            <param name="method">Method to convert.</param> <returns>Result selector.</returns>
        </member>
        <member name="M:DryIoc.FactoryMethod.ToString">
            <summary>Pretty prints wrapped method.</summary> <returns>Printed string.</returns>
        </member>
        <member name="F:DryIoc.FactoryMethod.ConstructorWithResolvableArguments">
            <summary>Searches for constructor with all resolvable parameters or throws <see cref="T:DryIoc.ContainerException"/> if not found.
            Works both for resolving as service and as Func&lt;TArgs..., TService&gt;.</summary>
        </member>
        <member name="T:DryIoc.Made">
            <summary>Rules how to: <list type="bullet">
            <item>Select constructor for creating service with <see cref="P:DryIoc.Made.FactoryMethod"/>.</item>
            <item>Specify how to resolve constructor parameters with <see cref="P:DryIoc.Made.Parameters"/>.</item>
            <item>Specify what properties/fields to resolve and how with <see cref="P:DryIoc.Made.PropertiesAndFields"/>.</item>
            </list></summary>
        </member>
        <member name="F:DryIoc.Made.Default">
            <summary>Container will use some sensible defaults for service creation.</summary>
        </member>
        <member name="M:DryIoc.Made.op_Implicit(DryIoc.FactoryMethodSelector)~DryIoc.Made">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.FactoryMethod"/> specified.</summary>
            <param name="factoryMethod">To use.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Made.op_Implicit(DryIoc.FactoryMethod)~DryIoc.Made">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.FactoryMethod"/> specified.</summary>
            <param name="factoryMethod">To return from <see cref="P:DryIoc.Made.FactoryMethod"/>.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Made.op_Implicit(System.Reflection.MethodInfo)~DryIoc.Made">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.FactoryMethod"/> specified.</summary>
            <param name="factoryMethod">To create <see cref="T:DryIoc.FactoryMethod"/> and return it from <see cref="P:DryIoc.Made.FactoryMethod"/>.</param> 
            <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Made.op_Implicit(DryIoc.ParameterSelector)~DryIoc.Made">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.Parameters"/> specified.</summary>
            <param name="parameters">To use.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Made.op_Implicit(DryIoc.PropertiesAndFieldsSelector)~DryIoc.Made">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.PropertiesAndFields"/> specified.</summary>
            <param name="propertiesAndFields">To use.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Made.Of(DryIoc.FactoryMethodSelector,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Specifies injections rules for Constructor, Parameters, Properties and Fields. If no rules specified returns <see cref="F:DryIoc.Made.Default"/> rules.</summary>
            <param name="factoryMethod">(optional)</param> <param name="parameters">(optional)</param> <param name="propertiesAndFields">(optional)</param>
            <returns>New injection rules or <see cref="F:DryIoc.Made.Default"/>.</returns>
        </member>
        <member name="M:DryIoc.Made.Of(System.Func{System.Type,System.Reflection.ConstructorInfo},DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Defines how to select constructor from implementation type.</summary>
            <param name="getConstructor">Delegate taking implementation type as input and returning selected constructor info.</param>
            <param name="parameters">(optional)</param> <param name="propertiesAndFields">(optional)</param>
            <returns>New instance of <see cref="T:DryIoc.Made"/> with <see cref="P:DryIoc.Made.FactoryMethod"/> set to specified delegate.</returns>
        </member>
        <member name="M:DryIoc.Made.Of``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Func{DryIoc.Request,System.Object}[])">
            <summary>Defines factory method using expression of constructor call (with properties), or static method call.</summary>
            <typeparam name="TService">Type with constructor or static method.</typeparam>
            <param name="serviceReturningExpr">Expression tree with call to constructor with properties: 
            <code lang="cs"><![CDATA[() => new Car(Arg.Of<IEngine>()) { Color = Arg.Of<Color>("CarColor") }]]></code>
            or static method call <code lang="cs"><![CDATA[() => Car.Create(Arg.Of<IEngine>())]]></code></param>
            <param name="argValues">(optional) Primitive custom values for dependencies.</param>
            <returns>New Made specification.</returns>
        </member>
        <member name="M:DryIoc.Made.Of``2(System.Func{DryIoc.Request,DryIoc.ServiceInfo.Typed{``0}},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{DryIoc.Request,System.Object}[])">
            <summary>Defines creation info from factory method call Expression without using strings.
            You can supply any/default arguments to factory method, they won't be used, it is only to find the <see cref="T:System.Reflection.MethodInfo"/>.</summary>
            <typeparam name="TFactory">Factory type.</typeparam> <typeparam name="TService">Factory product type.</typeparam>
            <param name="getFactoryInfo">Returns or resolves factory instance.</param> 
            <param name="serviceReturningExpr">Method, property or field expression returning service.</param>
            <param name="argValues">(optional) Primitive custom values for dependencies.</param>
            <returns>New Made specification.</returns>
        </member>
        <member name="P:DryIoc.Made.FactoryMethod">
            <summary>Returns delegate to select constructor based on provided request.</summary>
        </member>
        <member name="P:DryIoc.Made.ExpressionResultType">
            <summary>Return type of strongly-typed expression.</summary>
        </member>
        <member name="P:DryIoc.Made.Parameters">
            <summary>Specifies how constructor parameters should be resolved: 
            parameter service key and type, throw or return default value if parameter is unresolved.</summary>
        </member>
        <member name="P:DryIoc.Made.PropertiesAndFields">
            <summary>Specifies what <see cref="T:DryIoc.ServiceInfo"/> should be used when resolving property or field.</summary>
        </member>
        <member name="T:DryIoc.Made.Expr`1">
            <summary>Typed version of <see cref="T:DryIoc.Made"/> specified with statically typed expression tree.</summary>
            <typeparam name="TService">Type that expression returns.</typeparam>
        </member>
        <member name="M:DryIoc.Made.Expr`1.#ctor(DryIoc.FactoryMethodSelector,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Creates typed version.</summary>
            <param name="factoryMethod"></param> <param name="parameters"></param> <param name="propertiesAndFields"></param>
        </member>
        <member name="T:DryIoc.Arg">
            <summary>Class for defining parameters/properties/fields service info in <see cref="T:DryIoc.Made"/> expressions.
            Its methods are NOT actually called, they just used to reflect service info from call expression.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1">
            <summary>Specifies required service type of parameter or member. If required type is the same as parameter/member type,
            the method is just a placeholder to help detect constructor or factory method, and does not have additional meaning.</summary>
            <typeparam name="TRequired">Required service type if different from parameter/member type.</typeparam>
            <returns>Returns some (ignored) value.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``1(DryIoc.IfUnresolved)">
            <summary>Specifies required service type of parameter or member. Plus specifies if-unresolved policy.</summary>
            <typeparam name="TRequired">Required service type if different from parameter/member type.</typeparam>
            <param name="ifUnresolved">Defines to throw or to return default if unresolved.</param>
            <returns>Returns some (ignored) value.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``1(System.Object)">
            <summary>Specifies required service type of parameter or member. Plus specifies service key.</summary>
            <typeparam name="TRequired">Required service type if different from parameter/member type.</typeparam>
            <param name="serviceKey">Service key object.</param>
            <returns>Returns some (ignored) value.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``1(DryIoc.IfUnresolved,System.Object)">
            <summary>Specifies required service type of parameter or member. Plus specifies if-unresolved policy. Plus specifies service key.</summary>
            <typeparam name="TRequired">Required service type if different from parameter/member type.</typeparam>
            <param name="ifUnresolved">Defines to throw or to return default if unresolved.</param>
            <param name="serviceKey">Service key object.</param>
            <returns>Returns some (ignored) value.</returns>
        </member>
        <member name="M:DryIoc.Arg.Ref``1(System.Int32)">
            <summary>Specifies argument index starting from 0 to use corresponding custom value factory, 
            similar to String.Format <c>"{0}, {1}, etc"</c>.</summary>
            <typeparam name="T">Type of dependency. Difference from actual parameter type is ignored.</typeparam>
            <param name="argIndex">Argument index starting from 0</param> <returns>Ignored.</returns>
        </member>
        <member name="F:DryIoc.Arg.RefMethodName">
            <summary>Name is close to method itself to not forget when renaming the method.</summary>
        </member>
        <member name="T:DryIoc.Registrator">
            <summary>Contains <see cref="T:DryIoc.IRegistrator"/> extension methods to simplify general use cases.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register(DryIoc.IRegistrator,System.Type,DryIoc.Factory,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers service of <paramref name="serviceType"/>.</summary>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="serviceType">The service type to register</param>
            <param name="factory"><see cref="T:DryIoc.Factory"/> details object.</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional Could be of any type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.Register(DryIoc.IRegistrator,System.Type,System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers service <paramref name="serviceType"/> with corresponding <paramref name="implementationType"/>.</summary>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="serviceType">The service type to register.</param>
            <param name="implementationType">Implementation type. Concrete and open-generic class are supported.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. 
                Default value means no reuse, aka Transient.</param>
            <param name="with">(optional) specifies <see cref="T:DryIoc.Made"/>.</param>
            <param name="setup">(optional) Factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) Policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.Register(DryIoc.IRegistrator,System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers service of <paramref name="implementationType"/>. ServiceType will be the same as <paramref name="implementationType"/>.</summary>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="implementationType">Implementation type. Concrete and open-generic class are supported.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="with">(optional) specifies <see cref="T:DryIoc.Made"/>.</param>
            <param name="setup">(optional) factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.Register``2(DryIoc.IRegistrator,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers service of <typeparamref name="TService"/> type implemented by <typeparamref name="TImplementation"/> type.</summary>
            <typeparam name="TService">The type of service.</typeparam>
            <typeparam name="TImplementation">The type of service.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="made">(optional) specifies <see cref="T:DryIoc.Made"/>.</param>
            <param name="setup">(optional) factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.Register``1(DryIoc.IRegistrator,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers implementation type <typeparamref name="TImplementation"/> with itself as service type.</summary>
            <typeparam name="TImplementation">The type of service.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="made">(optional) specifies <see cref="T:DryIoc.Made"/>.</param>
            <param name="setup">(optional) Factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) Policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.Register``2(DryIoc.IRegistrator,DryIoc.Made.Expr{``1},DryIoc.IReuse,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers service type returned by Made expression.</summary>
            <typeparam name="TService">The type of service.</typeparam>
            <typeparam name="TMadeResult">The type returned by Made expression.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="made">Made specified with strongly-typed service creation expression.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="setup">(optional) Factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) Policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.Register``1(DryIoc.IRegistrator,DryIoc.Made.Expr{``0},DryIoc.IReuse,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers service type returned by Made expression.</summary>
            <typeparam name="TService">The type of service.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="made">Made specified with strongly-typed service creation expression.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="setup">(optional) Factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) Policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Type[],System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers many service types with the same implementation.</summary>
            <param name="registrator">Registrator/Container</param>
            <param name="serviceTypes">1 or more service types.</param> 
            <param name="implementationType">Should implement service types. Will throw if not.</param>
            <param name="reuse">(optional)</param> <param name="made">(optional) How to create implementation instance.</param>
            <param name="setup">(optional)</param> <param name="ifAlreadyRegistered">(optional) By default <see cref="F:DryIoc.IfAlreadyRegistered.AppendNotKeyed"/></param>
            <param name="serviceKey">(optional)</param>
        </member>
        <member name="F:DryIoc.Registrator.ExcludedGeneralPurposeServiceTypes">
            <summary>List of types excluded by default from RegisterMany convention.</summary>
        </member>
        <member name="M:DryIoc.Registrator.GetImplementedServiceTypes(System.Type,System.Boolean)">
            <summary>Returns many service types implemented by source type. Used by RegisterMany method.</summary>
            <param name="type">Source type: may be concrete, abstract or generic definition.</param> 
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
            <returns>Array of types or empty.</returns>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Type},DryIoc.Registrator.RegisterManyAction,System.Boolean)">
            <summary>Registers many implementations with their auto-figured service types.</summary>
            <param name="registrator">Registrator/Container to register with.</param>
            <param name="implTypes">Implementation type provider.</param>
            <param name="action">(optional) User specified registration action: 
            may be used to filter registrations or specify non-default registration options, e.g. Reuse or ServiceKey, etc.</param>
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Type},DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Func{System.Type,System.Boolean},System.Boolean,System.Object)">
            <summary>Registers many implementations with their auto-figured service types.</summary>
            <param name="registrator">Registrator/Container to register with.</param>
            <param name="implTypes">Implementation type provider.</param>
            <param name="reuse">(optional) Reuse to apply to all service registrations.</param>
            <param name="made">(optional) Allow to select constructor/method to create service, specify how to inject its parameters and properties/fields.</param>
            <param name="setup">(optional) Factory setup, by default is <see cref="F:DryIoc.Setup.Default"/>, check <see cref="T:DryIoc.Setup"/> class for available setups.</param>
            <param name="ifAlreadyRegistered">(optional) Policy to deal with existing service registrations.</param>
            <param name="serviceTypeCondition">(optional) Condition to select only specific service type to register.</param>
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
            <param name="serviceKey">(optional) service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany``1(DryIoc.IRegistrator,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Func{System.Type,System.Boolean},System.Boolean,System.Object)">
            <summary>Registers single registration for all implemented internal interfaces and base classes.</summary>
            <typeparam name="TImplementation">The type to get service types from.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="made">(optional) Allow to select constructor/method to create service, specify how to inject its parameters and properties/fields.</param>
            <param name="setup">(optional) Factory setup, by default is <see cref="F:DryIoc.Setup.Default"/>, check <see cref="T:DryIoc.Setup"/> class for available setups.</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceTypeCondition">(optional) Condition to select only specific service type to register.</param>        
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
            <param name="serviceKey">(optional) service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany``1(DryIoc.IRegistrator,DryIoc.Made.Expr{``0},DryIoc.IReuse,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Func{System.Type,System.Boolean},System.Boolean,System.Object)">
            <summary>Registers single registration for all implemented internal interfaces and base classes.</summary>
            <typeparam name="TMadeResult">The type returned by Made factory expression.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="made">Made specified with strongly-typed factory expression.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="setup">(optional) Factory setup, by default is <see cref="F:DryIoc.Setup.Default"/>, check <see cref="T:DryIoc.Setup"/> class for available setups.</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceTypeCondition">(optional) Condition to select only specific service type to register.</param>        
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
            <param name="serviceKey">(optional) service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},DryIoc.Registrator.RegisterManyAction,System.Boolean)">
            <summary>Registers many implementations with their auto-figured service types.</summary>
            <param name="registrator">Registrator/Container to register with.</param>
            <param name="implTypeAssemblies">Assemblies with implementation/service types to register.</param>
            <param name="action">(optional) User specified registration action: 
            may be used to filter registrations or specify non-default registration options, e.g. Reuse or ServiceKey, etc.</param>
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Func{System.Type,System.Boolean},DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Boolean,System.Object)">
            <summary>Registers many implementations with their auto-figured service types.</summary>
            <param name="registrator">Registrator/Container to register with.</param>
            <param name="implTypeAssemblies">Assemblies with implementation/service types to register.</param>
            <param name="serviceTypeCondition">Condition to select only specific service type to register.</param>
            <param name="reuse">(optional) Reuse to apply to all service registrations.</param>
            <param name="made">(optional) Allow to select constructor/method to create service, specify how to inject its parameters and properties/fields.</param>
            <param name="setup">(optional) Factory setup, by default is <see cref="F:DryIoc.Setup.Default"/>, check <see cref="T:DryIoc.Setup"/> class for available setups.</param>
            <param name="ifAlreadyRegistered">(optional) Policy to deal with existing service registrations.</param>
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
            <param name="serviceKey">(optional) service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``1(DryIoc.IRegistrator,System.Func{DryIoc.IResolver,``0},DryIoc.IReuse,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers a factory delegate for creating an instance of <typeparamref name="TService"/>.
            Delegate can use <see cref="T:DryIoc.IResolver"/> parameter to resolve any required dependencies, e.g.:
            <code lang="cs"><![CDATA[container.RegisterDelegate<ICar>(r => new Car(r.Resolve<IEngine>()))]]></code></summary>
            <typeparam name="TService">The type of service.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="factoryDelegate">The delegate used to create a instance of <typeparamref name="TService"/>.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="setup">(optional) factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
            <remarks>The method should be used as the last resort only! Though powerful it is easy to get memory leaks
            (due variables captured in delegate closure) and impossible to use in generation scenarios.
            Consider using FactoryMethod instead: 
            <code lang="cs"><![CDATA[container.Register<ICar>(with: Method.Of(() => new Car(Arg.Of<IEngine>())))]]></code>.</remarks>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate(DryIoc.IRegistrator,System.Type,System.Func{DryIoc.IResolver,System.Object},DryIoc.IReuse,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers a factory delegate for creating an instance of <paramref name="serviceType"/>.
            Delegate can use <see cref="T:DryIoc.IResolver"/> parameter to resolve any required dependencies, e.g.:
            <code lang="cs"><![CDATA[container.RegisterDelegate<ICar>(r => new Car(r.Resolve<IEngine>()))]]></code></summary>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="serviceType">Service type to register.</param>
            <param name="factoryDelegate">The delegate used to create a instance of <paramref name="serviceType"/>.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="setup">(optional) factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegateDecorator``1(DryIoc.IRegistrator,System.Func{DryIoc.IResolver,System.Func{``0,``0}},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Registers decorator function that gets decorated value as input and return decorator.</summary>
            <typeparam name="TService">Registered service type to decorate.</typeparam>
            <param name="registrator">Registrator/Container.</param>
            <param name="getDecorator">Delegate returning decorating function.</param>
            <param name="condition">(optional) Condition for decorator application.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstance(DryIoc.IContainer,System.Type,System.Object,DryIoc.IReuse,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            <summary>Registers an externally created object of <paramref name="serviceType"/>. 
            If no reuse specified instance will be stored in Singleton Scope, and disposed when container is disposed.</summary>
            <param name="container">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="serviceType">Service type to register.</param>
            <param name="instance">The pre-created instance of <paramref name="serviceType"/>.</param>
            <param name="reuse">(optional) By default means <see cref="F:DryIoc.Reuse.Singleton"/> as the longest available.</param>
            <param name="ifAlreadyRegistered">(optional) If Replace specified then existing instance may be replaced in scope without introducing new factory.</param>
            <param name="preventDisposal">(optional) Prevents disposal of stored instance by wrapping it into <see cref="F:DryIoc.ReuseWrapper.HiddenDisposable"/>.</param>
            <param name="weaklyReferenced">(optional) Store as WeakReference. </param>
            <param name="serviceKey">(optional) service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstance``1(DryIoc.IContainer,``0,DryIoc.IReuse,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            <summary>Registers an externally created object of <typeparamref name="TService"/>. 
            If no reuse specified instance will be stored in Singleton Scope, and disposed when container is disposed.</summary>
            <typeparam name="TService">The type of service.</typeparam>
            <param name="container">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="instance">The pre-created instance of <typeparamref name="TService"/>.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="preventDisposal">(optional) Prevents disposal of stored instance by wrapping it into <see cref="F:DryIoc.ReuseWrapper.HiddenDisposable"/>.</param>
            <param name="weaklyReferenced">(optional) Store as WeakReference. </param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInitializer``1(DryIoc.IRegistrator,System.Action{``0,DryIoc.IResolver},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Registers initializing action that will be called after service is resolved just before returning it to caller.
            Check example below for using initializer to automatically subscribe to singleton event aggregator.
            You can register multiple initializers for single service. 
            Or you can register initializer for <see cref="T:System.Object"/> type to be applied for all services and use <paramref name="condition"/> 
            to filter target services.</summary>
            <remarks>Initializer internally implemented as decorator registered as Action delegate, so all decorators behavior is applied.</remarks>
            <typeparam name="TTarget">Any type implemented by requested service type including service type itself and object type.</typeparam>
            <param name="registrator">Usually is <see cref="T:DryIoc.Container"/> object.</param>
            <param name="initialize">Delegate with <typeparamref name="TTarget"/> object and 
            <see cref="T:DryIoc.IResolver"/> to resolve additional services required by initializer.</param>
            <param name="condition">(optional) Condition to select required target.</param>
            <example><code lang="cs"><![CDATA[
                container.Register<EventAggregator>(Reuse.Singleton);
                container.Register<ISubscriber, SomeSubscriber>();
            
                // Registers initializer for all subscribers implementing ISubscriber.
                container.RegisterInitiliazer<ISubscriber>((s, r) => r.Resolve<EventAggregator>().Subscribe(s));
            ]]></code></example>
        </member>
        <member name="M:DryIoc.Registrator.IsRegistered(DryIoc.IRegistrator,System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if <paramref name="serviceType"/> is registered in container or its open generic definition is registered in container.</summary>
            <param name="registrator">Usually <see cref="T:DryIoc.Container"/> to explore or any other <see cref="T:DryIoc.IRegistrator"/> implementation.</param>
            <param name="serviceType">The type of the registered service.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
            <param name="factoryType">(optional) factory type to lookup, <see cref="F:DryIoc.FactoryType.Service"/> by default.</param>
            <param name="condition">(optional) condition to specify what registered factory do you expect.</param>
            <returns>True if <paramref name="serviceType"/> is registered, false - otherwise.</returns>
        </member>
        <member name="M:DryIoc.Registrator.IsRegistered``1(DryIoc.IRegistrator,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if <typeparamref name="TService"/> type is registered in container or its open generic definition is registered in container.</summary>
            <typeparam name="TService">The type of service.</typeparam>
            <param name="registrator">Usually <see cref="T:DryIoc.Container"/> to explore or any other <see cref="T:DryIoc.IRegistrator"/> implementation.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
            <param name="factoryType">(optional) factory type to lookup, <see cref="F:DryIoc.FactoryType.Service"/> by default.</param>
            <param name="condition">(optional) condition to specify what registered factory do you expect.</param>
            <returns>True if <typeparamref name="TService"/> name="serviceType"/&gt; is registered, false - otherwise.</returns>
        </member>
        <member name="M:DryIoc.Registrator.Unregister(DryIoc.IRegistrator,System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes specified registration from container.</summary>
            <param name="registrator">Usually <see cref="T:DryIoc.Container"/> to explore or any other <see cref="T:DryIoc.IRegistrator"/> implementation.</param>
            <param name="serviceType">Type of service to remove.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
            <param name="factoryType">(optional) Factory type to lookup, <see cref="F:DryIoc.FactoryType.Service"/> by default.</param>
            <param name="condition">(optional) Condition for Factory to be removed.</param>
        </member>
        <member name="M:DryIoc.Registrator.Unregister``1(DryIoc.IRegistrator,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes specified registration from container.</summary>
            <typeparam name="TService">The type of service to remove.</typeparam>
            <param name="registrator">Usually <see cref="T:DryIoc.Container"/> or any other <see cref="T:DryIoc.IRegistrator"/> implementation.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
            <param name="factoryType">(optional) Factory type to lookup, <see cref="F:DryIoc.FactoryType.Service"/> by default.</param>
            <param name="condition">(optional) Condition for Factory to be removed.</param>
        </member>
        <member name="T:DryIoc.Registrator.RegisterManyAction">
            <summary>Action that could be used by User to customize register many default behavior.</summary>
            <param name="r">Registrator provided to do any arbitrary registration User wants.</param>
            <param name="serviceTypes">Valid service type that could be used with <paramref name="implType"/>.</param>
            <param name="implType">Concrete or open-generic implementation type.</param>
        </member>
        <member name="T:DryIoc.Resolver">
            <summary>Defines convenient extension methods for <see cref="T:DryIoc.IResolver"/>.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,DryIoc.IfUnresolved)">
            <summary>Returns instance of <typepsaramref name="TService"/> type.</summary>
            <param name="serviceType">The type of the requested service.</param>
            <param name="resolver">Any <see cref="T:DryIoc.IResolver"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="ifUnresolved">(optional) Says how to handle unresolved service.</param>
            <returns>The requested service instance.</returns>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,DryIoc.IfUnresolved)">
            <summary>Returns instance of <typepsaramref name="TService"/> type.</summary>
            <typeparam name="TService">The type of the requested service.</typeparam>
            <param name="resolver">Any <see cref="T:DryIoc.IResolver"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="ifUnresolved">(optional) Says how to handle unresolved service.</param>
            <returns>The requested service instance.</returns>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,System.Type,DryIoc.IfUnresolved)">
            <summary>Returns instance of <typeparamref name="TService"/> searching for <paramref name="requiredServiceType"/>.
            In case of <typeparamref name="TService"/> being generic wrapper like Func, Lazy, IEnumerable, etc., <paramref name="requiredServiceType"/>
            could specify wrapped service type.</summary>
            <typeparam name="TService">The type of the requested service.</typeparam>
            <param name="resolver">Any <see cref="T:DryIoc.IResolver"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="requiredServiceType">(optional) Service or wrapped type assignable to <typeparamref name="TService"/>.</param>
            <param name="ifUnresolved">(optional) Says how to handle unresolved service.</param>
            <returns>The requested service instance.</returns>
            <remarks>Using <paramref name="requiredServiceType"/> implicitly support Covariance for generic wrappers even in .Net 3.5.</remarks>
            <example><code lang="cs"><![CDATA[
                container.Register<IService, Service>();
                var services = container.Resolve<IEnumerable<object>>(typeof(IService));
            ]]></code></example>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,System.Object,DryIoc.IfUnresolved,System.Type)">
            <summary>Returns instance of <paramref name="serviceType"/> searching for <paramref name="requiredServiceType"/>.
            In case of <paramref name="serviceType"/> being generic wrapper like Func, Lazy, IEnumerable, etc., <paramref name="requiredServiceType"/>
            could specify wrapped service type.</summary>
            <param name="serviceType">The type of the requested service.</param>
            <param name="resolver">Any <see cref="T:DryIoc.IResolver"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="serviceKey">Service key (any type with <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/> defined).</param>
            <param name="ifUnresolved">(optional) Says how to handle unresolved service.</param>
            <param name="requiredServiceType">(optional) Service or wrapped type assignable to <paramref name="serviceType"/>.</param>
            <returns>The requested service instance.</returns>
            <remarks>Using <paramref name="requiredServiceType"/> implicitly support Covariance for generic wrappers even in .Net 3.5.</remarks>
            <example><code lang="cs"><![CDATA[
                container.Register<IService, Service>();
                var services = container.Resolve(typeof(Lazy<object>), "someKey", requiredServiceType: typeof(IService));
            ]]></code></example>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,System.Object,DryIoc.IfUnresolved,System.Type)">
            <summary>Returns instance of <typepsaramref name="TService"/> type.</summary>
            <typeparam name="TService">The type of the requested service.</typeparam>
            <param name="resolver">Any <see cref="T:DryIoc.IResolver"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="serviceKey">Service key (any type with <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/> defined).</param>
            <param name="ifUnresolved">(optional) Says how to handle unresolved service.</param>
            <param name="requiredServiceType">(optional) Service or wrapped type assignable to <typeparamref name="TService"/>.</param>
            <returns>The requested service instance.</returns>
            <remarks>Using <paramref name="requiredServiceType"/> implicitly support Covariance for generic wrappers even in .Net 3.5.</remarks>
        </member>
        <member name="M:DryIoc.Resolver.ResolveMany``1(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object)">
            <summary>Returns all registered services instances including all keyed and default registrations.
            Use <paramref name="behavior"/> to return either all registered services at the moment of resolve (dynamic fresh view) or
            the same services that were returned with first <see cref="M:DryIoc.Resolver.ResolveMany``1(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object)"/> call (fixed view).</summary>
            <typeparam name="TService">Return collection item type. It denotes registered service type if <paramref name="requiredServiceType"/> is not specified.</typeparam>
            <param name="resolver">Usually <see cref="T:DryIoc.Container"/> object.</param>
            <param name="requiredServiceType">(optional) Denotes registered service type. Should be assignable to <typeparamref name="TService"/>.</param>
            <param name="behavior">(optional) Specifies new registered services awareness. Aware by default.</param>
            <param name="serviceKey">(optional) Service key.</param>
            <returns>Result collection of services.</returns>
            <remarks>The same result could be achieved by directly calling:
            <code lang="cs"><![CDATA[
                container.Resolve<LazyEnumerable<IService>>();  // for dynamic result - default behavior
                container.Resolve<IService[]>();                // for fixed array
                container.Resolve<IEnumerable<IService>>();     // same as fixed array
            ]]></code>
            </remarks>
        </member>
        <member name="M:DryIoc.Resolver.InjectPropertiesAndFields``1(DryIoc.IContainer,``0,DryIoc.PropertiesAndFieldsSelector)">
            <summary>For given instance resolves and sets properties and fields.
            It respects <see cref="P:DryIoc.Rules.PropertiesAndFields"/> rules set per container, 
            or if rules are not set it uses <see cref="F:DryIoc.PropertiesAndFields.Auto"/>, 
            or you can specify your own rules with <paramref name="propertiesAndFields"/> parameter.</summary>
            <typeparam name="TService">Input and returned instance type.</typeparam>Service (wrapped)
            <param name="container">Usually a container instance, cause <see cref="T:DryIoc.Container"/> implements <see cref="T:DryIoc.IResolver"/></param>
            <param name="instance">Service instance with properties to resolve and initialize.</param>
            <param name="propertiesAndFields">(optional) Function to select properties and fields, overrides all other rules if specified.</param>
            <returns>Input instance with resolved dependencies, to enable fluent method composition.</returns>
            <remarks>Different Rules could be combined together using <see cref="M:DryIoc.PropertiesAndFields.And(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)"/> method.</remarks>        
        </member>
        <member name="M:DryIoc.Resolver.New(DryIoc.IContainer,System.Type,DryIoc.Made)">
            <summary>Creates service using container for injecting parameters without registering anything.</summary>
            <param name="container">Container to use for type creation and injecting its dependencies.</param>
            <param name="concreteType">Type to instantiate.</param>
            <param name="made">(optional) Injection rules to select constructor/factory method, inject parameters, properties and fields.</param>
            <returns>Object instantiated by constructor or object returned by factory method.</returns>
        </member>
        <member name="M:DryIoc.Resolver.New``1(DryIoc.IContainer,DryIoc.Made)">
            <summary>Creates service using container for injecting parameters without registering anything.</summary>
            <typeparam name="T">Type to instantiate.</typeparam>
            <param name="container">Container to use for type creation and injecting its dependencies.</param>
            <param name="made">(optional) Injection rules to select constructor/factory method, inject parameters, properties and fields.</param>
            <returns>Object instantiated by constructor or object returned by factory method.</returns>
        </member>
        <member name="T:DryIoc.ResolveManyBehavior">
            <summary>Specifies result of <see cref="M:DryIoc.Resolver.ResolveMany``1(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object)"/>: either dynamic(lazy) or fixed view.</summary>
        </member>
        <member name="F:DryIoc.ResolveManyBehavior.AsLazyEnumerable">
            <summary>Lazy/dynamic item resolve.</summary>
        </member>
        <member name="F:DryIoc.ResolveManyBehavior.AsFixedArray">
            <summary>Fixed array of item at time of resolve, newly registered/removed services won't be listed.</summary>
        </member>
        <member name="T:DryIoc.IServiceInfo">
            <summary>Provides information required for service resolution: service type, 
            and optional <see cref="T:DryIoc.ServiceDetails"/>: key, what to do if service unresolved, and required service type.</summary>
        </member>
        <member name="M:DryIoc.IServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
            <param name="serviceType">Required service type.</param> <param name="details">Optional details.</param> <returns>Create info.</returns>
        </member>
        <member name="P:DryIoc.IServiceInfo.ServiceType">
            <summary>The required piece of info: service type.</summary>
        </member>
        <member name="P:DryIoc.IServiceInfo.Details">
            <summary>Additional optional details: service key, if-unresolved policy, required service type.</summary>
        </member>
        <member name="T:DryIoc.ServiceDetails">
            <summary>Provides optional service resolution details: service key, required service type, what return when service is unresolved,
            default value if service is unresolved, custom service value.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.Default">
            <summary>Default details if not specified, use default setting values, e.g. <see cref="F:DryIoc.IfUnresolved.Throw"/></summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.IfUnresolvedReturnDefault">
            <summary>The same as <see cref="F:DryIoc.ServiceDetails.Default"/> with only difference <see cref="P:DryIoc.ServiceDetails.IfUnresolved"/> set to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</summary>
        </member>
        <member name="M:DryIoc.ServiceDetails.Of(System.Type,System.Object,DryIoc.IfUnresolved,System.Object)">
            <summary>Creates new DTO out of provided settings, or returns default if all settings have default value.</summary>
            <param name="requiredServiceType">Registered service type to search for.</param>
            <param name="serviceKey">Service key.</param> <param name="ifUnresolved">If unresolved policy.</param>
            <param name="defaultValue">Custom default value, if specified it will automatically set <paramref name="ifUnresolved"/> to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</param>
            <returns>Created details DTO.</returns>
        </member>
        <member name="M:DryIoc.ServiceDetails.Of(System.Object)">
            <summary>Sets custom value for service. This setting is orthogonal to the rest.</summary>
            <param name="value">Custom value.</param> <returns>Details with custom value.</returns>
        </member>
        <member name="M:DryIoc.ServiceDetails.ToString">
            <summary>Pretty prints service details to string for debugging and errors.</summary> <returns>Details string.</returns>
        </member>
        <member name="P:DryIoc.ServiceDetails.RequiredServiceType">
            <summary>Service type to search in registry. Should be assignable to user requested service type.</summary>
        </member>
        <member name="P:DryIoc.ServiceDetails.ServiceKey">
            <summary>Service key provided with registration.</summary>
        </member>
        <member name="P:DryIoc.ServiceDetails.IfUnresolved">
            <summary>Policy to deal with unresolved request.</summary>
        </member>
        <member name="P:DryIoc.ServiceDetails.DefaultValue">
            <summary>Value to use in case <see cref="P:DryIoc.ServiceDetails.IfUnresolved"/> is set to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</summary>
        </member>
        <member name="P:DryIoc.ServiceDetails.CustomValue">
            <summary>Custom value specified for dependency.</summary>
        </member>
        <member name="T:DryIoc.ServiceInfoTools">
            <summary>Contains tools for combining or propagating of <see cref="T:DryIoc.IServiceInfo"/> independent of its concrete implementations.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.WithDetails``1(``0,DryIoc.ServiceDetails,DryIoc.Request)">
            <summary>Combines service info with details: the main task is to combine service and required service type.</summary>
            <typeparam name="T">Type of <see cref="T:DryIoc.IServiceInfo"/>.</typeparam>
            <param name="info">Source info.</param> <param name="details">Details to combine with info.</param> 
            <param name="request">Owner request.</param> <returns>Original source or new combined info.</returns>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.InheritInfo(DryIoc.IServiceInfo,DryIoc.IServiceInfo,System.Boolean)">
            <summary>Enables propagation/inheritance of info between dependency and its owner: 
            for instance <see cref="P:DryIoc.ServiceDetails.RequiredServiceType"/> for wrappers.</summary>
            <param name="dependency">Dependency info.</param>
            <param name="owner">Dependency holder/owner info.</param>
            <param name="shouldInheritServiceKey">(optional) Self-explanatory. Usually set to true for wrapper and decorator info.</param>
            <returns>Either input dependency info, or new info with properties inherited from the owner.</returns>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.Print(System.Text.StringBuilder,DryIoc.IServiceInfo)">
            <summary>Appends info string representation into provided builder.</summary>
            <param name="s">String builder to print to.</param> <param name="info">Info to print.</param>
            <returns>String builder with appended info.</returns>
        </member>
        <member name="T:DryIoc.ServiceInfo">
            <summary>Represents custom or resolution root service info, there is separate representation for parameter, 
            property and field dependencies.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of(System.Type,DryIoc.IfUnresolved,System.Object)">
            <summary>Creates info out of provided settings</summary>
            <param name="serviceType">Service type</param>
            <param name="ifUnresolved">(optional) If unresolved policy. Set to Throw if not specified.</param>
            <param name="serviceKey">(optional) Service key.</param>
            <returns>Created info.</returns>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of``1(DryIoc.IfUnresolved,System.Object)">
            <summary>Creates service info using typed <typeparamref name="TService"/>.</summary>
            <typeparam name="TService">Service type.</typeparam>
            <param name="ifUnresolved">(optional)</param> <param name="serviceKey">(optional)</param>
            <returns>Created info.</returns>
        </member>
        <member name="M:DryIoc.ServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
            <param name="serviceType">Required service type.</param> <param name="details">Optional details.</param> <returns>Create info.</returns>
        </member>
        <member name="M:DryIoc.ServiceInfo.ToString">
            <summary>Prints info to string using <see cref="M:DryIoc.ServiceInfoTools.Print(System.Text.StringBuilder,DryIoc.IServiceInfo)"/>.</summary> <returns>Printed string.</returns>
        </member>
        <member name="P:DryIoc.ServiceInfo.ServiceType">
            <summary>Type of service to create. Indicates registered service in registry.</summary>
        </member>
        <member name="P:DryIoc.ServiceInfo.Details">
            <summary>Additional settings. If not specified uses <see cref="F:DryIoc.ServiceDetails.Default"/>.</summary>
        </member>
        <member name="T:DryIoc.ServiceInfo.Typed`1">
            <summary>Strongly-typed version of Service Info.</summary> <typeparam name="TService">Service type.</typeparam>
        </member>
        <member name="M:DryIoc.ServiceInfo.Typed`1.#ctor">
            <summary>Creates service info object.</summary>
        </member>
        <member name="T:DryIoc.ParameterServiceInfo">
            <summary>Provides <see cref="T:DryIoc.IServiceInfo"/> for parameter, 
            by default using parameter name as <see cref="P:DryIoc.IServiceInfo.ServiceType"/>.</summary>
            <remarks>For parameter default setting <see cref="P:DryIoc.ServiceDetails.IfUnresolved"/> is <see cref="F:DryIoc.IfUnresolved.Throw"/>.</remarks>
        </member>
        <member name="M:DryIoc.ParameterServiceInfo.Of(System.Reflection.ParameterInfo)">
            <summary>Creates service info from parameter alone, setting service type to parameter type,
            and setting resolution policy to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/> if parameter is optional.</summary>
            <param name="parameter">Parameter to create info for.</param>
            <returns>Parameter service info.</returns>
        </member>
        <member name="M:DryIoc.ParameterServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
            <param name="serviceType">Required service type.</param> <param name="details">Optional details.</param> <returns>Create info.</returns>
        </member>
        <member name="M:DryIoc.ParameterServiceInfo.ToString">
            <summary>Prints info to string using <see cref="M:DryIoc.ServiceInfoTools.Print(System.Text.StringBuilder,DryIoc.IServiceInfo)"/>.</summary> <returns>Printed string.</returns>
        </member>
        <member name="P:DryIoc.ParameterServiceInfo.ServiceType">
            <summary>Service type specified by <see cref="P:System.Reflection.ParameterInfo.ParameterType"/>.</summary>
        </member>
        <member name="P:DryIoc.ParameterServiceInfo.Details">
            <summary>Optional service details.</summary>
        </member>
        <member name="T:DryIoc.PropertyOrFieldServiceInfo">
            <summary>Base class for property and field dependency info.</summary>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.Of(System.Reflection.MemberInfo)">
            <summary>Create member info out of provide property or field.</summary>
            <param name="member">Member is either property or field.</param> <returns>Created info.</returns>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
            <param name="serviceType">Required service type.</param> <param name="details">Optional details.</param> <returns>Create info.</returns>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.SetValue(System.Object,System.Object)">
            <summary>Sets property or field value on provided holder object.</summary>
            <param name="holder">Holder of property or field.</param> <param name="value">Value to set.</param>
        </member>
        <member name="P:DryIoc.PropertyOrFieldServiceInfo.ServiceType">
            <summary>The required service type. It will be either <see cref="P:System.Reflection.FieldInfo.FieldType"/> or <see cref="P:System.Reflection.PropertyInfo.PropertyType"/>.</summary>
        </member>
        <member name="P:DryIoc.PropertyOrFieldServiceInfo.Details">
            <summary>Optional details: service key, if-unresolved policy, required service type.</summary>
        </member>
        <member name="P:DryIoc.PropertyOrFieldServiceInfo.Member">
            <summary>Either <see cref="T:System.Reflection.PropertyInfo"/> or <see cref="T:System.Reflection.FieldInfo"/>.</summary>
        </member>
        <member name="T:DryIoc.Request">
            <summary>Contains resolution stack with information about resolved service and factory for it,
            Additionally request contain weak reference to <see cref="T:DryIoc.IContainer"/>. That the all required information for resolving services.
            Request implements <see cref="T:DryIoc.IResolver"/> interface on top of provided container, which could be use by delegate factories.</summary>
        </member>
        <member name="M:DryIoc.Request.CreateEmpty(DryIoc.ContainerWeakRef)">
            <summary>Creates empty request associated with provided <paramref name="container"/>.
            Every resolution will start from this request by pushing service information into, and then resolving it.</summary>
            <param name="container">Reference to container issued the request. Could be changed later with <see cref="M:DryIoc.Request.SwitchContainer(DryIoc.ContainerWeakRef)"/> method.</param>
            <returns>New empty request.</returns>
        </member>
        <member name="F:DryIoc.Request.Parent">
            <summary>Previous request in dependency chain. It <see cref="P:DryIoc.Request.IsEmpty"/> for resolution root.</summary>
        </member>
        <member name="F:DryIoc.Request.ResolvedFactory">
            <summary>Factory found in container to resolve this request.</summary>
        </member>
        <member name="F:DryIoc.Request.FuncArgs">
            <summary>List of specified arguments to use instead of resolving them.</summary>
        </member>
        <member name="F:DryIoc.Request.ContainerWeakRef">
            <summary>Weak reference to container.</summary>
        </member>
        <member name="F:DryIoc.Request.Scope">
            <summary>Resolution scope.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(DryIoc.IServiceInfo,DryIoc.IScope)">
            <summary>Creates new request with provided info, and attaches current request as new request parent.</summary>
            <param name="info">Info about service to resolve.</param> <param name="scope">(optional) Resolution scope.</param>
            <returns>New request for provided info.</returns>
            <remarks>Current request should be resolved to factory (<see cref="M:DryIoc.Request.ResolveWithFactory(DryIoc.Factory)"/>), before pushing info into it.</remarks>
        </member>
        <member name="M:DryIoc.Request.Push(System.Type,System.Object,DryIoc.IfUnresolved,System.Type,DryIoc.IScope)">
            <summary>Composes service description into <see cref="T:DryIoc.IServiceInfo"/> and calls Push.</summary>
            <param name="serviceType">Service type to resolve.</param>
            <param name="serviceKey">(optional) Service key to resolve.</param>
            <param name="ifUnresolved">(optional) Instructs how to handle unresolved service.</param>
            <param name="requiredServiceType">(optional) Registered/unwrapped service type to find.</param>
            <param name="scope">(optional) Resolution scope.</param>
            <returns>New request with provided info.</returns>
        </member>
        <member name="M:DryIoc.Request.UpdateServiceInfo(System.Func{DryIoc.IServiceInfo,DryIoc.IServiceInfo})">
            <summary>Allow to switch current service info to new one: for instance it is used be decorators.</summary>
            <param name="getInfo">Gets new info to switch to.</param>
            <returns>New request with new info but the rest intact: e.g. <see cref="F:DryIoc.Request.ResolvedFactory"/>.</returns>
        </member>
        <member name="M:DryIoc.Request.ChangeServiceKey(System.Object)">
            <summary>Sets service key to passed value. Required for multiple default services to change null key to
            actual <see cref="T:DryIoc.DefaultKey"/></summary>
            <param name="serviceKey">Key to set.</param>
        </member>
        <member name="M:DryIoc.Request.WithFuncArgs(System.Type,System.String)">
            <summary>Returns new request with parameter expressions created for <paramref name="funcType"/> input arguments.
            The expression is set to <see cref="F:DryIoc.Request.FuncArgs"/> request field to use for <see cref="F:DryIoc.WrappersSupport.FuncTypes"/>
            resolution.</summary>
            <param name="funcType">Func type to get input arguments from.</param>
            <param name="funcArgPrefix">(optional) Unique prefix to help generate non-conflicting argument names.</param>
            <returns>New request with <see cref="F:DryIoc.Request.FuncArgs"/> field set.</returns>
        </member>
        <member name="M:DryIoc.Request.SwitchContainer(DryIoc.ContainerWeakRef)">
            <summary>Changes container to passed one. Could be used by child container, 
            to switch child container to parent preserving the rest of request state.</summary>
            <param name="containerWeakRef">Reference to container to switch to.</param>
            <returns>Request with replaced container.</returns>
        </member>
        <member name="M:DryIoc.Request.ResolveWithFactory(DryIoc.Factory)">
            <summary>Returns new request with set <see cref="F:DryIoc.Request.ResolvedFactory"/>.</summary>
            <param name="factory">Factory to which request is resolved.</param>
            <returns>New request with set factory.</returns>
        </member>
        <member name="M:DryIoc.Request.ParentNonWrapper">
            <summary>Searches parent request stack upward and returns closest parent of <see cref="F:DryIoc.FactoryType.Service"/>.
            If not found returns <see cref="P:DryIoc.Request.IsEmpty"/> request.</summary> <returns>Found parent or <see cref="P:DryIoc.Request.IsEmpty"/> request.</returns>
        </member>
        <member name="M:DryIoc.Request.ParentNonWrapper(System.Func{DryIoc.Request,System.Boolean})">
            <summary>Searches parent request stack upward and returns closest parent of <see cref="F:DryIoc.FactoryType.Service"/>.
            If not found returns <see cref="P:DryIoc.Request.IsEmpty"/> request.</summary>
            <param name="condition">Condition, e.g. to find root request condition may be: <code lang="cs"><![CDATA[p => p.Parent.IsEmpty]]></code></param>
            <returns>Found parent or empty request.</returns>
        </member>
        <member name="M:DryIoc.Request.Enumerate">
            <summary>Enumerates all request stack parents. Last returned will <see cref="P:DryIoc.Request.IsEmpty"/> empty parent.</summary>
            <returns>Unfolding parents.</returns>
        </member>
        <member name="M:DryIoc.Request.PrintCurrent(System.Text.StringBuilder)">
            <summary>Prints current request info only (no parents printed) to provided builder.</summary>
            <param name="s">Builder to print too.</param>
            <returns>(optional) Builder to appended info to, or new builder if not specified.</returns>
        </member>
        <member name="M:DryIoc.Request.Print(System.Int32)">
            <summary>Prints full stack of requests starting from current one using <see cref="M:DryIoc.Request.PrintCurrent(System.Text.StringBuilder)"/>.</summary>
            <param name="recursiveFactoryID">Flag specifying that in case of found recursion/repetition of requests, 
            mark repeated requests.</param>
            <returns>Builder with appended request stack info.</returns>
        </member>
        <member name="M:DryIoc.Request.ToString">
            <summary>Print while request stack info to string using <seealso cref="M:DryIoc.Request.Print(System.Int32)"/>.</summary>
            <returns>String with info.</returns>
        </member>
        <member name="P:DryIoc.Request.IsEmpty">
            <summary>Indicates that request is empty initial request: there is no <see cref="P:DryIoc.Request.ServiceInfo"/> in such a request.</summary>
        </member>
        <member name="P:DryIoc.Request.ServiceInfo">
            <summary>Requested service id info and commanded resolution behavior.</summary>
        </member>
        <member name="P:DryIoc.Request.Container">
            <summary>Provides access to container currently bound to request. 
            By default it is container initiated request by calling resolve method,
            but could be changed along the way: for instance when resolving from parent container.</summary>
        </member>
        <member name="P:DryIoc.Request.ServiceType">
            <summary>Shortcut access to <see cref="P:DryIoc.IServiceInfo.ServiceType"/>.</summary>
        </member>
        <member name="P:DryIoc.Request.ServiceKey">
            <summary>Shortcut access to <see cref="P:DryIoc.ServiceDetails.ServiceKey"/>.</summary>
        </member>
        <member name="P:DryIoc.Request.IfUnresolved">
            <summary>Shortcut access to <see cref="P:DryIoc.ServiceDetails.IfUnresolved"/>.</summary>
        </member>
        <member name="P:DryIoc.Request.RequiredServiceType">
            <summary>Shortcut access to <see cref="P:DryIoc.ServiceDetails.RequiredServiceType"/>.</summary>
        </member>
        <member name="P:DryIoc.Request.ImplementationType">
            <summary>Implementation type of factory, if request was <see cref="M:DryIoc.Request.ResolveWithFactory(DryIoc.Factory)"/> factory, or null otherwise.</summary>
        </member>
        <member name="P:DryIoc.Request.IsCompositionRoot">
            <summary>Returns true if request originated from first Resolve call.</summary>
        </member>
        <member name="T:DryIoc.FactoryType">
            <summary>Type of services supported by Container.</summary>
        </member>
        <member name="F:DryIoc.FactoryType.Service">
            <summary>(default) Defines normal service factory</summary>
        </member>
        <member name="F:DryIoc.FactoryType.Decorator">
            <summary>Defines decorator factory</summary>
        </member>
        <member name="F:DryIoc.FactoryType.Wrapper">
            <summary>Defines wrapper factory.</summary>
        </member>
        <member name="T:DryIoc.Setup">
            <summary>Base class to store optional <see cref="T:DryIoc.Factory"/> settings.</summary>
        </member>
        <member name="F:DryIoc.Setup.Default">
            <summary>Default setup for service factories.</summary>
        </member>
        <member name="M:DryIoc.Setup.With(System.Boolean,System.Func{System.Object},System.Object,System.Func{DryIoc.Request,System.Boolean},System.Boolean,System.Type[])">
            <summary>Constructs setup object out of specified settings. If all settings are default then <see cref="F:DryIoc.Setup.Default"/> setup will be returned.</summary>
            <param name="cacheFactoryExpression">(optional)</param> <param name="lazyMetadata">(optional)</param> 
            <param name="metadata">(optional) Overrides <paramref name="lazyMetadata"/></param> <param name="condition">(optional)</param>
            <param name="openResolutionScope">(optional) If true dependency expression will be "r.Resolve(...)" instead of inline expression.</param>
            <param name="reuseWrappers">(optional) Multiple reuse wrappers.</param>       
            <returns>New setup object or <see cref="F:DryIoc.Setup.Default"/>.</returns>
        </member>
        <member name="F:DryIoc.Setup.Wrapper">
            <summary>Default setup which will look for wrapped service type as single generic parameter.</summary>
        </member>
        <member name="M:DryIoc.Setup.WrapperOfTypeArg(System.Int32)">
            <summary>Returns generic wrapper setup.</summary>
            <param name="index">(optional) Generic type arg index - default -1 is for single type arg.</param>
            <returns>New setup with specified index or <see cref="F:DryIoc.Setup.Wrapper"/> otherwise.</returns>
        </member>
        <member name="F:DryIoc.Setup.WrapperOfRequiredServiceType">
            <summary>Required service type setup.</summary>
        </member>
        <member name="M:DryIoc.Setup.ReuseWrapper(DryIoc.IReuseWrapperFactory)">
            <summary>Reuse wrapper setup.</summary>
            <param name="reuseWrapperFactory"></param>
            <returns>New reuse wrapper setup.</returns>
        </member>
        <member name="F:DryIoc.Setup.Decorator">
            <summary>Default decorator setup: decorator is applied to service type it registered with.</summary>
        </member>
        <member name="M:DryIoc.Setup.DecoratorWith(System.Func{DryIoc.Request,System.Boolean})">
            <summary>Creates setup with optional condition.</summary>
            <param name="condition">(optional)</param> <returns>New setup with condition or <see cref="F:DryIoc.Setup.Decorator"/>.</returns>
        </member>
        <member name="P:DryIoc.Setup.FactoryType">
            <summary>Factory type is required to be specified by concrete setups as in 
            <see cref="T:DryIoc.Setup.ServiceSetup"/>, <see cref="T:DryIoc.Setup.DecoratorSetup"/>, <see cref="T:DryIoc.Setup.WrapperSetup"/>.</summary>
        </member>
        <member name="P:DryIoc.Setup.Condition">
            <summary>Predicate to check if factory could be used for resolved request.</summary>
        </member>
        <member name="P:DryIoc.Setup.CacheFactoryExpression">
            <summary>Set to true allows to cache and use cached factored service expression.</summary>
        </member>
        <member name="P:DryIoc.Setup.Metadata">
            <summary>Arbitrary metadata object associated with Factory/Implementation.</summary>
        </member>
        <member name="P:DryIoc.Setup.OpenResolutionScope">
            <summary>Indicates that injected expression should be: 
            <c><![CDATA[r.Resolver.Resolve<IDependency>(...)]]></c>
            instead of: <c><![CDATA[new Dependency(...)]]></c></summary>
        </member>
        <member name="P:DryIoc.Setup.ReuseWrappers">
            <summary>Specifies how to wrap the reused/shared instance to apply additional behavior, e.g. <see cref="T:System.WeakReference"/>, 
            or disable disposing with <see cref="T:DryIoc.ReuseHiddenDisposable"/>, etc.</summary>
        </member>
        <member name="T:DryIoc.Setup.WrapperSetup">
            <summary>Setup for <see cref="F:DryIoc.FactoryType.Wrapper"/> factory.</summary>
        </member>
        <member name="F:DryIoc.Setup.WrapperSetup.WrappedServiceTypeArgIndex">
            <summary>Delegate to get wrapped type from provided wrapper type. 
            If wrapper is generic, then wrapped type is usually a generic parameter.</summary>
        </member>
        <member name="F:DryIoc.Setup.WrapperSetup.WrapsRequiredServiceType">
            <summary>Per name.</summary>
        </member>
        <member name="F:DryIoc.Setup.WrapperSetup.ReuseWrapperFactory">
            <summary>(optional) Tool for wrapping and unwrapping reused object.</summary>
        </member>
        <member name="M:DryIoc.Setup.WrapperSetup.#ctor(System.Int32)">
            <summary>Constructs wrapper setup from optional wrapped type selector and reuse wrapper factory.</summary>
            <param name="wrappedServiceTypeArgIndex"></param> 
        </member>
        <member name="M:DryIoc.Setup.WrapperSetup.#ctor(DryIoc.IReuseWrapperFactory)">
            <summary>Constructs wrapper setup from optional wrapped type selector and reuse wrapper factory.</summary>
            <param name="reuseWrapperFactory">(optional)</param>
        </member>
        <member name="M:DryIoc.Setup.WrapperSetup.GetWrappedTypeOrNullIfWrapsRequired(System.Type)">
            <summary>Unwraps service type or returns its.</summary>
            <param name="serviceType"></param>
            <returns>Wrapped type or self.</returns>
        </member>
        <member name="P:DryIoc.Setup.WrapperSetup.FactoryType">
            <summary>Returns <see cref="F:DryIoc.FactoryType.Wrapper"/> type.</summary>
        </member>
        <member name="T:DryIoc.IConcreteFactoryProvider">
            <summary>Facility for creating concrete factories from some template/prototype. Example: 
            creating closed-generic type reflection factory from registered open-generic prototype factory.</summary>
        </member>
        <member name="M:DryIoc.IConcreteFactoryProvider.ProvideConcreteFactory(DryIoc.Request)">
            <summary>Method applied for factory provider, returns new factory per request.</summary>
            <param name="request">Request to resolve.</param> <returns>Returns new factory per request.</returns>
        </member>
        <member name="P:DryIoc.IConcreteFactoryProvider.ProvidedFactoriesServiceTypeKey">
            <summary>Returns factories created by <see cref="M:DryIoc.IConcreteFactoryProvider.ProvideConcreteFactory(DryIoc.Request)"/> so far.</summary>
        </member>
        <member name="T:DryIoc.Factory">
            <summary>Base class for different ways to instantiate service: 
            <list type="bullet">
            <item>Through reflection - <see cref="T:DryIoc.ReflectionFactory"/></item>
            <item>Using custom delegate - <see cref="T:DryIoc.DelegateFactory"/></item>
            <item>Using custom expression - <see cref="T:DryIoc.ExpressionFactory"/></item>
            </list>
            For all of the types Factory should provide result as <see cref="T:System.Linq.Expressions.Expression"/> and <see cref="T:DryIoc.FactoryDelegate"/>.
            Factories are supposed to be immutable and stateless.
            Each created factory has an unique ID set in <see cref="P:DryIoc.Factory.FactoryID"/>.</summary>
        </member>
        <member name="F:DryIoc.Factory.Reuse">
            <summary>Reuse policy for factory created services.</summary>
        </member>
        <member name="M:DryIoc.Factory.CheckCondition(DryIoc.Request)">
            <summary>Checks that condition is met for request or there is no condition setup. 
            Additionally check for reuse scope availability.</summary>
            <param name="request">Request to check against.</param>
            <returns>True if condition met or no condition setup.</returns>
        </member>
        <member name="M:DryIoc.Factory.#ctor(DryIoc.IReuse,DryIoc.Setup)">
            <summary>Initializes reuse and setup. Sets the <see cref="P:DryIoc.Factory.FactoryID"/></summary>
            <param name="reuse">(optional)</param>
            <param name="setup">(optional)</param>
        </member>
        <member name="M:DryIoc.Factory.IsMatchingReuseScope(DryIoc.Request)">
            <summary>Returns true if for factory Reuse exists matching resolution or current Scope.</summary>
            <param name="request"></param> <returns>True if matching Scope exists.</returns>
        </member>
        <member name="M:DryIoc.Factory.ThrowIfInvalidRegistration(DryIoc.IContainer,System.Type,System.Object,System.Boolean)">
            <summary>Validates that factory is OK for registered service type.</summary>
            <param name="container">Container to register factory in.</param>
            <param name="serviceType">Service type to register factory for.</param>
            <param name="serviceKey">Service key to register factory with.</param>
            <param name="isStaticallyChecked">Skips service type check. Means that service and implementation are statically checked.</param>
        </member>
        <member name="M:DryIoc.Factory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>The main factory method to create service expression, e.g. "new Client(new Service())".
            If <paramref name="request"/> has <see cref="F:DryIoc.Request.FuncArgs"/> specified, they could be used in expression.</summary>
            <param name="request">Service request.</param>
            <returns>Created expression.</returns>
        </member>
        <member name="M:DryIoc.Factory.GetExpressionOrDefault(DryIoc.Request,System.Type)">
            <summary>Returns service expression: either by creating it with <see cref="M:DryIoc.Factory.CreateExpressionOrDefault(DryIoc.Request)"/> or taking expression from cache.
            Before returning method may transform the expression  by applying <see cref="F:DryIoc.Factory.Reuse"/>, or/and decorators if found any.
            If <paramref name="reuseWrapperType"/> specified: result expression may be of required wrapper type.</summary>
            <param name="request">Request for service.</param>
            <param name="reuseWrapperType">(optional) Reuse wrapper type of expression to return.</param>
            <returns>Service expression.</returns>
        </member>
        <member name="M:DryIoc.Factory.ThrowIfReuseHasShorterLifespanThanParent(DryIoc.IReuse,DryIoc.Request)">
            <summary>Check method name for explanation XD.</summary> <param name="reuse">Reuse to check.</param> <param name="request">Request to resolve.</param>
        </member>
        <member name="M:DryIoc.Factory.GetDelegateOrDefault(DryIoc.Request)">
            <summary>Creates factory delegate from service expression and returns it. By default uses <see cref="T:DryIoc.FactoryCompiler"/>
            to compile delegate from expression but could be overridden by concrete factory type: e.g. <see cref="T:DryIoc.DelegateFactory"/></summary>
            <param name="request">Service request.</param>
            <returns>Factory delegate created from service expression.</returns>
        </member>
        <member name="M:DryIoc.Factory.ToString">
            <summary>Returns nice string representation of factory.</summary>
            <returns>String representation.</returns>
        </member>
        <member name="P:DryIoc.Factory.FactoryID">
            <summary>Unique factory id generated from static seed.</summary>
        </member>
        <member name="P:DryIoc.Factory.Setup">
            <summary>Setup may contain different/non-default factory settings.</summary>
        </member>
        <member name="P:DryIoc.Factory.FactoryType">
            <summary>Shortcut for <see cref="P:DryIoc.Setup.FactoryType"/>.</summary>
        </member>
        <member name="P:DryIoc.Factory.ImplementationType">
            <summary>Non-abstract closed implementation type. May be null if not known beforehand, e.g. in <see cref="T:DryIoc.DelegateFactory"/>.</summary>
        </member>
        <member name="P:DryIoc.Factory.Provider">
            <summary>Indicates that Factory is factory provider and 
            consumer should call <see cref="M:DryIoc.IConcreteFactoryProvider.ProvideConcreteFactory(DryIoc.Request)"/>  to get concrete factory.</summary>
        </member>
        <member name="T:DryIoc.FactoryMethodSelector">
            <summary>Declares delegate to get single factory method or constructor for resolved request.</summary>
            <param name="request">Request to resolve.</param>
            <returns>Factory method wrapper over constructor or method.</returns>
        </member>
        <member name="T:DryIoc.ParameterSelector">
            <summary>Specifies how to get parameter info for injected parameter and resolved request</summary>
            <remarks>Request is for parameter method owner not for parameter itself.</remarks>
            <param name="request">Request for parameter method/constructor owner.</param>
            <returns>Service info describing how to inject parameter.</returns>
        </member>
        <member name="T:DryIoc.PropertiesAndFieldsSelector">
            <summary>Specifies what properties or fields to inject and how.</summary>
            <param name="request">Request for property/field owner.</param>
            <returns>Corresponding service info for each property/field to be injected.</returns>
        </member>
        <member name="T:DryIoc.Parameters">
            <summary>DSL for specifying <see cref="T:DryIoc.ParameterSelector"/> injection rules.</summary>
        </member>
        <member name="F:DryIoc.Parameters.Of">
            <summary>Specifies to return default details <see cref="F:DryIoc.ServiceDetails.Default"/> for all parameters.</summary>
        </member>
        <member name="M:DryIoc.Parameters.And(DryIoc.ParameterSelector,DryIoc.ParameterSelector)">
            <summary>Combines source selector with other. Other will override the source.</summary>
            <param name="source">Source selector.</param> <param name="other">Specific other selector to add.</param>
            <returns>Combined result selector.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Details(DryIoc.ParameterSelector,System.Func{DryIoc.Request,System.Reflection.ParameterInfo,DryIoc.ServiceDetails})">
            <summary>Overrides source parameter rules with specific parameter details. If it is not your parameter just return null.</summary>
            <param name="source">Original parameters rules</param> 
            <param name="getDetailsOrNull">Should return specific details or null.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Name(DryIoc.ParameterSelector,System.String,System.Type,System.Object,DryIoc.IfUnresolved,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for parameter identified by <paramref name="name"/>.</summary>
            <param name="source">Original parameters rules.</param> <param name="name">Name to identify parameter.</param>
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default throws exception if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Name(DryIoc.ParameterSelector,System.String,System.Func{DryIoc.Request,System.Object})">
            <summary>Specify parameter by name and set custom value to it.</summary>
            <param name="source">Original parameters rules.</param> <param name="name">Parameter name.</param>
            <param name="getCustomValue">Custom value provider.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Type``1(DryIoc.ParameterSelector,System.Type,System.Object,DryIoc.IfUnresolved,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for parameter identified by type <typeparamref name="T"/>.</summary>
            <typeparam name="T">Type of parameter.</typeparam> <param name="source">Source selector.</param> 
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default throws exception if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <returns>Combined selector.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Type``1(DryIoc.ParameterSelector,System.Func{DryIoc.Request,System.Object})">
            <summary>Specify parameter by type and set custom value to it.</summary>
            <typeparam name="T">Parameter type.</typeparam>
            <param name="source">Original parameters rules.</param> 
            <param name="getCustomValue">Custom value provider.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="T:DryIoc.PropertiesAndFields">
            <summary>DSL for specifying <see cref="T:DryIoc.PropertiesAndFieldsSelector"/> injection rules.</summary>
        </member>
        <member name="F:DryIoc.PropertiesAndFields.Of">
            <summary>Say to not resolve any properties or fields.</summary>
        </member>
        <member name="F:DryIoc.PropertiesAndFields.Auto">
            <summary>Public assignable instance members of any type except object, string, primitives types, and arrays of those.</summary>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.All(System.Boolean,System.Boolean,System.Boolean,DryIoc.IfUnresolved,DryIoc.PropertiesAndFields.GetInfo)">
            <summary>Generates selector property and field selector with settings specified by parameters.
            If all parameters are omitted the return all public not primitive members.</summary>
            <param name="withNonPublic">(optional) Specifies to include non public members. Will include by default.</param>
            <param name="withPrimitive">(optional) Specifies to include members of primitive types. Will include by default.</param>
            <param name="withFields">(optional) Specifies to include fields as well as properties. Will include by default.</param>
            <param name="ifUnresolved">(optional) Defines ifUnresolved behavior for resolved members.</param>
            <param name="withInfo">(optional) Return service info for a member or null to skip member resolution.</param>
            <returns>Result selector composed using provided settings.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.And(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Combines source properties and fields with other. Other will override the source condition.</summary>
            <param name="source">Source selector.</param> <param name="other">Specific other selector to add.</param>
            <returns>Combined result selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Details(DryIoc.PropertiesAndFieldsSelector,System.String,System.Func{DryIoc.Request,DryIoc.ServiceDetails})">
            <summary>Specifies service details (key, if-unresolved policy, required type) for property/field with the name.</summary>
            <param name="source">Original member selector.</param> <param name="name">Member name.</param> <param name="getDetails">Details.</param>
            <returns>New selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Name(DryIoc.PropertiesAndFieldsSelector,System.String,System.Type,System.Object,DryIoc.IfUnresolved,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for property/field identified by <paramref name="name"/>.</summary>
            <param name="source">Source selector.</param> <param name="name">Name to identify member.</param>
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default returns default value if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <returns>Combined selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Name(DryIoc.PropertiesAndFieldsSelector,System.String,System.Func{DryIoc.Request,System.Object})">
            <summary>Specifies custom value for property/field with specific name.</summary>
            <param name="source">Original property/field list.</param>
            <param name="name">Target member name.</param> <param name="getCustomValue">Custom value provider.</param>
            <returns>Return new combined selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Match(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <summary>Returns true if property matches flags provided.</summary>
            <param name="property">Property to match</param>
            <param name="withNonPublic">Says to include non public properties.</param>
            <param name="withPrimitive">Says to include properties of primitive type.</param>
            <returns>True if property is matched and false otherwise.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Match(System.Reflection.FieldInfo,System.Boolean,System.Boolean)">
            <summary>Returns true if field matches flags provided.</summary>
            <param name="field">Field to match.</param>
            <param name="withNonPublic">Says to include non public fields.</param>
            <param name="withPrimitive">Says to include fields of primitive type.</param>
            <returns>True if property is matched and false otherwise.</returns>
        </member>
        <member name="T:DryIoc.PropertiesAndFields.GetInfo">
            <summary>Should return service info for input member (property or field).</summary>
            <param name="member">Input member.</param> <param name="request">Request to provide context.</param> <returns>Service info.</returns>
        </member>
        <member name="T:DryIoc.ReflectionFactory">
            <summary>Reflects on <see cref="P:DryIoc.ReflectionFactory.ImplementationType"/> constructor parameters and members,
            creates expression for each reflected dependency, and composes result service expression.</summary>
        </member>
        <member name="F:DryIoc.ReflectionFactory.Made">
            <summary>Injection rules set for Constructor, Parameters, Properties and Fields.</summary>
        </member>
        <member name="M:DryIoc.ReflectionFactory.#ctor(System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup)">
            <summary>Creates factory providing implementation type, optional reuse and setup.</summary>
            <param name="implementationType">(optional) Optional if Made.FactoryMethod is present Non-abstract close or open generic type.</param>
            <param name="reuse">(optional)</param> <param name="made">(optional)</param> <param name="setup">(optional)</param>
        </member>
        <member name="M:DryIoc.ReflectionFactory.ThrowIfInvalidRegistration(DryIoc.IContainer,System.Type,System.Object,System.Boolean)">
            <summary>Before registering factory checks that ImplementationType is assignable, Or
            in case of open generics, compatible with <paramref name="serviceType"/>. 
            Then checks that there is defined constructor selector for implementation type with multiple/no constructors.</summary>
            <param name="container">Container to register factory in.</param>
            <param name="serviceType">Service type to register factory with.</param>
            <param name="serviceKey">(ignored)</param>
            <param name="isStaticallyChecked">Skips service type check. Means that service and implementation are statically checked.</param>
        </member>
        <member name="M:DryIoc.ReflectionFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>Creates service expression, so for registered implementation type "Service", 
            you will get "new Service()". If there is <see cref="T:DryIoc.Reuse"/> specified, then expression will
            contain call to <see cref="T:DryIoc.Scope"/> returned by reuse.</summary>
            <param name="request">Request for service to resolve.</param> <returns>Created expression.</returns>
        </member>
        <member name="P:DryIoc.ReflectionFactory.ImplementationType">
            <summary>Non-abstract service implementation type. May be open generic.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.Provider">
            <summary>Provides closed-generic factory for registered open-generic variant.</summary>
        </member>
        <member name="T:DryIoc.ExpressionFactory">
            <summary>Creates service expression using client provided expression factory delegate.</summary>
        </member>
        <member name="M:DryIoc.ExpressionFactory.#ctor(System.Func{DryIoc.Request,System.Linq.Expressions.Expression},DryIoc.IReuse,DryIoc.Setup)">
            <summary>Wraps provided delegate into factory.</summary>
            <param name="getServiceExpression">Delegate that will be used internally to create service expression.</param>
            <param name="reuse">(optional) Reuse.</param> <param name="setup">(optional) Setup.</param>
        </member>
        <member name="M:DryIoc.ExpressionFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>Creates service expression using wrapped delegate.</summary>
            <param name="request">Request to resolve.</param> <returns>Expression returned by stored delegate.</returns>
        </member>
        <member name="T:DryIoc.DelegateFactory">
            <summary>This factory is the thin wrapper for user provided delegate 
            and where possible it uses delegate directly: without converting it to expression.</summary>
        </member>
        <member name="M:DryIoc.DelegateFactory.#ctor(System.Func{DryIoc.IResolver,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Type)">
            <summary>Creates factory by providing:</summary>
            <param name="factoryDelegate">User specified service creation delegate.</param>
            <param name="reuse">(optional) Reuse behavior for created service.</param>
            <param name="setup">(optional) Additional settings.</param>
            <param name="knownImplementationType">(optional) Implementation type if known, e.g. when registering existing instance.</param>
        </member>
        <member name="M:DryIoc.DelegateFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>Create expression by wrapping call to stored delegate with provided request.</summary>
            <param name="request">Request to resolve. It will be stored in resolution state to be passed to delegate on actual resolve.</param>
            <returns>Created delegate call expression.</returns>
        </member>
        <member name="M:DryIoc.DelegateFactory.GetDelegateOrDefault(DryIoc.Request)">
            <summary>If possible returns delegate directly, without creating expression trees, just wrapped in <see cref="T:DryIoc.FactoryDelegate"/>.
            If decorator found for request then factory fall-backs to expression creation.</summary>
            <param name="request">Request to resolve.</param> 
            <returns>Factory delegate directly calling wrapped delegate, or invoking expression if decorated.</returns>
        </member>
        <member name="P:DryIoc.DelegateFactory.ImplementationType">
            <summary>Non-abstract closed implementation type.</summary>
        </member>
        <member name="T:DryIoc.CreateScopedValue">
            <summary>Should return value stored in scope.</summary>
        </member>
        <member name="T:DryIoc.IScope">
            <summary>Lazy object storage that will create object with provided factory on first access, 
            then will be returning the same object for subsequent access.</summary>
        </member>
        <member name="M:DryIoc.IScope.GetOrAdd(System.Int32,DryIoc.CreateScopedValue)">
            <summary>Creates, stores, and returns stored object.</summary>
            <param name="id">Unique ID to find created object in subsequent calls.</param>
            <param name="createValue">Delegate to create object. It will be used immediately, and reference to delegate will not be stored.</param>
            <returns>Created and stored object.</returns>
            <remarks>Scope does not store <paramref name="createValue"/> (no memory leak here), 
            it stores only result of <paramref name="createValue"/> call.</remarks>
        </member>
        <member name="M:DryIoc.IScope.SetOrAdd(System.Int32,System.Object)">
            <summary>Sets (replaces) value at specified id, or adds value if no existing id found.</summary>
            <param name="id">To set value at.</param> <param name="item">Value to set.</param>
        </member>
        <member name="P:DryIoc.IScope.Parent">
            <summary>Parent scope in scope stack. Null for root scope.</summary>
        </member>
        <member name="P:DryIoc.IScope.Name">
            <summary>Optional name object associated with scope.</summary>
        </member>
        <member name="T:DryIoc.Scope">
            <summary>Scope implementation which will dispose stored <see cref="T:System.IDisposable"/> items on its own dispose.
            Locking is used internally to ensure that object factory called only once.</summary>
        </member>
        <member name="M:DryIoc.Scope.#ctor(DryIoc.IScope,System.Object)">
            <summary>Create scope with optional parent and name.</summary>
            <param name="parent">Parent in scope stack.</param> <param name="name">Associated name object.</param>
        </member>
        <member name="M:DryIoc.Scope.GetOrAdd(System.Int32,DryIoc.CreateScopedValue)">
            <summary><see cref="M:DryIoc.IScope.GetOrAdd(System.Int32,DryIoc.CreateScopedValue)"/> for description.
            Will throw <see cref="T:DryIoc.ContainerException"/> if scope is disposed.</summary>
            <param name="id">Unique ID to find created object in subsequent calls.</param>
            <param name="createValue">Delegate to create object. It will be used immediately, and reference to delegate will Not be stored.</param>
            <returns>Created and stored object.</returns>
            <exception cref="T:DryIoc.ContainerException">if scope is disposed.</exception>
        </member>
        <member name="M:DryIoc.Scope.SetOrAdd(System.Int32,System.Object)">
            <summary>Sets (replaces) value at specified id, or adds value if no existing id found.</summary>
            <param name="id">To set value at.</param> <param name="item">Value to set.</param>
        </member>
        <member name="M:DryIoc.Scope.Dispose">
            <summary>Disposes all stored <see cref="T:System.IDisposable"/> objects and nullifies object storage.</summary>
            <remarks>If item disposal throws exception, then it won't be propagated outside, so the rest of the items could be disposed.</remarks>
        </member>
        <member name="M:DryIoc.Scope.ToString">
            <summary>Prints scope info (name and parent) to string for debug purposes.</summary> <returns>String representation.</returns>
        </member>
        <member name="P:DryIoc.Scope.Parent">
            <summary>Parent scope in scope stack. Null for root scope.</summary>
        </member>
        <member name="P:DryIoc.Scope.Name">
            <summary>Optional name object associated with scope.</summary>
        </member>
        <member name="P:DryIoc.Scope.IsDisposed">
            <summary>Returns true if scope disposed.</summary>
        </member>
        <member name="T:DryIoc.SingletonScope">
            <summary>Scope implementation which will dispose stored <see cref="T:System.IDisposable"/> items on its own dispose.
            Locking is used internally to ensure that object factory called only once.</summary>
        </member>
        <member name="M:DryIoc.SingletonScope.#ctor">
            <summary>Creates scope.</summary>
        </member>
        <member name="M:DryIoc.SingletonScope.ReserveItemIndex(System.Int32)">
            <summary>Adds mapping between id and index on resolution.</summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:DryIoc.SingletonScope.GetOrAdd(System.Int32,DryIoc.CreateScopedValue)">
            <summary><see cref="M:DryIoc.IScope.GetOrAdd(System.Int32,DryIoc.CreateScopedValue)"/> for description.
            Will throw <see cref="T:DryIoc.ContainerException"/> if scope is disposed.</summary>
            <param name="id">Unique ID to find created object in subsequent calls.</param>
            <param name="createValue">Delegate to create object. It will be used immediately, and reference to delegate will Not be stored.</param>
            <returns>Created and stored object.</returns>
            <exception cref="T:DryIoc.ContainerException">if scope is disposed.</exception>
        </member>
        <member name="M:DryIoc.SingletonScope.SetOrAdd(System.Int32,System.Object)">
            <summary>Sets (replaces) value at specified id, or adds value if no existing id found.</summary>
            <param name="id">To set value at.</param> <param name="item">Value to set.</param>
        </member>
        <member name="M:DryIoc.SingletonScope.Dispose">
            <summary>Disposes all stored <see cref="T:System.IDisposable"/> objects and nullifies object storage.</summary>
            <remarks>If item disposal throws exception, then it won't be propagated outside, so the rest of the items could be disposed.</remarks>
        </member>
        <member name="M:DryIoc.SingletonScope.ToString">
            <summary>Prints scope info (name and parent) to string for debug purposes.</summary> <returns>String representation.</returns>
        </member>
        <member name="P:DryIoc.SingletonScope.Parent">
            <summary>Parent scope in scope stack. Null for root scope.</summary>
        </member>
        <member name="P:DryIoc.SingletonScope.Name">
            <summary>Optional name object associated with scope.</summary>
        </member>
        <member name="P:DryIoc.SingletonScope.IsDisposed">
            <summary>Returns true if scope disposed.</summary>
        </member>
        <member name="T:DryIoc.SetCurrentScopeHandler">
            <summary>Delegate to get new scope from old/existing current scope.</summary>
            <param name="oldScope">Old/existing scope to change.</param>
            <returns>New scope or old if do not want to change current scope.</returns>
        </member>
        <member name="T:DryIoc.IScopeContext">
            <summary>Provides ambient current scope and optionally scope storage for container, 
            examples are HttpContext storage, Execution context, Thread local.</summary>
        </member>
        <member name="M:DryIoc.IScopeContext.GetCurrentOrDefault">
            <summary>Returns current scope or null if no ambient scope available at the moment.</summary>
            <returns>Current scope or null.</returns>
        </member>
        <member name="M:DryIoc.IScopeContext.SetCurrent(DryIoc.SetCurrentScopeHandler)">
            <summary>Changes current scope using provided delegate. Delegate receives current scope as input and
            should return new current scope.</summary>
            <param name="setCurrentScope">Delegate to change the scope.</param>
            <remarks>Important: <paramref name="setCurrentScope"/> may be called multiple times in concurrent environment.
            Make it predictable by removing any side effects.</remarks>
            <returns>New current scope. So it is convenient to use method in "using (var newScope = ctx.SetCurrent(...))".</returns>
        </member>
        <member name="P:DryIoc.IScopeContext.RootScopeName">
            <summary>Name associated with context root scope - so the reuse may find scope context.</summary>
        </member>
        <member name="T:DryIoc.ThreadScopeContext">
            <summary>Tracks one current scope per thread, so the current scope in different tread would be different or null,
            if not yet tracked. Context actually stores scope references internally, so it should be disposed to free them.</summary>
        </member>
        <member name="F:DryIoc.ThreadScopeContext.ScopeContextName">
            <summary>Provides static access to <see cref="P:DryIoc.ThreadScopeContext.RootScopeName"/>. It is OK because its constant.</summary>
        </member>
        <member name="M:DryIoc.ThreadScopeContext.GetCurrentOrDefault">
            <summary>Returns current scope in calling Thread or null, if no scope tracked.</summary>
            <returns>Found scope or null.</returns>
        </member>
        <member name="M:DryIoc.ThreadScopeContext.SetCurrent(DryIoc.SetCurrentScopeHandler)">
            <summary>Change current scope for the calling Thread.</summary>
            <param name="setCurrentScope">Delegate to change the scope given current one (or null).</param>
            <remarks>Important: <paramref name="setCurrentScope"/> may be called multiple times in concurrent environment.
            Make it predictable by removing any side effects.</remarks>
        </member>
        <member name="M:DryIoc.ThreadScopeContext.Dispose">
            <summary>Disposed all stored/tracked scopes and empties internal scope storage.</summary>
        </member>
        <member name="P:DryIoc.ThreadScopeContext.RootScopeName">
            <summary>Key to identify context.</summary>
        </member>
        <member name="T:DryIoc.IReuse">
            <summary>Reuse goal is to locate or create scope where reused objects will be stored.</summary>
            <remarks><see cref="T:DryIoc.IReuse"/> implementors supposed to be stateless, and provide scope location behavior only.
            The reused service instances should be stored in scope(s).</remarks>
        </member>
        <member name="M:DryIoc.IReuse.GetScopeOrDefault(DryIoc.Request)">
            <summary>Locates or creates scope to store reused service objects.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Located scope.</returns>
        </member>
        <member name="M:DryIoc.IReuse.GetScopeExpression(DryIoc.Request)">
            <summary>Supposed to create in-line expression with the same code as body of <see cref="M:DryIoc.IReuse.GetScopeOrDefault(DryIoc.Request)"/> method.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Expression of type <see cref="T:DryIoc.IScope"/>.</returns>
            <remarks>Result expression should be static: should Not create closure on any objects. 
            If you require to reference some item from outside, put it into <see cref="P:DryIoc.IContainer.ResolutionStateCache"/>.</remarks>
        </member>
        <member name="P:DryIoc.IReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="T:DryIoc.SingletonReuse">
            <summary>Returns container bound scope for storing singleton objects.</summary>
        </member>
        <member name="M:DryIoc.SingletonReuse.GetScopeOrDefault(DryIoc.Request)">
            <summary>Returns container bound Singleton scope.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Container singleton scope.</returns>
        </member>
        <member name="M:DryIoc.SingletonReuse.GetScopeExpression(DryIoc.Request)">
            <summary>Returns expression directly accessing <see cref="P:DryIoc.IScopeAccess.SingletonScope"/>.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Singleton scope property expression.</returns>
        </member>
        <member name="M:DryIoc.SingletonReuse.ToString">
            <summary>Pretty print reuse name and lifespan</summary> <returns>Printed string.</returns>
        </member>
        <member name="P:DryIoc.SingletonReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="T:DryIoc.CurrentScopeReuse">
            <summary>Returns container bound current scope created by <see cref="M:DryIoc.Container.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})"/> method.</summary>
            <remarks>It is the same as Singleton scope if container was not created by <see cref="M:DryIoc.Container.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})"/>.</remarks>
        </member>
        <member name="F:DryIoc.CurrentScopeReuse.Name">
            <summary>Name to find current scope or parent with equal name.</summary>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.#ctor(System.Object)">
            <summary>Creates reuse optionally specifying its name.</summary> 
            <param name="name">(optional) Used to find matching current scope or parent.</param>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetScopeOrDefault(DryIoc.Request)">
            <summary>Returns container current scope or if <see cref="F:DryIoc.CurrentScopeReuse.Name"/> specified: current scope or its parent with corresponding name.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Found current scope or its parent.</returns>
            <exception cref="T:DryIoc.ContainerException">with the code <see cref="F:DryIoc.Error.NoMatchedScopeFound"/> if <see cref="F:DryIoc.CurrentScopeReuse.Name"/> specified but
            no matching scope or its parent found.</exception>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetScopeExpression(DryIoc.Request)">
            <summary>Returns <see cref="M:DryIoc.IScopeAccess.GetCurrentNamedScope(System.Object,System.Boolean)"/> method call expression.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Method call expression returning matched current scope.</returns>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.ToString">
            <summary>Pretty prints reuse to string.</summary> <returns>Reuse string.</returns>
        </member>
        <member name="P:DryIoc.CurrentScopeReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="T:DryIoc.ResolutionScopeReuse">
            <summary>Represents services created once per resolution root (when some of Resolve methods called).</summary>
            <remarks>Scope is created only if accessed to not waste memory.</remarks>
        </member>
        <member name="M:DryIoc.ResolutionScopeReuse.#ctor(System.Type,System.Object,System.Boolean)">
            <summary>Creates new resolution scope reuse with specified type and key.</summary>
            <param name="assignableFromServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="outermost">(optional)</param>
        </member>
        <member name="M:DryIoc.ResolutionScopeReuse.GetScopeOrDefault(DryIoc.Request)">
            <summary>Creates or returns already created resolution root scope.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Created or existing scope.</returns>
        </member>
        <member name="M:DryIoc.ResolutionScopeReuse.GetScopeExpression(DryIoc.Request)">
            <summary>Returns <see cref="M:DryIoc.IScopeAccess.GetMatchingResolutionScope(DryIoc.IScope,System.Type,System.Object,System.Boolean,System.Boolean)"/> method call expression.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Method call expression returning existing or newly created resolution scope.</returns>
        </member>
        <member name="M:DryIoc.ResolutionScopeReuse.ToString">
            <summary>Pretty print reuse name and lifespan</summary> <returns>Printed string.</returns>
        </member>
        <member name="P:DryIoc.ResolutionScopeReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="T:DryIoc.Reuse">
            <summary>Specifies pre-defined reuse behaviors supported by container: 
            used when registering services into container with <see cref="T:DryIoc.Registrator"/> methods.</summary>
        </member>
        <member name="F:DryIoc.Reuse.Transient">
            <summary>Synonym for absence of reuse.</summary>
        </member>
        <member name="F:DryIoc.Reuse.Singleton">
            <summary>Specifies to store single service instance per <see cref="T:DryIoc.Container"/>.</summary>
        </member>
        <member name="F:DryIoc.Reuse.InResolutionScope">
            <summary>Specifies to store single service instance per resolution root created by <see cref="T:DryIoc.Resolver"/> methods.</summary>
        </member>
        <member name="F:DryIoc.Reuse.InCurrentScope">
            <summary>Specifies to store single service instance per current/open scope created with <see cref="M:DryIoc.Container.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})"/>.</summary>
        </member>
        <member name="M:DryIoc.Reuse.InCurrentNamedScope(System.Object)">
            <summary>Returns current scope reuse with specific name to match with scope.
            If name is not specified then function returns <see cref="F:DryIoc.Reuse.InCurrentScope"/>.</summary>
            <param name="name">(optional) Name to match with scope.</param>
            <returns>Created current scope reuse.</returns>
        </member>
        <member name="M:DryIoc.Reuse.InResolutionScopeOf(System.Type,System.Object,System.Boolean)">
            <summary>Creates reuse to search for <paramref name="assignableFromServiceType"/> and <paramref name="serviceKey"/>
            in existing resolution scope hierarchy. If parameters are not specified or null, then <see cref="F:DryIoc.Reuse.InResolutionScope"/> will be returned.</summary>
            <param name="assignableFromServiceType">(optional) To search for scope with service type assignable to type specified in parameter.</param>
            <param name="serviceKey">(optional) Search for specified key.</param>
            <param name="outermost">If true - commands to look for outermost match instead of nearest.</param>
            <returns>New reuse with specified parameters or <see cref="F:DryIoc.Reuse.InResolutionScope"/> if nothing specified.</returns>
        </member>
        <member name="M:DryIoc.Reuse.InResolutionScopeOf``1(System.Object,System.Boolean)">
            <summary>Creates reuse to search for <typeparamref name="TAssignableFromServiceType"/> and <paramref name="serviceKey"/>
            in existing resolution scope hierarchy.</summary>
            <typeparam name="TAssignableFromServiceType">To search for scope with service type assignable to type specified in parameter.</typeparam>
            <param name="serviceKey">(optional) Search for specified key.</param>
            <param name="outermost">If true - commands to look for outermost match instead of nearest.</param>
            <returns>New reuse with specified parameters.</returns>
        </member>
        <member name="F:DryIoc.Reuse.InThread">
            <summary>Ensuring single service instance per Thread.</summary>
        </member>
        <member name="F:DryIoc.Reuse.WebRequestScopeName">
            <summary>Special name that by convention recognized by <see cref="F:DryIoc.Reuse.InWebRequest"/>.</summary>
        </member>
        <member name="F:DryIoc.Reuse.InWebRequest">
            <summary>Web request is just convention for reuse in <see cref="M:DryIoc.Reuse.InCurrentNamedScope(System.Object)"/> with special name <see cref="F:DryIoc.Reuse.WebRequestScopeName"/>.</summary>
        </member>
        <member name="T:DryIoc.IReuseWrapperFactory">
            <summary>Creates <see cref="T:DryIoc.IReuseWrapper"/> for target and unwraps matching wrapper.</summary>
        </member>
        <member name="M:DryIoc.IReuseWrapperFactory.Wrap(System.Object)">
            <summary>Wraps target value into new wrapper.</summary>
            <param name="target">Input value. May be other wrapper.</param> <returns>New wrapper.</returns>
        </member>
        <member name="M:DryIoc.IReuseWrapperFactory.Unwrap(System.Object)">
            <summary>Unwraps wrapper of supported/matched wrapper type. Otherwise throws.</summary>
            <param name="wrapper">Wrapper to unwrap.</param> <returns>Unwrapped value. May be nested wrapper.</returns>
        </member>
        <member name="T:DryIoc.ReuseWrapperFactory">
            <summary>Listing and implementations of out-of-the-box supported <see cref="T:DryIoc.IReuseWrapper"/> factories.</summary>
        </member>
        <member name="F:DryIoc.ReuseWrapperFactory.HiddenDisposable">
            <summary>Factory for <see cref="T:DryIoc.ReuseHiddenDisposable"/>.</summary>
        </member>
        <member name="F:DryIoc.ReuseWrapperFactory.WeakReference">
            <summary>Factory for <see cref="T:DryIoc.ReuseWeakReference"/>.</summary>
        </member>
        <member name="F:DryIoc.ReuseWrapperFactory.Swapable">
            <summary>Factory for <see cref="T:DryIoc.ReuseSwapable"/>.</summary>
        </member>
        <member name="F:DryIoc.ReuseWrapperFactory.Recyclable">
            <summary>Factory for <see cref="T:DryIoc.ReuseRecyclable"/>.</summary>
        </member>
        <member name="T:DryIoc.IReuseWrapper">
            <summary>Defines reused object wrapper.</summary>
        </member>
        <member name="P:DryIoc.IReuseWrapper.Target">
            <summary>Wrapped value.</summary>
        </member>
        <member name="T:DryIoc.ReuseWrapper">
            <summary>Provides strongly-typed access to wrapped target.</summary>
        </member>
        <member name="F:DryIoc.ReuseWrapper.HiddenDisposable">
            <summary>Type of <see cref="T:DryIoc.ReuseHiddenDisposable"/> added for intellisense discoverability.</summary>
        </member>
        <member name="F:DryIoc.ReuseWrapper.WeakReference">
            <summary>Type of <see cref="T:DryIoc.ReuseWeakReference"/> added for intellisense discoverability.</summary>
        </member>
        <member name="F:DryIoc.ReuseWrapper.Recyclable">
            <summary>Type of <see cref="T:DryIoc.ReuseRecyclable"/> added for intellisense discoverability.</summary>
        </member>
        <member name="F:DryIoc.ReuseWrapper.Swapable">
            <summary>Type of <see cref="T:DryIoc.ReuseSwapable"/> added for intellisense discoverability.</summary>
        </member>
        <member name="M:DryIoc.ReuseWrapper.TargetOrDefault``1(DryIoc.IReuseWrapper)">
            <summary>Unwraps input until target of <typeparamref name="T"/> is found. Returns found target, otherwise returns null.</summary>
            <typeparam name="T">Target to stop search on.</typeparam>
            <param name="reuseWrapper">Source reused wrapper to get target from.</param>
        </member>
        <member name="T:DryIoc.IHideDisposableFromContainer">
            <summary>Marker interface used by Scope to skip dispose for reused disposable object.</summary>
        </member>
        <member name="T:DryIoc.ReuseHiddenDisposable">
            <summary>Wraps reused service object to prevent container to dispose service object. Intended to work only with <see cref="T:System.IDisposable"/> target.</summary>
        </member>
        <member name="M:DryIoc.ReuseHiddenDisposable.#ctor(System.IDisposable)">
            <summary>Constructs wrapper by wrapping input target.</summary>
            <param name="target">Disposable target.</param>
        </member>
        <member name="M:DryIoc.ReuseHiddenDisposable.Dispose">
            <summary>Dispose target and mark wrapper as disposed.</summary>
        </member>
        <member name="P:DryIoc.ReuseHiddenDisposable.Target">
            <summary>Wrapped value.</summary>
        </member>
        <member name="P:DryIoc.ReuseHiddenDisposable.IsDisposed">
            <summary>True if target was disposed.</summary>
        </member>
        <member name="T:DryIoc.ReuseWeakReference">
            <summary>Wraps reused object as <see cref="T:System.WeakReference"/>. Allow wrapped object to be garbage collected.</summary>
        </member>
        <member name="F:DryIoc.ReuseWeakReference.Ref">
            <summary>Provides access to <see cref="T:System.WeakReference"/> members.</summary>
        </member>
        <member name="M:DryIoc.ReuseWeakReference.#ctor(System.Object)">
            <summary>Wraps input target into weak reference</summary> <param name="value">Value to wrap.</param>
        </member>
        <member name="P:DryIoc.ReuseWeakReference.Target">
            <summary>Wrapped value, delegates to <see cref="P:System.WeakReference.Target"/></summary>
        </member>
        <member name="T:DryIoc.ReuseSwapable">
            <summary>Wraps reused value ref box with ability to Swap it new value. Similar to <see cref="T:DryIoc.Ref`1"/>.</summary>
        </member>
        <member name="M:DryIoc.ReuseSwapable.#ctor(System.Object)">
            <summary>Constructs ref wrapper.</summary> <param name="value">Wrapped value.</param>
        </member>
        <member name="M:DryIoc.ReuseSwapable.Swap(System.Func{System.Object,System.Object})">
            <summary>Exchanges currently hold object with <paramref name="getValue"/> result.</summary>
            <param name="getValue">Delegate to produce new object value from current one passed as parameter.</param>
            <returns>Returns old object value the same way as <see cref="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)"/></returns>
            <remarks>Important: <paramref name="getValue"/> delegate may be called multiple times with new value each time, 
            if it was changed in meantime by other concurrently running code.</remarks>
        </member>
        <member name="M:DryIoc.ReuseSwapable.Swap(System.Object)">
            <summary>Simplified version of Swap ignoring old value.</summary> <param name="newValue">New value.</param> <returns>Old value.</returns>
        </member>
        <member name="P:DryIoc.ReuseSwapable.Target">
            <summary>Wrapped value.</summary>
        </member>
        <member name="T:DryIoc.IRecyclable">
            <summary>If recycled set to True, that command Scope to create and return new value on next access.</summary>
        </member>
        <member name="M:DryIoc.IRecyclable.Recycle">
            <summary>Commands to recycle value.</summary>
        </member>
        <member name="P:DryIoc.IRecyclable.IsRecycled">
            <summary>Indicates that value should be recycled.</summary>
        </member>
        <member name="T:DryIoc.ReuseRecyclable">
            <summary>Wraps value with ability to be recycled, so next access to recycle value with create new value from Container.</summary>
        </member>
        <member name="M:DryIoc.ReuseRecyclable.#ctor(System.Object)">
            <summary>Wraps input value</summary> <param name="value"></param>
        </member>
        <member name="M:DryIoc.ReuseRecyclable.Recycle">
            <summary>Commands to recycle value.</summary>
        </member>
        <member name="P:DryIoc.ReuseRecyclable.Target">
            <summary>Returns wrapped value.</summary>
        </member>
        <member name="P:DryIoc.ReuseRecyclable.IsRecycled">
            <summary>Indicates that value should be recycled.</summary>
        </member>
        <member name="T:DryIoc.IfUnresolved">
            <summary>Specifies what to return when <see cref="T:DryIoc.IResolver"/> unable to resolve service.</summary>
        </member>
        <member name="F:DryIoc.IfUnresolved.Throw">
            <summary>Specifies to throw <see cref="T:DryIoc.ContainerException"/> if no service found.</summary>
        </member>
        <member name="F:DryIoc.IfUnresolved.ReturnDefault">
            <summary>Specifies to return default value instead of throwing error.</summary>
        </member>
        <member name="T:DryIoc.IfAlreadyRegistered">
            <summary>Specifies options to handle situation when registering some service already present in the registry.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.AppendNotKeyed">
            <summary>Appends new default registration or throws registration with the same key.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.Throw">
            <summary>Throws if default or registration with the same key is already exist.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.Keep">
            <summary>Keeps old default or keyed registration ignoring new registration: ensures Register-Once semantics.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.Replace">
            <summary>Replaces old registration with new one.</summary>
        </member>
        <member name="T:DryIoc.ServiceRegistrationInfo">
            <summary>Define registered service structure.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.ServiceType">
            <summary>Required service type.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.OptionalServiceKey">
            <summary>Is null single default service, or actual service key, or <see cref="T:DryIoc.DefaultKey"/> for multiple default services.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.Factory">
            <summary>Registered factory.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.FactoryRegistrationOrder">
            <summary>Provides registration order across all factory registrations in container.</summary>
            <remarks>May be repeated for factory registered with multiple services.</remarks>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.#ctor(DryIoc.Factory,System.Type,System.Object)">
            <summary>Creates info. Registration order is figured out automatically based on Factory.</summary>
            <param name="factory"></param> <param name="serviceType"></param> <param name="optionalServiceKey"></param>
        </member>
        <member name="T:DryIoc.LazyEnumerable`1">
            <summary>Resolves all registered services of <typeparamref name="TService"/> type on demand, 
            when enumerator <see cref="M:System.Collections.IEnumerator.MoveNext"/> called. If service type is not found, empty returned.</summary>
            <typeparam name="TService">Service type to resolve.</typeparam>
        </member>
        <member name="F:DryIoc.LazyEnumerable`1.Items">
            <summary>Exposes internal items enumerable.</summary>
        </member>
        <member name="M:DryIoc.LazyEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Wraps lazy resolved items.</summary> <param name="items">Lazy resolved items.</param>
        </member>
        <member name="M:DryIoc.LazyEnumerable`1.GetEnumerator">
            <summary>Return items enumerator.</summary> <returns>items enumerator.</returns>
        </member>
        <member name="T:DryIoc.Meta`2">
            <summary>Wrapper type to box service with associated arbitrary metadata object.</summary>
            <typeparam name="T">Service type.</typeparam>
            <typeparam name="TMetadata">Arbitrary metadata object type.</typeparam>
        </member>
        <member name="F:DryIoc.Meta`2.Value">
            <summary>Value or object with associated metadata.</summary>
        </member>
        <member name="F:DryIoc.Meta`2.Metadata">
            <summary>Associated metadata object. Could be anything.</summary>
        </member>
        <member name="M:DryIoc.Meta`2.#ctor(`0,`1)">
            <summary>Boxes value and its associated metadata together.</summary>
            <param name="value">value</param> <param name="metadata">any metadata object</param>
        </member>
        <member name="T:DryIoc.FactoryExpression`1">
            <summary>Wraps factory expression created by container internally. May be used for debugging.</summary>
            <typeparam name="TService">Service type to resolve.</typeparam>
        </member>
        <member name="F:DryIoc.FactoryExpression`1.Value">
            <summary>Factory expression that Container compiles to delegate.</summary>
        </member>
        <member name="M:DryIoc.FactoryExpression`1.#ctor(System.Linq.Expressions.Expression{DryIoc.FactoryDelegate})">
            <summary>Creates wrapper.</summary> <param name="value">Wrapped expression.</param>
        </member>
        <member name="T:DryIoc.Error">
            <summary>Defines error codes and error messages for all DryIoc exceptions (DryIoc extensions may define their own.)</summary>
        </member>
        <member name="F:DryIoc.Error.FirstErrorCode">
            <summary>First error code to identify error range for other possible error code definitions.</summary>
        </member>
        <member name="F:DryIoc.Error.Messages">
            <summary>List of error messages indexed with code.</summary>
        </member>
        <member name="M:DryIoc.Error.Of(System.String)">
            <summary>Stores new error message and returns error code for it.</summary>
            <param name="message">Error message to store.</param> <returns>Error code for message.</returns>
        </member>
        <member name="T:DryIoc.ErrorCheck">
            <summary>Checked error condition, possible error sources.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.Unspecified">
            <summary>Unspecified, just throw.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.InvalidCondition">
            <summary>Predicate evaluated to false.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.IsNull">
            <summary>Checked object is null.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.IsNotOfType">
            <summary>Checked object is of unexpected type.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.TypeIsNotOfType">
            <summary>Checked type is not assignable to expected type</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.OperationThrows">
            <summary>Invoked operation throw, it is source of inner exception.</summary>
        </member>
        <member name="T:DryIoc.Throw">
            <summary>Enables more clean error message formatting and a bit of code contracts.</summary>
        </member>
        <member name="F:DryIoc.Throw.GetMatchedException">
            <summary>Returns matched exception (to check type and error code). By default return <see cref="T:DryIoc.ContainerException"/>.</summary>
        </member>
        <member name="M:DryIoc.Throw.If(System.Boolean,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws matched exception if throw condition is true.</summary>
            <param name="throwCondition">Condition to be evaluated, throws if result is true, otherwise - does nothing.</param>
            <param name="error">Error code to match to exception thrown.</param>
            <param name="arg0">Arguments to formatted message.</param> <param name="arg1"></param> <param name="arg2"></param> <param name="arg3"></param>
        </member>
        <member name="M:DryIoc.Throw.ThrowIf``1(``0,System.Boolean,System.Int32,System.Object,System.Object,System.Object)">
            <summary>Throws matched exception if throw condition is true. Otherwise return source <paramref name="arg0"/>.</summary>
            <typeparam name="T">Type of source <paramref name="arg0"/>.</typeparam>
            <param name="arg0">In case of exception <paramref name="arg0"/> will be used as first argument in formatted message.</param>
            <param name="throwCondition">Condition to be evaluated, throws if result is true, otherwise - does nothing.</param>
            <param name="error">Error code to match to exception thrown.</param>
            <param name="arg1">Rest of arguments to formatted message.</param> <param name="arg2"></param> <param name="arg3"></param>
            <returns><paramref name="arg0"/> if throw condition is false.</returns>
        </member>
        <member name="M:DryIoc.Throw.ThrowIf``1(``0,System.Func{``0,System.Boolean},System.Int32,System.Object,System.Object,System.Object)">
            <summary>Throws matched exception if throw condition is true. Passes <paramref name="arg0"/> to condition. 
            Enables fluent syntax at cast of delegate creation. Otherwise return source <paramref name="arg0"/>.</summary>
            <typeparam name="T">Type of source <paramref name="arg0"/>.</typeparam>
            <param name="arg0">In case of exception <paramref name="arg0"/> will be used as first argument in formatted message.</param>
            <param name="throwCondition">Condition to be evaluated, throws if result is true, otherwise - does nothing.</param>
            <param name="error">Error code to match to exception thrown.</param>
            <param name="arg1">Rest of arguments to formatted message.</param> <param name="arg2"></param> <param name="arg3"></param>
            <returns><paramref name="arg0"/> if throw condition is false.</returns>
        </member>
        <member name="M:DryIoc.Throw.ThrowIfNull``1(``0,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws exception if <paramref name="arg"/> is null, otherwise returns <paramref name="arg"/>.</summary>
            <param name="arg">Argument to check for null.</param>
            <param name="error">Error code.</param>
            <param name="arg0"></param> <param name="arg1"></param> <param name="arg2"></param> <param name="arg3"></param>
            <typeparam name="T">Type of argument to check and return.</typeparam>
            <returns><paramref name="arg"/> if it is not null.</returns>
        </member>
        <member name="M:DryIoc.Throw.ThrowIfNotOf``1(``0,System.Type,System.Int32,System.Object,System.Object)">
            <summary>Throws exception if <paramref name="arg0"/> is not assignable to type specified by <paramref name="arg1"/>,
            otherwise just returns <paramref name="arg0"/>.</summary>
            <typeparam name="T">Type of argument to check and return if no error.</typeparam>
            <param name="arg0">Instance to check if it is assignable to type <paramref name="arg1"/>.</param>
            <param name="arg1">Type to check <paramref name="arg0"/> against.</param>
            <param name="error">Error code</param>
            <param name="arg2"></param> <param name="arg3"></param>
            <returns><paramref name="arg0"/> if it assignable to <paramref name="arg1"/>.</returns>
        </member>
        <member name="M:DryIoc.Throw.ThrowIfNotImplementedBy(System.Type,System.Type,System.Int32,System.Object,System.Object)">
            <summary>Throws if <paramref name="arg0"/> is not assignable from <paramref name="arg1"/>.</summary>
            <param name="arg0"></param> <param name="arg1"></param> 
            <param name="error">Error code</param>
             <param name="arg2"></param> <param name="arg3"></param>
            <returns><paramref name="arg0"/> if no exception.</returns>
        </member>
        <member name="M:DryIoc.Throw.IfThrows``2(System.Func{``1},System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Invokes <paramref name="operation"/> and in case of <typeparamref name="TEx"/> re-throws it as inner-exception.</summary>
            <typeparam name="TEx">Exception to check and handle, and then wrap as inner-exception.</typeparam>
            <typeparam name="T">Result of <paramref name="operation"/>.</typeparam>
            <param name="operation">To invoke</param> <param name="error">Error code</param>
            <param name="arg0"></param> <param name="arg1"></param> <param name="arg2"></param> <param name="arg3"></param>
            <returns>Result of <paramref name="operation"/> if no exception.</returns>
        </member>
        <member name="M:DryIoc.Throw.It(System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Just throws the exception with the <paramref name="error"/> code.</summary>
            <param name="error">Error code.</param>
            <param name="arg0"></param> <param name="arg1"></param> <param name="arg2"></param> <param name="arg3"></param>
        </member>
        <member name="M:DryIoc.Throw.For``1(System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws <paramref name="error"/> instead of returning value of <typeparamref name="T"/>. 
            Supposed to be used in expression that require some return value.</summary>
            <typeparam name="T"></typeparam> <param name="error"></param>
            <param name="arg0"></param> <param name="arg1"></param> <param name="arg2"></param> <param name="arg3"></param>
            <returns>Does not return, throws instead.</returns>
        </member>
        <member name="T:DryIoc.Throw.GetMatchedExceptionHandler">
            <summary>Declares mapping between <see cref="T:DryIoc.ErrorCheck"/> type and <paramref name="error"/> code to specific <see cref="T:System.Exception"/>.</summary>
            <returns>Returns mapped exception.</returns>
        </member>
        <member name="T:DryIoc.ReflectionTools">
            <summary>Contains helper methods to work with Type: for instance to find Type implemented base types and interfaces, etc.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetImplementedTypes(System.Type,DryIoc.ReflectionTools.IncludeImplementedType)">
            <summary>Returns all interfaces and all base types (in that order) implemented by <paramref name="sourceType"/>.
            Specify <paramref name="includeImplementedType"/> to include <paramref name="sourceType"/> itself as first item and 
            <see cref="T:System.Object"/> type as the last item.</summary>
            <param name="sourceType">Source type for discovery.</param>
            <param name="includeImplementedType">Additional types to include into result collection.</param>
            <returns>Array of found types, empty if nothing found.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetImplementedInterfaces(System.Type)">
            <summary>Gets a collection of the interfaces implemented by the current type and its base types.</summary>
            <param name="type">Source type</param>
            <returns>Collection of interface types.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.ContainsAllGenericTypeParameters(System.Type,System.Type[])">
            <summary>Returns true if <paramref name="type"/> contains all generic parameters from <paramref name="genericParams"/>.</summary>
            <param name="type">Expected to be open-generic type.</param>
            <param name="genericParams">Generic parameters.</param>
            <returns>Returns true if contains and false otherwise.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsCompilerGenerated(System.Type)">
            <summary>Returns true if class is compiler generated. Checking for CompilerGeneratedAttribute
            is not enough, because this attribute is not applied for classes generated from "async/await".</summary>
            <param name="type">Type to check.</param> <returns>Returns true if type is compiler generated.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsGeneric(System.Type)">
            <summary>Returns true if type is generic.</summary><param name="type">Type to check.</param> <returns>True if type generic.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsGenericDefinition(System.Type)">
            <summary>Returns true if type is generic type definition (open type).</summary><param name="type">Type to check.</param>
            <returns>True if type is open type: generic type definition.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsClosedGeneric(System.Type)">
            <summary>Returns true if type is closed generic: does not have open generic parameters, only closed/concrete ones.</summary>
            <param name="type">Type to check</param> <returns>True if closed generic.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsOpenGeneric(System.Type)">
            <summary>Returns true if type if open generic: contains at list one open generic parameter. Could be
            generic type definition as well.</summary>
            <param name="type">Type to check.</param> <returns>True if open generic.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetGenericDefinitionOrNull(System.Type)">
            <summary>Returns generic type definition if type is generic and null otherwise.</summary>
            <param name="type">Source type, could be null.</param> <returns>Generic type definition.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetGenericParamsAndArgs(System.Type)">
            <summary>Returns generic type parameters and arguments in order they specified. If type is not generic, returns empty array.</summary>
            <param name="type">Source type.</param> <returns>Array of generic type arguments (closed/concrete types) and parameters (open).</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetGenericParamConstraints(System.Type)">
            <summary>Returns array of interface and base class constraints for provider generic parameter type.</summary>
            <param name="type">Generic parameter type.</param>
            <returns>Array of interface and base class constraints.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetElementTypeOrNull(System.Type)">
            <summary>If type is array returns is element type, otherwise returns null.</summary>
            <param name="type">Source type.</param> <returns>Array element type or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetBaseType(System.Type)">
            <summary>Return base type or null, if not exist (the case for only for object type).</summary> 
            <param name="type">Source type.</param> <returns>Base type or null for object.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsPublicOrNestedPublic(System.Type)">
            <summary>Checks if type is public or nested public in public type.</summary>
            <param name="type">Type to check.</param> <returns>Return true if check succeeded.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsValueType(System.Type)">
            <summary>Returns true if type is value type.</summary>
            <param name="type">Type to check.</param> <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsAbstract(System.Type)">
            <summary>Returns true if type if abstract or interface.</summary>
            <param name="type">Type to check.</param> <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsStatic(System.Type)">
            <summary>Returns true if type is static.</summary>
            <param name="type">Type</param> <returns>True is static.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsEnum(System.Type)">
            <summary>Returns true if type is enum type.</summary>
            <param name="type">Type to check.</param> <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsAssignableTo(System.Type,System.Type)">
            <summary>Returns true if instance of type is assignable to instance of <paramref name="other"/> type.</summary>
            <param name="type">Type to check, could be null.</param> 
            <param name="other">Other type to check, could be null.</param>
            <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsTypeOf(System.Type,System.Object)">
            <summary>Returns true if type of <paramref name="obj"/> is assignable to source <paramref name="type"/>.</summary>
            <param name="type">Is type of object.</param> <param name="obj">Object to check.</param>
            <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsPrimitive(System.Type,System.Boolean)">
            <summary>Returns true if provided type IsPitmitive in .Net terms, or enum, or string
            , or array of primitives if <paramref name="orArrayOfPrimitives"/> is true.</summary>
            <param name="type">Type to check.</param> 
            <param name="orArrayOfPrimitives">Says to return true for array or primitives recursively.</param>
            <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAttributes(System.Type,System.Type,System.Boolean)">
            <summary>Returns all attributes defined on <paramref name="type"/>.</summary>
            <param name="type">Type to get attributes for.</param>
            <param name="attributeType">(optional) Check only for that attribute type, otherwise for any attribute.</param>
            <param name="inherit">(optional) Additionally check for attributes inherited from base type.</param>
            <returns>Sequence of found attributes or empty.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAll``1(System.Type,System.Func{DryIoc.Reflection.TypeInfo,System.Collections.Generic.IEnumerable{``0}})">
            <summary>Recursive method to enumerate all input type and its base types for specific details.
            Details are returned by <paramref name="getDeclared"/> delegate.</summary>
            <typeparam name="T">Details type: properties, fields, methods, etc.</typeparam>
            <param name="type">Input type.</param> <param name="getDeclared">Get declared type details.</param>
            <returns>Enumerated details info objects.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAllConstructors(System.Type,System.Boolean,System.Boolean)">
            <summary>Enumerates all constructors from input type.</summary>
            <param name="type">Input type.</param>
            <param name="includeNonPublic">(optional) If set include non-public constructors into result.</param>
            <param name="includeStatic">(optional) Turned off by default.</param>
            <returns>Enumerated constructors.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetConstructorOrNull(System.Type,System.Boolean,System.Type[])">
            <summary>Searches and returns constructor by its signature.</summary>
            <param name="type">Input type.</param>
            <param name="includeNonPublic">(optional) If set include non-public constructors into result.</param>
            <param name="args">Signature - constructor argument types.</param>
            <returns>Found constructor or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetSingleConstructorOrNull(System.Type,System.Boolean)">
            <summary>Returns single constructor, otherwise if no or more than one: returns false.</summary>
            <param name="type">Type to inspect.</param>
            <param name="includeNonPublic">If set, counts non-public constructors.</param>
            <returns>Single constructor or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetSingleDeclaredMethodOrNull(System.Type,System.String)">
            <summary>Returns single declared (not inherited) method by name, or null if not found.</summary>
            <param name="type">Input type</param> <param name="name">Method name to look for.</param>
            <returns>Found method or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetDeclaredMethodOrNull(System.Type,System.String,System.Type[])">
            <summary>Returns declared (not inherited) method by name and argument types, or null if not found.</summary>
            <param name="type">Input type</param> <param name="name">Method name to look for.</param>
            <param name="args">Argument types</param> <returns>Found method or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetPropertyOrNull(System.Type,System.String)">
            <summary>Returns property by name, including inherited. Or null if not found.</summary>
            <param name="type">Input type.</param> <param name="name">Property name to look for.</param>
            <returns>Found property or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetFieldOrNull(System.Type,System.String)">
            <summary>Returns field by name, including inherited. Or null if not found.</summary>
            <param name="type">Input type.</param> <param name="name">Field name to look for.</param>
            <returns>Found field or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAssembly(System.Type)">
            <summary>Returns type assembly.</summary> <param name="type">Input type</param> <returns>Type assembly.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsStatic(System.Reflection.MemberInfo)">
            <summary>Returns true if member is static, otherwise returns false.</summary>
            <param name="member">Member to check.</param> <returns>True if static.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetReturnTypeOrDefault(System.Reflection.MemberInfo)">
            <summary>Return either <see cref="P:System.Reflection.PropertyInfo.PropertyType"/>, or <see cref="P:System.Reflection.FieldInfo.FieldType"/>, <see cref="P:System.Reflection.MethodInfo.ReturnType"/>.
            Otherwise returns null.</summary>
            <param name="member">Expecting member of type <see cref="T:System.Reflection.PropertyInfo"/> or <see cref="T:System.Reflection.FieldInfo"/> only.</param>
            <returns>Type of property of field.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsBackingField(System.Reflection.FieldInfo)">
            <summary>Returns true if field is backing field for property.</summary>
            <param name="field">Field to check.</param> <returns>Returns true if field is backing property.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsPublic(System.Reflection.PropertyInfo)">
            <summary>Returns true if property is public.</summary>
            <param name="property">Property check.</param> <returns>Returns result of check.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsIndexer(System.Reflection.PropertyInfo)">
            <summary>Returns true if property is indexer: aka this[].</summary>
            <param name="property">Property to check</param><returns>True if indexer.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAttributes(System.Reflection.MemberInfo,System.Type,System.Boolean)">
            <summary>Returns attributes defined for the member/method.</summary>
            <param name="member">Member to check.</param> <param name="attributeType">(optional) Specific attribute type to return, any attribute otherwise.</param>
            <param name="inherit">Check for inherited member attributes.</param> <returns>Found attributes or empty.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAttributes(System.Reflection.ParameterInfo,System.Type,System.Boolean)">
            <summary>Returns attributes defined for parameter.</summary>
             <param name="parameter">Target parameter.</param> 
            <param name="attributeType">(optional) Specific attribute type to return, any attribute otherwise.</param>
            <param name="inherit">Check for inherited attributes.</param> <returns>Found attributes or empty.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetLoadedTypes(System.Reflection.Assembly)">
            <summary>Get types from assembly that are loaded successfully. 
            Hacks to <see cref="T:System.Reflection.ReflectionTypeLoadException"/> for loaded types.</summary>
            <param name="assembly">Assembly to get types from.</param>
            <returns>Array of loaded types.</returns>
        </member>
        <member name="T:DryIoc.ReflectionTools.IncludeImplementedType">
            <summary>Flags for <see cref="M:DryIoc.ReflectionTools.GetImplementedTypes(System.Type,DryIoc.ReflectionTools.IncludeImplementedType)"/> method.</summary>
        </member>
        <member name="F:DryIoc.ReflectionTools.IncludeImplementedType.None">
            <summary>Include nor object not source type.</summary>
        </member>
        <member name="F:DryIoc.ReflectionTools.IncludeImplementedType.SourceType">
            <summary>Include source type to list of implemented types.</summary>
        </member>
        <member name="F:DryIoc.ReflectionTools.IncludeImplementedType.ObjectType">
            <summary>Include <see cref="T:System.Object"/> type to list of implemented types.</summary>
        </member>
        <member name="T:DryIoc.ArrayTools">
            <summary>Methods to work with immutable arrays, and general array sugar.</summary>
        </member>
        <member name="M:DryIoc.ArrayTools.IsNullOrEmpty``1(``0[])">
            <summary>Returns true if array is null or have no items.</summary> <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Source array to check.</param> <returns>True if null or has no items, false otherwise.</returns>
        </member>
        <member name="M:DryIoc.ArrayTools.ToArrayOrSelf``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns source enumerable if it is array, otherwise converts source to array.</summary>
            <typeparam name="T">Array item type.</typeparam>
            <param name="source">Source enumerable.</param>
            <returns>Source enumerable or its array copy.</returns>
        </member>
        <member name="M:DryIoc.ArrayTools.Append``1(``0[],``0[])">
            <summary>Returns new array consisting from all items from source array then all items from added array.
            If source is null or empty, then added array will be returned.
            If added is null or empty, then source will be returned.</summary>
            <typeparam name="T">Array item type.</typeparam>
            <param name="source">Array with leading items.</param>
            <param name="added">Array with following items.</param>
            <returns>New array with items of source and added arrays.</returns>
        </member>
        <member name="M:DryIoc.ArrayTools.AppendOrUpdate``1(``0[],``0,System.Int32)">
            <summary>Returns new array with <paramref name="value"/> appended, 
            or <paramref name="value"/> at <paramref name="index"/>, if specified.
            If source array could be null or empty, then single value item array will be created despite any index.</summary>
            <typeparam name="T">Array item type.</typeparam>
            <param name="source">Array to append value to.</param>
            <param name="value">Value to append.</param>
            <param name="index">(optional) Index of value to update.</param>
            <returns>New array with appended or updated value.</returns>
        </member>
        <member name="M:DryIoc.ArrayTools.IndexOf``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Calls predicate on each item in <paramref name="source"/> array until predicate returns true,
            then method will return this item index, or if predicate returns false for each item, method will return -1.</summary>
            <typeparam name="T">Type of array items.</typeparam>
            <param name="source">Source array: if null or empty, then method will return -1.</param>
            <param name="predicate">Delegate to evaluate on each array item until delegate returns true.</param>
            <returns>Index of item for which predicate returns true, or -1 otherwise.</returns>
        </member>
        <member name="M:DryIoc.ArrayTools.IndexOf``1(``0[],``0)">
            <summary>Looks up for item in source array equal to provided value, and returns its index, or -1 if not found.</summary>
            <typeparam name="T">Type of array items.</typeparam>
            <param name="source">Source array: if null or empty, then method will return -1.</param>
            <param name="value">Value to look up.</param>
            <returns>Index of item equal to value, or -1 item is not found.</returns>
        </member>
        <member name="M:DryIoc.ArrayTools.RemoveAt``1(``0[],System.Int32)">
            <summary>Produces new array without item at specified <paramref name="index"/>. 
            Will return <paramref name="source"/> array if index is out of bounds, or source is null/empty.</summary>
            <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Input array.</param> <param name="index">Index if item to remove.</param>
            <returns>New array with removed item at index, or input source array if index is not in array.</returns>
        </member>
        <member name="M:DryIoc.ArrayTools.Remove``1(``0[],``0)">
            <summary>Looks for item in array using equality comparison, and returns new array with found item remove, or original array if not item found.</summary>
            <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Input array.</param> <param name="value">Value to find and remove.</param>
            <returns>New array with value removed or original array if value is not found.</returns>
        </member>
        <member name="M:DryIoc.ArrayTools.One``1(``0)">
            <summary>Creates array consisting of single item.</summary>
            <param name="item">item</param> <typeparam name="T">item type.</typeparam>
            <returns>Array of one item.</returns>
        </member>
        <member name="M:DryIoc.ArrayTools.Empty``1">
            <summary>Returns singleton empty array of provided type.</summary> 
            <typeparam name="T">Array item type.</typeparam> <returns>Empty array.</returns>
        </member>
        <member name="T:DryIoc.PrintTools">
            <summary>Provides pretty printing/debug view for number of types.</summary>
        </member>
        <member name="F:DryIoc.PrintTools.DefaultItemSeparator">
            <summary>Default separator used for printing enumerable.</summary>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.Object,System.String,System.String,System.Func{System.Type,System.String})">
            <summary>Prints input object by using corresponding Print methods for know types.</summary>
            <param name="s">Builder to append output to.</param>
            <param name="x">Object to print.</param>
            <param name="quote">(optional) Quote to use for quoting string object.</param>
            <param name="itemSeparator">(optional) Separator for enumerable.</param>
            <param name="getTypeName">(optional) Custom type printing policy.</param>
            <returns>String builder with appended output.</returns>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.String,System.String)">
            <summary>Appends string to string builder quoting with <paramref name="quote"/> if provided.</summary>
            <param name="s">String builder to append string to.</param>
            <param name="str">String to print.</param>
            <param name="quote">(optional) Quote to add before and after string.</param>
            <returns>String builder with appended string.</returns>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.Collections.IEnumerable,System.String,System.Action{System.Text.StringBuilder,System.Object})">
            <summary>Prints enumerable by using corresponding Print method for known item type.</summary>
            <param name="s">String builder to append output to.</param>
            <param name="items">Items to print.</param>
            <param name="separator">(optional) Custom separator if provided.</param>
            <param name="printItem">(optional) Custom item printer if provided.</param>
            <returns>String builder with appended output.</returns>
        </member>
        <member name="F:DryIoc.PrintTools.GetTypeNameDefault">
            <summary>Default delegate to print Type details: by default print <see cref="P:System.Type.FullName"/> and
            spare namespace if it start with "System."</summary>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.Type,System.Func{System.Type,System.String})">
            <summary>Appends <see cref="T:System.Type"/> object details to string builder.</summary>
            <param name="s">String builder to append output to.</param>
            <param name="type">Input type to print.</param>
            <param name="getTypeName">(optional) Delegate to provide custom type details.</param>
            <returns>String builder with appended output.</returns>
        </member>
        <member name="T:DryIoc.Portable">
            <summary>Ports some methods from .Net 4.0/4.5</summary>
        </member>
        <member name="F:DryIoc.Portable.GetTypesFromAssembly">
            <summary>Portable version of Assembly.GetTypes.</summary>
        </member>
        <member name="F:DryIoc.Portable.GetPropertyGetMethod">
            <summary>Portable version of PropertyInfo.GetGetMethod.</summary>
        </member>
        <member name="F:DryIoc.Portable.GetPropertySetMethod">
            <summary>Portable version of PropertyInfo.GetSetMethod.</summary>
        </member>
        <member name="F:DryIoc.Portable.GetGenericArguments">
            <summary>Portable version of Type.GetGenericArguments.</summary>
        </member>
        <member name="M:DryIoc.Portable.GetCurrentManagedThreadID">
            <summary>Returns managed Thread ID either from Environment or Thread.CurrentThread whichever is available.</summary>
            <returns>Managed Thread ID.</returns>
        </member>
        <member name="T:DryIoc.ExpressionTools">
            <summary>Tools for expressions, that are not supported out-of-box.</summary>
        </member>
        <member name="M:DryIoc.ExpressionTools.GetCalledMethodOrNull(System.Linq.Expressions.LambdaExpression)">
            <summary>Extracts method info from method call expression.
            It is allow to use type-safe method declaration instead of string method name.</summary>
            <param name="methodCall">Lambda wrapping method call.</param>
            <returns>Found method info or null if lambda body is not method call.</returns>
        </member>
        <member name="M:DryIoc.ExpressionTools.GetAccessedMemberOrNull``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>Extracts member info from property or field getter. Enables type-safe property declarations without using strings.</summary>
            <typeparam name="T">Type of member holder.</typeparam>
            <param name="getter">Expected to contain member access: t => t.MyProperty.</param>
            <returns>Extracted member info or null if getter does not contain member access.</returns>
        </member>
        <member name="M:DryIoc.ExpressionTools.GetMethodDelegateOrNull``2(System.String)">
            <summary>Creates and returns delegate calling method without parameters.</summary>
            <typeparam name="TOwner">Method owner type.</typeparam>
            <typeparam name="TReturn">Method return type.</typeparam>
            <param name="methodName">Method name to find.</param>
            <returns>Created delegate or null, if no method with such name is found.</returns>
        </member>
        <member name="M:DryIoc.ExpressionTools.GetDefaultValueExpression(System.Type)">
            <summary>Creates default(T) expression for provided <paramref name="type"/>.</summary>
            <param name="type">Type to get default value of.</param>
            <returns>Default value expression.</returns>
        </member>
        <member name="T:DryIoc.KV`2">
            <summary>Immutable Key-Value. It is reference type (could be check for null), 
            which is different from System value type <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            In addition provides <see cref="M:DryIoc.KV`2.Equals(System.Object)"/> and <see cref="M:DryIoc.KV`2.GetHashCode"/> implementations.</summary>
            <typeparam name="K">Type of Key.</typeparam><typeparam name="V">Type of Value.</typeparam>
        </member>
        <member name="F:DryIoc.KV`2.Key">
            <summary>Key.</summary>
        </member>
        <member name="F:DryIoc.KV`2.Value">
            <summary>Value.</summary>
        </member>
        <member name="M:DryIoc.KV`2.#ctor(`0,`1)">
            <summary>Creates Key-Value object by providing key and value. Does Not check either one for null.</summary>
            <param name="key">key.</param><param name="value">value.</param>
        </member>
        <member name="M:DryIoc.KV`2.ToString">
            <summary>Creates nice string view.</summary><returns>String representation.</returns>
        </member>
        <member name="M:DryIoc.KV`2.Equals(System.Object)">
            <summary>Returns true if both key and value are equal to corresponding key-value of other object.</summary>
            <param name="obj">Object to check equality with.</param> <returns>True if equal.</returns>
        </member>
        <member name="M:DryIoc.KV`2.GetHashCode">
            <summary>Combines key and value hash code. R# generated default implementation.</summary>
            <returns>Combined hash code for key-value.</returns>
        </member>
        <member name="T:DryIoc.Update`1">
            <summary>Delegate for changing value from old one to some new based on provided new value.</summary>
            <typeparam name="V">Type of values.</typeparam>
            <param name="oldValue">Existing value.</param>
            <param name="newValue">New value passed to Update.. method.</param>
            <returns>Changed value.</returns>
        </member>
        <member name="T:DryIoc.ImTreeMapIntToObj">
            <summary>Simple immutable AVL tree with integer keys and object values.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMapIntToObj.Empty">
            <summary>Empty tree to start with. The <see cref="F:DryIoc.ImTreeMapIntToObj.Height"/> of the empty tree is 0.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMapIntToObj.Key">
            <summary>Key.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMapIntToObj.Value">
            <summary>Value.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMapIntToObj.Left">
            <summary>Left subtree/branch, or empty.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMapIntToObj.Right">
            <summary>Right subtree/branch, or empty.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMapIntToObj.Height">
            <summary>Height of longest subtree/branch. It is 0 for empty tree, and 1 for single node tree.</summary>
        </member>
        <member name="M:DryIoc.ImTreeMapIntToObj.AddOrUpdate(System.Int32,System.Object)">
            <summary>Returns new tree with added or updated value for specified key.</summary>
            <param name="key"></param> <param name="value"></param>
            <returns>New tree.</returns>
        </member>
        <member name="M:DryIoc.ImTreeMapIntToObj.AddOrUpdate(System.Int32,System.Object,DryIoc.ImTreeMapIntToObj.UpdateValue)">
            <summary>Returns new tree with added or updated value for specified key.</summary>
            <param name="key"></param> <param name="value"></param>
            <param name="updateValue">Delegate to get updated value based on its old and new value.</param>
            <returns>New tree.</returns>
        </member>
        <member name="M:DryIoc.ImTreeMapIntToObj.Update(System.Int32,System.Object)">
            <summary>Returns new tree with updated value for the key, Or the same tree if key was not found.</summary>
            <param name="key"></param> <param name="value"></param>
            <returns>New tree if key is found, or the same tree otherwise.</returns>
        </member>
        <member name="M:DryIoc.ImTreeMapIntToObj.GetValueOrDefault(System.Int32)">
            <summary>Get value for found key or null otherwise.</summary>
            <param name="key"></param> <returns>Found value or null.</returns>
        </member>
        <member name="M:DryIoc.ImTreeMapIntToObj.Enumerate">
            <summary>Returns all sub-trees enumerated from left to right.</summary> 
            <returns>Enumerated sub-trees or empty if tree is empty.</returns>
        </member>
        <member name="P:DryIoc.ImTreeMapIntToObj.IsEmpty">
            <summary>Returns true is tree is empty.</summary>
        </member>
        <member name="T:DryIoc.ImTreeMapIntToObj.UpdateValue">
            <summary>Delegate to get updated value based on its old and new value.</summary>
            <param name="oldValue">Old</param> <param name="newValue">New</param> <returns>Update result</returns>
        </member>
        <member name="T:DryIoc.ImTreeMap`2">
            <summary>Immutable http://en.wikipedia.org/wiki/AVL_tree where actual node key is hash code of <typeparamref name="K"/>.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMap`2.Empty">
            <summary>Empty tree to start with. The <see cref="F:DryIoc.ImTreeMap`2.Height"/> of the empty tree is 0.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMap`2.Key">
            <summary>Key of type K that should support <see cref="M:System.Object.Equals(System.Object)"/> and <see cref="M:System.Object.GetHashCode"/>.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMap`2.Value">
            <summary>Value of any type V.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMap`2.Hash">
            <summary>Hash calculated from <see cref="F:DryIoc.ImTreeMap`2.Key"/> with <see cref="M:System.Object.GetHashCode"/>. Hash is stored to improve speed.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMap`2.Conflicts">
            <summary>In case of <see cref="F:DryIoc.ImTreeMap`2.Hash"/> conflicts for different keys contains conflicted keys with their values.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMap`2.Left">
            <summary>Left subtree/branch, or empty.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMap`2.Right">
            <summary>Right subtree/branch, or empty.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMap`2.Height">
            <summary>Height of longest subtree/branch. It is 0 for empty tree, and 1 for single node tree.</summary>
        </member>
        <member name="M:DryIoc.ImTreeMap`2.AddOrUpdate(`0,`1,DryIoc.Update{`1})">
            <summary>Returns new tree with added key-value. If value with the same key is exist, then
            if <paramref name="update"/> is not specified: then existing value will be replaced by <paramref name="value"/>;
            if <paramref name="update"/> is specified: then update delegate will decide what value to keep.</summary>
            <param name="key">Key to add.</param><param name="value">Value to add.</param>
            <param name="update">(optional) Delegate to decide what value to keep: old or new one.</param>
            <returns>New tree with added or updated key-value.</returns>
        </member>
        <member name="M:DryIoc.ImTreeMap`2.Update(`0,`1,DryIoc.Update{`1})">
            <summary>Looks for <paramref name="key"/> and replaces its value with new <paramref name="value"/>, or 
            it may use <paramref name="update"/> for more complex update logic. Returns new tree with updated value,
            or the SAME tree if key is not found.</summary>
            <param name="key">Key to look for.</param>
            <param name="value">New value to replace key value with.</param>
            <param name="update">(optional) Delegate for custom update logic, it gets old and new <paramref name="value"/>
            as inputs and should return updated value as output.</param>
            <returns>New tree with updated value or the SAME tree if no key found.</returns>
        </member>
        <member name="M:DryIoc.ImTreeMap`2.GetValueOrDefault(`0,`1)">
            <summary>Searches for key in tree and returns the value if found, or <paramref name="defaultValue"/> otherwise.</summary>
            <param name="key">Key to look for.</param> <param name="defaultValue">Value to return if key is not found.</param>
            <returns>Found value or <paramref name="defaultValue"/>.</returns>
        </member>
        <member name="M:DryIoc.ImTreeMap`2.Enumerate">
            <summary>Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
            The only difference is using fixed size array instead of stack for speed-up (~20% faster than stack).</summary>
            <returns>Sequence of enumerated key value pairs.</returns>
        </member>
        <member name="P:DryIoc.ImTreeMap`2.IsEmpty">
            <summary>Returns true is tree is empty.</summary>
        </member>
        <member name="T:DryIoc.Ref">
            <summary>Provides optimistic-concurrency consistent <see cref="M:DryIoc.Ref.Swap``1(``0@,System.Func{``0,``0})"/> operation.</summary>
        </member>
        <member name="M:DryIoc.Ref.Of``1(``0)">
            <summary>Factory for <see cref="T:DryIoc.Ref`1"/> with type of value inference.</summary>
            <typeparam name="T">Type of value to wrap.</typeparam>
            <param name="value">Initial value to wrap.</param>
            <returns>New ref.</returns>
        </member>
        <member name="M:DryIoc.Ref.NewRef``1(DryIoc.Ref{``0})">
            <summary>Creates new ref to original ref value.</summary> <typeparam name="T">Type of ref value.</typeparam>
            <param name="original">Original ref.</param> <returns>New ref to original value.</returns>
        </member>
        <member name="M:DryIoc.Ref.Swap``1(``0@,System.Func{``0,``0})">
            <summary>First, it evaluates new value using <paramref name="getNewValue"/> function. 
            Second, it checks that original value is not changed. 
            If it is changed it will retry first step, otherwise it assigns new value and returns original (the one used for <paramref name="getNewValue"/>).</summary>
            <typeparam name="T">Type of value to swap.</typeparam>
            <param name="value">Reference to change to new value</param>
            <param name="getNewValue">Delegate to get value from old one.</param>
            <returns>Old/original value. By analogy with <see cref="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)"/>.</returns>
            <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        </member>
        <member name="T:DryIoc.Ref`1">
            <summary>Wrapper that provides optimistic-concurrency Swap operation implemented using <see cref="M:DryIoc.Ref.Swap``1(``0@,System.Func{``0,``0})"/>.</summary>
            <typeparam name="T">Type of object to wrap.</typeparam>
        </member>
        <member name="M:DryIoc.Ref`1.#ctor(`0)">
            <summary>Creates ref to object, optionally with initial value provided.</summary>
            <param name="initialValue">Initial object value.</param>
        </member>
        <member name="M:DryIoc.Ref`1.Swap(System.Func{`0,`0})">
            <summary>Exchanges currently hold object with <paramref name="getNewValue"/> result: see <see cref="M:DryIoc.Ref.Swap``1(``0@,System.Func{``0,``0})"/> for details.</summary>
            <param name="getNewValue">Delegate to produce new object value from current one passed as parameter.</param>
            <returns>Returns old object value the same way as <see cref="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)"/></returns>
            <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        </member>
        <member name="M:DryIoc.Ref`1.Swap(`0)">
            <summary>Simplified version of Swap ignoring old value.</summary>
            <param name="newValue">New value to set</param> <returns>Old value.</returns>
        </member>
        <member name="P:DryIoc.Ref`1.Value">
            <summary>Gets the wrapped value.</summary>
        </member>
        <member name="T:DryIoc.Reflection.TypeInfoTools">
            <summary>Adds extension method to Type to return corresponding <see cref="T:DryIoc.Reflection.TypeInfo"/> for it.</summary>
        </member>
        <member name="M:DryIoc.Reflection.TypeInfoTools.GetTypeInfo(System.Type)">
            <summary>Wraps input type into <see cref="T:DryIoc.Reflection.TypeInfo"/> structure.</summary>
            <param name="type">Input type.</param> <returns>Type info wrapper.</returns>
        </member>
        <member name="T:DryIoc.Reflection.TypeInfo">
            <summary>Partial analog of TypeInfo existing in .NET 4.5 and higher.</summary>
        </member>
        <member name="M:DryIoc.Reflection.TypeInfo.#ctor(System.Type)">
            <summary>Creates type info by wrapping input type.</summary> <param name="type">Type to wrap.</param>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.TypeExtensions">
            <summary>
            Extends <see cref="T:System.Type"/> with methods that are useful in
            building scanning rules for <see cref="M:Revenj.Extensibility.Autofac.RegistrationExtensions.RegisterAssemblyTypes(Revenj.Extensibility.Autofac.ContainerBuilder,System.Reflection.Assembly[])"/>.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.TypeExtensions.IsInNamespace(System.Type,System.String)">
            <summary>
            Returns true if this type is in the <paramref name="namespace"/> namespace
            or one of its sub-namespaces.
            </summary>
            <param name="this">The type to test.</param>
            <param name="namespace">The namespace to test.</param>
            <returns>True if this type is in the <paramref name="namespace"/> namespace
            or one of its sub-namespaces; otherwise, false.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.TypeExtensions.IsInNamespaceOf``1(System.Type)">
            <summary>
            Returns true if this type is in the same namespace as <typeparamref name="T"/>
            or one of its sub-namespaces.
            </summary>
            <param name="this">The type to test.</param>
            <returns>True if this type is in the same namespace as <typeparamref name="T"/>
            or one of its sub-namespaces; otherwise, false.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.TypeExtensions.IsClosedTypeOf(System.Type,System.Type)">
            <summary>Determines whether the candidate type supports any base or 
            interface that closes the provided generic type.</summary>
            <param name="this"></param>
            <param name="openGeneric"></param>
            <returns></returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.TypeExtensions.IsAssignableTo``1(System.Type)">
            <summary>
            Determines whether this type is assignable to <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type to test assignability to.</typeparam>
            <returns>True if this type is assignable to references of type
            <typeparamref name="T"/>; otherwise, False.</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.ResolutionExtensions">
            <summary>
            Adds syntactic convenience methods to the <see cref="T:Revenj.Extensibility.Autofac.IComponentContext"/> interface.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.InjectProperties``1(Revenj.Extensibility.Autofac.IComponentContext,``0)">
            <summary>
            Set any properties on <paramref name="instance"/> that can be
            resolved in the context.
            </summary>
            <typeparam name="TService">Type of instance. Used only to provide method chaining.</typeparam>
            <param name="context">The context from which to resolve the service.</param>
            <param name="instance">The instance to inject properties into.</param>
            <returns><paramref name="instance"/>.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.InjectUnsetProperties``1(Revenj.Extensibility.Autofac.IComponentContext,``0)">
            <summary>
            Set any null-valued properties on <paramref name="instance"/> that can be
            resolved by the container.
            </summary>
            <typeparam name="TService">Type of instance. Used only to provide method chaining.</typeparam>
            <param name="context">The context from which to resolve the service.</param>
            <param name="instance">The instance to inject properties into.</param>
            <returns><paramref name="instance"/>.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveNamed``1(Revenj.Extensibility.Autofac.IComponentContext,System.String)">
            <summary>
            Retrieve a service from the context.
            </summary>
            <typeparam name="TService">The type to which the result will be cast.</typeparam>
            <param name="context">The context from which to resolve the service.</param>
            <param name="serviceName">Name of the service.</param>
            <returns>
            The component instance that provides the service.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveNamed``1(Revenj.Extensibility.Autofac.IComponentContext,System.String,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Retrieve a service from the context.
            </summary>
            <typeparam name="TService">The type to which the result will be cast.</typeparam>
            <param name="context">The context from which to resolve the service.</param>
            <param name="serviceName">Name of the service.</param>
            <param name="parameters">The parameters.</param>
            <returns>
            The component instance that provides the service.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveNamed``1(Revenj.Extensibility.Autofac.IComponentContext,System.String,Revenj.Extensibility.Autofac.Core.Parameter[])">
            <summary>
            Retrieve a service from the context.
            </summary>
            <typeparam name="TService">The type to which the result will be cast.</typeparam>
            <param name="context">The context from which to resolve the service.</param>
            <param name="serviceName">Name of the service.</param>
            <param name="parameters">The parameters.</param>
            <returns>
            The component instance that provides the service.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveKeyed``1(Revenj.Extensibility.Autofac.IComponentContext,System.Object)">
            <summary>
            Retrieve a service from the context.
            </summary>
            <typeparam name="TService">The type to which the result will be cast.</typeparam>
            <param name="context">The context from which to resolve the service.</param>
            <param name="serviceKey">Key of the service.</param>
            <returns>
            The component instance that provides the service.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveKeyed``1(Revenj.Extensibility.Autofac.IComponentContext,System.Object,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Retrieve a service from the context.
            </summary>
            <typeparam name="TService">The type to which the result will be cast.</typeparam>
            <param name="context">The context from which to resolve the service.</param>
            <param name="serviceKey">Key of the service.</param>
            <param name="parameters">The parameters.</param>
            <returns>
            The component instance that provides the service.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveKeyed``1(Revenj.Extensibility.Autofac.IComponentContext,System.Object,Revenj.Extensibility.Autofac.Core.Parameter[])">
            <summary>
            Retrieve a service from the context.
            </summary>
            <typeparam name="TService">The type to which the result will be cast.</typeparam>
            <param name="context">The context from which to resolve the service.</param>
            <param name="serviceKey">Key of the service.</param>
            <param name="parameters">The parameters.</param>
            <returns>
            The component instance that provides the service.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.Resolve``1(Revenj.Extensibility.Autofac.IComponentContext)">
            <summary>
            Retrieve a service from the context.
            </summary>
            <typeparam name="TService">The service to retrieve.</typeparam>
            <param name="context">The context from which to resolve the service.</param>
            <returns>The component instance that provides the service.</returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.Resolve``1(Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Retrieve a service from the context.
            </summary>
            <typeparam name="TService">The type to which the result will be cast.</typeparam>
            <param name="context">The context from which to resolve the service.</param>
            <param name="parameters">Parameters for the service.</param>
            <returns>
            The component instance that provides the service.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.Resolve``1(Revenj.Extensibility.Autofac.IComponentContext,Revenj.Extensibility.Autofac.Core.Parameter[])">
            <summary>
            Retrieve a service from the context.
            </summary>
            <typeparam name="TService">The type to which the result will be cast.</typeparam>
            <param name="context">The context from which to resolve the service.</param>
            <param name="parameters">Parameters for the service.</param>
            <returns>
            The component instance that provides the service.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.Resolve(Revenj.Extensibility.Autofac.IComponentContext,System.Type)">
            <summary>
            Retrieve a service from the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="serviceType">The service type.</param>
            <returns>
            The component instance that provides the service.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.Resolve(Revenj.Extensibility.Autofac.IComponentContext,System.Type,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Retrieve a service from the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="parameters">Parameters for the service.</param>
            <param name="serviceType">The service type.</param>
            <returns>
            The component instance that provides the service.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.Resolve(Revenj.Extensibility.Autofac.IComponentContext,System.Type,Revenj.Extensibility.Autofac.Core.Parameter[])">
            <summary>
            Retrieve a service from the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="parameters">Parameters for the service.</param>
            <param name="serviceType">The service type.</param>
            <returns>
            The component instance that provides the service.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveNamed(Revenj.Extensibility.Autofac.IComponentContext,System.String,System.Type)">
            <summary>
            Retrieve a service from the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="serviceName">The service name.</param>
            <param name="serviceType">Type of the service.</param>
            <returns>
            The component instance that provides the service.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveNamed(Revenj.Extensibility.Autofac.IComponentContext,System.String,System.Type,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Retrieve a service from the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="parameters">Parameters for the service.</param>
            <param name="serviceName">The service name.</param>
            <param name="serviceType">Type of the service.</param>
            <returns>
            The component instance that provides the service.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveNamed(Revenj.Extensibility.Autofac.IComponentContext,System.String,System.Type,Revenj.Extensibility.Autofac.Core.Parameter[])">
            <summary>
            Retrieve a service from the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="parameters">Parameters for the service.</param>
            <param name="serviceName">The service name.</param>
            <param name="serviceType">Type of the service.</param>
            <returns>
            The component instance that provides the service.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveService(Revenj.Extensibility.Autofac.IComponentContext,Revenj.Extensibility.Autofac.Core.Service)">
            <summary>
            Retrieve a service from the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="service">The service to resolve.</param>
            <returns>
            The component instance that provides the service.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveService(Revenj.Extensibility.Autofac.IComponentContext,Revenj.Extensibility.Autofac.Core.Service,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Retrieve a service from the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="parameters">Parameters for the service.</param>
            <param name="service">The service to resolve.</param>
            <returns>
            The component instance that provides the service.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveService(Revenj.Extensibility.Autofac.IComponentContext,Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.Core.Parameter[])">
            <summary>
            Retrieve a service from the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="parameters">Parameters for the service.</param>
            <param name="service">The service to resolve.</param>
            <returns>
            The component instance that provides the service.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveOptional``1(Revenj.Extensibility.Autofac.IComponentContext)">
            <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <typeparam name="TService">The service to resolve.</typeparam>
            <returns>
            The component instance that provides the service, or null.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveOptional``1(Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="parameters">Parameters for the service.</param>
            <typeparam name="TService">The service to resolve.</typeparam>
            <returns>
            The component instance that provides the service, or null.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveOptional``1(Revenj.Extensibility.Autofac.IComponentContext,Revenj.Extensibility.Autofac.Core.Parameter[])">
            <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="parameters">Parameters for the service.</param>
            <typeparam name="TService">The service to resolve.</typeparam>
            <returns>
            The component instance that provides the service, or null.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveOptionalNamed``1(Revenj.Extensibility.Autofac.IComponentContext,System.String)">
            <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="serviceName">The name of the service.</param>
            <typeparam name="TService">The service to resolve.</typeparam>
            <returns>
            The component instance that provides the service, or null.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveOptionalNamed``1(Revenj.Extensibility.Autofac.IComponentContext,System.String,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="parameters">Parameters for the service.</param>
            <param name="serviceName">The name of the service.</param>
            <typeparam name="TService">The service to resolve.</typeparam>
            <returns>
            The component instance that provides the service, or null.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveOptionalNamed``1(Revenj.Extensibility.Autofac.IComponentContext,System.String,Revenj.Extensibility.Autofac.Core.Parameter[])">
            <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="parameters">Parameters for the service.</param>
            <param name="serviceName">The name of the service.</param>
            <typeparam name="TService">The service to resolve.</typeparam>
            <returns>
            The component instance that provides the service, or null.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveOptionalKeyed``1(Revenj.Extensibility.Autofac.IComponentContext,System.Object)">
            <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="serviceKey">The name of the service.</param>
            <typeparam name="TService">The service to resolve.</typeparam>
            <returns>
            The component instance that provides the service, or null.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveOptionalKeyed``1(Revenj.Extensibility.Autofac.IComponentContext,System.Object,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="parameters">Parameters for the service.</param>
            <param name="serviceKey">The name of the service.</param>
            <typeparam name="TService">The service to resolve.</typeparam>
            <returns>
            The component instance that provides the service, or null.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveOptionalKeyed``1(Revenj.Extensibility.Autofac.IComponentContext,System.Object,Revenj.Extensibility.Autofac.Core.Parameter[])">
            <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="parameters">Parameters for the service.</param>
            <param name="serviceKey">The key of the service.</param>
            <typeparam name="TService">The service to resolve.</typeparam>
            <returns>
            The component instance that provides the service, or null.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveOptional(Revenj.Extensibility.Autofac.IComponentContext,System.Type)">
            <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="serviceType">The type of the service.</param>
            <returns>
            The component instance that provides the service, or null.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveOptional(Revenj.Extensibility.Autofac.IComponentContext,System.Type,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="parameters">Parameters for the service.</param>
            <param name="serviceType">The type of the service.</param>
            <returns>
            The component instance that provides the service, or null.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveOptional(Revenj.Extensibility.Autofac.IComponentContext,System.Type,Revenj.Extensibility.Autofac.Core.Parameter[])">
            <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="parameters">Parameters for the service.</param>
            <param name="serviceType">The type of the service.</param>
            <returns>
            The component instance that provides the service, or null.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveOptionalService(Revenj.Extensibility.Autofac.IComponentContext,Revenj.Extensibility.Autofac.Core.Service)">
            <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="service">The service.</param>
            <returns>
            The component instance that provides the service, or null.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveOptionalService(Revenj.Extensibility.Autofac.IComponentContext,Revenj.Extensibility.Autofac.Core.Service,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="service">The service.</param>
            <param name="parameters">Parameters for the service.</param>
            <returns>
            The component instance that provides the service, or null.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.ResolveOptionalService(Revenj.Extensibility.Autofac.IComponentContext,Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.Core.Parameter[])">
            <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="service">The service.</param>
            <param name="parameters">Parameters for the service.</param>
            <returns>
            The component instance that provides the service, or null.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.IsRegistered``1(Revenj.Extensibility.Autofac.IComponentContext)">
            <summary>
            Determine whether the specified service is available in the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <typeparam name="TService">The service to test for the registration of.</typeparam>
            <returns>True if the service is registered.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.IsRegistered(Revenj.Extensibility.Autofac.IComponentContext,System.Type)">
            <summary>
            Determine whether the specified service is available in the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="serviceType">The service to test for the registration of.</param>
            <returns>True if the service is registered.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.IsRegisteredWithName(Revenj.Extensibility.Autofac.IComponentContext,System.String,System.Type)">
            <summary>
            Determine whether the specified service is available in the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="serviceName">The name of the service to test for the registration of.</param>
            <param name="serviceType">Type type of the service to test for the registration of.</param>
            <returns>True if the service is registered.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.IsRegisteredWithName``1(Revenj.Extensibility.Autofac.IComponentContext,System.String)">
            <summary>
            Determine whether the specified service is available in the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="serviceName">The name of the service to test for the registration of.</param>
            <typeparam name="TService">Type type of the service to test for the registration of.</typeparam>
            <returns>True if the service is registered.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.IsRegisteredWithKey(Revenj.Extensibility.Autofac.IComponentContext,System.Object,System.Type)">
            <summary>
            Determine whether the specified service is available in the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="serviceKey">The key of the service to test for the registration of.</param>
            <param name="serviceType">Type type of the service to test for the registration of.</param>
            <returns>True if the service is registered.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.IsRegisteredWithKey``1(Revenj.Extensibility.Autofac.IComponentContext,System.Object)">
            <summary>
            Determine whether the specified service is available in the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="serviceKey">The key of the service to test for the registration of.</param>
            <typeparam name="TService">Type type of the service to test for the registration of.</typeparam>
            <returns>True if the service is registered.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.IsRegisteredService(Revenj.Extensibility.Autofac.IComponentContext,Revenj.Extensibility.Autofac.Core.Service)">
            <summary>
            Determine whether the specified service is available in the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="service">The service to test for the registration of.</param>
            <returns>True if the service is registered.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.TryResolveService(Revenj.Extensibility.Autofac.IComponentContext,Revenj.Extensibility.Autofac.Core.Service,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},System.Object@)">
            <summary>
            Try to retrieve a service from the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="service">The service to resolve.</param>
            <param name="instance">The resulting component instance providing the service, or null.</param>
            <param name="parameters">The parameters.</param>
            <returns>
            True if a component providing the service is available.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.TryResolveService(Revenj.Extensibility.Autofac.IComponentContext,Revenj.Extensibility.Autofac.Core.Service,System.Object@)">
            <summary>
            Try to retrieve a service from the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="service">The service to resolve.</param>
            <param name="instance">The resulting component instance providing the service, or null.</param>
            <returns>
            True if a component providing the service is available.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.TryResolve(Revenj.Extensibility.Autofac.IComponentContext,System.Type,System.Object@)">
            <summary>
            Try to retrieve a service from the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="serviceType">The service type to resolve.</param>
            <param name="instance">The resulting component instance providing the service, or null.</param>
            <returns>
            True if a component providing the service is available.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.TryResolve``1(Revenj.Extensibility.Autofac.IComponentContext,``0@)">
            <summary>
            Try to retrieve a service from the context.
            </summary>
            <typeparam name="T">The service type to resolve.</typeparam>
            <param name="context">The context from which to resolve the service.</param>
            <param name="instance">The resulting component instance providing the service, or default(T).</param>
            <returns>
            True if a component providing the service is available.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.TryResolveNamed(Revenj.Extensibility.Autofac.IComponentContext,System.String,System.Type,System.Object@)">
            <summary>
            Try to retrieve a service from the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="serviceName">The name of the service to resolve.</param>
            <param name="serviceType">The type of the service to resolve.</param>
            <param name="instance">The resulting component instance providing the service, or null.</param>
            <returns>
            True if a component providing the service is available.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ResolutionExtensions.TryResolveKeyed(Revenj.Extensibility.Autofac.IComponentContext,System.Object,System.Type,System.Object@)">
            <summary>
            Try to retrieve a service from the context.
            </summary>
            <param name="context">The context from which to resolve the service.</param>
            <param name="serviceKey">The key of the service to resolve.</param>
            <param name="serviceType">The type of the service to resolve.</param>
            <param name="instance">The resulting component instance providing the service, or null.</param>
            <returns>
            True if a component providing the service is available.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Features.Indexed.IIndex`2">
            <summary>
            Provides components by lookup operations via an index (key) type.
            </summary>
            <typeparam name="TKey">The type of the index.</typeparam>
            <typeparam name="TValue">The service provided by the indexed components.</typeparam>
            <example>
            Retrieving a value given a key:
            <code>
            IIndex&lt;AccountType, IRenderer&gt; accountRenderers = // ...
            var renderer = accountRenderers[AccountType.User];
            </code>
            </example>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.Indexed.IIndex`2.TryGetValue(`0,`1@)">
            <summary>
            Get the value associated with <paramref name="key"/> if any is available.
            </summary>
            <param name="key">The key to look up.</param>
            <param name="value">The retrieved value.</param>
            <returns>True if a value associated with the key exists.</returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Features.Indexed.IIndex`2.Item(`0)">
            <summary>
            Get the value associated with <paramref name="key"/>.
            </summary>
            <param name="key">The value to retrieve.</param>
            <returns>The associated value.</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Resolving.InstanceLookupEndingEventArgs">
            <summary>
            Fired when an instance is looked up.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Resolving.InstanceLookupEndingEventArgs.#ctor(Revenj.Extensibility.Autofac.Core.Resolving.IInstanceLookup,System.Boolean)">
            <summary>
            Create an instance of the <see cref="T:Revenj.Extensibility.Autofac.Core.Resolving.InstanceLookupBeginningEventArgs"/> class.
            </summary>
            <param name="instanceLookup">The instance lookup that is ending.</param>
            <param name="newInstanceActivated">True if a new instance was created as part of the operation.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Resolving.InstanceLookupEndingEventArgs.NewInstanceActivated">
            <summary>
            True if a new instance was created as part of the operation.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Resolving.InstanceLookupEndingEventArgs.InstanceLookup">
            <summary>
            The instance lookup operation that is ending.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Resolving.InstanceLookupCompletionBeginningEventArgs">
            <summary>
            Raised when the completion phase of an instance lookup operation begins.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Resolving.InstanceLookupCompletionBeginningEventArgs.#ctor(Revenj.Extensibility.Autofac.Core.Resolving.IInstanceLookup)">
            <summary>
            Create an instance of the <see cref="T:Revenj.Extensibility.Autofac.Core.Resolving.InstanceLookupCompletionBeginningEventArgs"/> class.
            </summary>
            <param name="instanceLookup">The instance lookup that is beginning the completion phase.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Resolving.InstanceLookupCompletionBeginningEventArgs.InstanceLookup">
            <summary>
            The instance lookup operation that is beginning the completion phase.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.ActivatedEventArgs`1">
            <summary>
            Fired when the activation process for a new instance is complete.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.IActivatedEventArgs`1">
            <summary>
            Fired when the activation process for a new instance is complete.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IActivatedEventArgs`1.Context">
            <summary>
            The context in which the activation occurred.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IActivatedEventArgs`1.Component">
            <summary>
            The component providing the instance.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IActivatedEventArgs`1.Parameters">
            <summary>
            The paramters provided when resolved.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IActivatedEventArgs`1.Instance">
            <summary>
            The instance that will be used to satisfy the request.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.ActivatedEventArgs`1.#ctor(Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.IComponentContext,Revenj.Extensibility.Autofac.Core.IComponentRegistration,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Core.ActivatedEventArgs`1"/> class.
            </summary>
            <param name="service">Service which is activated</param>
            <param name="context">The context.</param>
            <param name="component">The component.</param>
            <param name="parameters">The parameters.</param>
            <param name="instance">The instance.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.ActivatedEventArgs`1.Service">
            <summary>
            The service which is activating.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.ActivatedEventArgs`1.Context">
            <summary>
            The context in which the activation occurred.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.ActivatedEventArgs`1.Component">
            <summary>
            The component providing the instance.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.ActivatedEventArgs`1.Parameters">
            <summary>
            The paramters provided when resolved.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.ActivatedEventArgs`1.Instance">
            <summary>
            The instance that will be used to satisfy the request.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.ListElementCollection">
            <summary>
            Holds a list of values for those properties/parameters that are enumerable
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.ListElementCollection.ListElementTypeConverter">
            <summary>
            Helps convert the configuration element into an actuall generic list
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlParameterStatus">
             <summary>
             This class represents the ParameterStatus message sent from PostgreSQL
             server.
             </summary>
            
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NoticeEventHandler">
            <summary>
            Represents the method that handles the <see cref="E:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.Notification">Notice</see> events.
            </summary>
            <param name="e">A <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlNoticeEventArgs">NpgsqlNoticeEventArgs</see> that contains the event data.</param>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NotificationEventHandler">
            <summary>
            Represents the method that handles the <see cref="E:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.Notification">Notification</see> events.
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="e">A <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlNotificationEventArgs">NpgsqlNotificationEventArgs</see> that contains the event data.</param>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection">
            <summary>
            This class represents a connection to a
            PostgreSQL server.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.#ctor">
            <summary>
            Initializes a new instance of the
            <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection">NpgsqlConnection</see> class.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.#ctor(System.String)">
            <summary>
            Initializes a new instance of the
            <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection">NpgsqlConnection</see> class
            and sets the <see cref="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.ConnectionString">ConnectionString</see>.
            </summary>
            <param name="ConnectionString">The connection used to open the PostgreSQL database.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.BeginDbTransaction(System.Data.IsolationLevel)">
            <summary>
            Begins a database transaction with the specified isolation level.
            </summary>
            <param name="isolationLevel">The <see cref="T:System.Data.IsolationLevel">isolation level</see> under which the transaction should run.</param>
            <returns>An <see cref="T:System.Data.Common.DbTransaction">DbTransaction</see>
            object representing the new transaction.</returns>
            <remarks>
            Currently the IsolationLevel ReadCommitted and Serializable are supported by the PostgreSQL backend.
            There's no support for nested transactions.
            </remarks>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.BeginTransaction">
            <summary>
            Begins a database transaction.
            </summary>
            <returns>A <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlTransaction">NpgsqlTransaction</see>
            object representing the new transaction.</returns>
            <remarks>
            Currently there's no support for nested transactions.
            </remarks>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.BeginTransaction(System.Data.IsolationLevel)">
            <summary>
            Begins a database transaction with the specified isolation level.
            </summary>
            <param name="level">The <see cref="T:System.Data.IsolationLevel">isolation level</see> under which the transaction should run.</param>
            <returns>A <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlTransaction">NpgsqlTransaction</see>
            object representing the new transaction.</returns>
            <remarks>
            Currently the IsolationLevel ReadCommitted and Serializable are supported by the PostgreSQL backend.
            There's no support for nested transactions.
            </remarks>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.Open">
            <summary>
            Opens a database connection with the property settings specified by the
            <see cref="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.ConnectionString">ConnectionString</see>.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.ChangeDatabase(System.String)">
            <summary>
            This method changes the current database by disconnecting from the actual
            database and connecting to the specified.
            </summary>
            <param name="dbName">The name of the database to use in place of the current database.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.Close">
            <summary>
            Releases the connection to the database.  If the connection is pooled, it will be
            made available for re-use.  If it is non-pooled, the actual connection will be shutdown.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.CreateDbCommand">
            <summary>
            Creates and returns a <see cref="T:System.Data.Common.DbCommand">DbCommand</see>
            object associated with the <see cref="T:System.Data.Common.DbConnection">IDbConnection</see>.
            </summary>
            <returns>A <see cref="T:System.Data.Common.DbCommand">DbCommand</see> object.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.CreateCommand">
            <summary>
            Creates and returns a <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand">NpgsqlCommand</see>
            object associated with the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection">NpgsqlConnection</see>.
            </summary>
            <returns>A <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand">NpgsqlCommand</see> object.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.Dispose(System.Boolean)">
            <summary>
            Releases all resources used by the
            <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection">NpgsqlConnection</see>.
            </summary>
            <param name="disposing"><b>true</b> when called from Dispose();
            <b>false</b> when being called from the finalizer.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.System#ICloneable#Clone">
            <summary>
            Create a new connection based on this one.
            </summary>
            <returns>A new NpgsqlConnection object.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.Clone">
            <summary>
            Create a new connection based on this one.
            </summary>
            <returns>A new NpgsqlConnection object.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.DefaultCertificateSelectionCallback(System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Cryptography.X509Certificates.X509Certificate,System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection)">
            <summary>
            Default SSL CertificateSelectionCallback implementation.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.DefaultCertificateValidationCallback(System.Security.Cryptography.X509Certificates.X509Certificate,System.Int32[])">
            <summary>
            Default SSL CertificateValidationCallback implementation.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.DefaultPrivateKeySelectionCallback(System.Security.Cryptography.X509Certificates.X509Certificate,System.String)">
            <summary>
            Default SSL PrivateKeySelectionCallback implementation.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.DefaultProvideClientCertificatesCallback(System.Security.Cryptography.X509Certificates.X509CertificateCollection)">
            <summary>
            Default SSL ProvideClientCertificatesCallback implementation.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.GetSchema">
            <summary>
            Returns the supported collections
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.GetSchema(System.String)">
            <summary>
            Returns the schema collection specified by the collection name.
            </summary>
            <param name="collectionName">The collection name.</param>
            <returns>The collection specified.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.GetSchema(System.String,System.String[])">
            <summary>
            Returns the schema collection specified by the collection name filtered by the restrictions.
            </summary>
            <param name="collectionName">The collection name.</param>
            <param name="restrictions">
            The restriction values to filter the results.  A description of the restrictions is contained
            in the Restrictions collection.
            </param>
            <returns>The collection specified.</returns>
        </member>
        <member name="E:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.Notice">
            <summary>
            Occurs on NoticeResponses from the PostgreSQL backend.
            </summary>
        </member>
        <member name="E:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.Notification">
            <summary>
            Occurs on NotificationResponses from the PostgreSQL backend.
            </summary>
        </member>
        <member name="E:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.ProvideClientCertificatesCallback">
            <summary>
            Called to provide client certificates for SSL handshake.
            </summary>
        </member>
        <member name="E:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.CertificateSelectionCallback">
            <summary>
            Mono.Security.Protocol.Tls.CertificateSelectionCallback delegate.
            </summary>
        </member>
        <member name="E:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.CertificateValidationCallback">
            <summary>
            Mono.Security.Protocol.Tls.CertificateValidationCallback delegate.
            </summary>
        </member>
        <member name="E:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.PrivateKeySelectionCallback">
            <summary>
            Mono.Security.Protocol.Tls.PrivateKeySelectionCallback delegate.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.ConnectionString">
            <summary>
            Gets or sets the string used to connect to a PostgreSQL database.
            Valid values are:
            <ul>
            <li>
            Server:             Address/Name of Postgresql Server;
            </li>
            <li>
            Port:               Port to connect to;
            </li>
            <li>
            Protocol:           Protocol version to use, instead of automatic; Integer 2 or 3;
            </li>
            <li>
            Database:           Database name. Defaults to user name if not specified;
            </li>
            <li>
            User Id:            User name;
            </li>
            <li>
            Password:           Password for clear text authentication;
            </li>
            <li>
            SSL:                True or False. Controls whether to attempt a secure connection. Default = False;
            </li>
            <li>
            Pooling:            True or False. Controls whether connection pooling is used. Default = True;
            </li>
            <li>
            MinPoolSize:        Min size of connection pool;
            </li>
            <li>
            MaxPoolSize:        Max size of connection pool;
            </li>
            <li>
            Timeout:            Time to wait for connection open in seconds. Default is 15.
            </li>
            <li>
            CommandTimeout:     Time to wait for command to finish execution before throw an exception. In seconds. Default is 20.
            </li>
            <li>
            Sslmode:            Mode for ssl connection control. Can be Prefer, Require, Allow or Disable. Default is Disable. Check user manual for explanation of values.
            </li>
            <li>
            ConnectionLifeTime: Time to wait before closing unused connections in the pool in seconds. Default is 15.
            </li>
            <li>
            SyncNotification:   Specifies if Npgsql should use synchronous notifications.
            </li>
            <li>
            SearchPath: Changes search path to specified and public schemas.
            </li>
            </ul>
            </summary>
            <value>The connection string that includes the server name,
            the database name, and other parameters needed to establish
            the initial connection. The default value is an empty string.
            </value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.Host">
            <summary>
            Backend server host name.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.Port">
            <summary>
            Backend server port.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.SSL">
            <summary>
            If true, the connection will attempt to use SSL.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.ConnectionTimeout">
            <summary>
            Gets the time to wait while trying to establish a connection
            before terminating the attempt and generating an error.
            </summary>
            <value>The time (in seconds) to wait for a connection to open. The default value is 15 seconds.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.CommandTimeout">
            <summary>
            Gets the time to wait while trying to execute a command
            before terminating the attempt and generating an error.
            </summary>
            <value>The time (in seconds) to wait for a command to complete. The default value is 20 seconds.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.ConnectionLifeTime">
            <summary>
            Gets the time to wait before closing unused connections in the pool if the count
            of all connections exeeds MinPoolSize.
            </summary>
            <remarks>
            If connection pool contains unused connections for ConnectionLifeTime seconds,
            the half of them will be closed. If there will be unused connections in a second
            later then again the half of them will be closed and so on.
            This strategy provide smooth change of connection count in the pool.
            </remarks>
            <value>The time (in seconds) to wait. The default value is 15 seconds.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.Database">
            <summary>
             Gets the name of the current database or the database to be used after a connection is opened.
             </summary>
             <value>The name of the current database or the name of the database to be
             used after a connection is opened. The default value is the empty string.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.PreloadReader">
            <summary>
            Whether datareaders are loaded in their entirety (for compatibility with earlier code).
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.DataSource">
            <summary>
            Gets the database server name.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.SyncNotification">
            <summary>
            Gets flag indicating if we are using Synchronous notification or not.
            The default value is false.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.FullState">
            <summary>
            Gets the current state of the connection.
            </summary>
            <value>A bitwise combination of the <see cref="T:System.Data.ConnectionState">ConnectionState</see> values. The default is <b>Closed</b>.</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.State">
            <summary>
            Gets whether the current state of the connection is Open or Closed
            </summary>
            <value>ConnectionState.Open or ConnectionState.Closed</value>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.PostgreSqlVersion">
            <summary>
            Version of the PostgreSQL backend.
            This can only be called when there is an active connection.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.ProcessID">
            <summary>
            Process id of backend server.
            This can only be called when there is an active connection.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.Connector">
            <summary>
            The connector object connected to the backend.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.ConnectionStringValues">
            <summary>
            Gets the NpgsqlConnectionStringBuilder containing the parsed connection string values.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.UserName">
            <summary>
            User name.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.Password">
            <summary>
            Password.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection.Pooling">
            <summary>
            Determine if connection pooling will be used for this connection.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommandBuilder">
            <summary>
             This class is responsible to create database commands for automatic insert, update and delete operations.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommandBuilder.DeriveParameters(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand)">
            <summary>
            
             This method is reponsible to derive the command parameter list with values obtained from function definition.
             It clears the Parameters collection of command. Also, if there is any parameter type which is not supported by Npgsql, an InvalidOperationException will be thrown.
             Parameters name will be parameter1, parameter2, ...
             For while, only parameter name and NpgsqlDbType are obtained.
            </summary>
             <param name="command">NpgsqlCommand whose function parameters will be obtained.</param>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BasicBackendToNativeTypeConverter">
            <summary>
            Provide event handlers to convert all native supported basic data types from their backend
            text representation to a .NET object.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BasicBackendToNativeTypeConverter.ToBinary(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo,System.String,System.Int16,System.Int32)">
            <summary>
            Binary data.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BasicBackendToNativeTypeConverter.ToBoolean(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo,System.String,System.Int16,System.Int32)">
            <summary>
            Convert a postgresql boolean to a System.Boolean.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BasicBackendToNativeTypeConverter.ToBit(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo,System.String,System.Int16,System.Int32)">
            <summary>
            Convert a postgresql bit to a System.Boolean.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BasicBackendToNativeTypeConverter.ToDateTime(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo,System.String,System.Int16,System.Int32)">
            <summary>
            Convert a postgresql datetime to a System.DateTime.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BasicBackendToNativeTypeConverter.ToDate(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo,System.String,System.Int16,System.Int32)">
            <summary>
            Convert a postgresql date to a System.DateTime.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BasicBackendToNativeTypeConverter.ToTime(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo,System.String,System.Int16,System.Int32)">
            <summary>
            Convert a postgresql time to a System.DateTime.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BasicBackendToNativeTypeConverter.ToMoney(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo,System.String,System.Int16,System.Int32)">
            <summary>
            Convert a postgresql money to a System.Decimal.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BasicNativeToBackendTypeConverter">
            <summary>
            Provide event handlers to convert the basic native supported data types from
            native form to backend representation.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BasicNativeToBackendTypeConverter.ToBinary(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo,System.Object,System.Boolean)">
            <summary>
            Binary data.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BasicNativeToBackendTypeConverter.ToBoolean(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo,System.Object,System.Boolean)">
            <summary>
            Convert to a postgresql boolean.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BasicNativeToBackendTypeConverter.ToBit(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo,System.Object,System.Boolean)">
            <summary>
            Convert to a postgresql bit.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BasicNativeToBackendTypeConverter.ToDateTime(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo,System.Object,System.Boolean)">
            <summary>
            Convert to a postgresql timestamp.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BasicNativeToBackendTypeConverter.ToDate(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo,System.Object,System.Boolean)">
            <summary>
            Convert to a postgresql date.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BasicNativeToBackendTypeConverter.ToTime(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo,System.Object,System.Boolean)">
            <summary>
            Convert to a postgresql time.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BasicNativeToBackendTypeConverter.ToMoney(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo,System.Object,System.Boolean)">
            <summary>
            Convert to a postgres money.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BasicNativeToBackendTypeConverter.ToSingleDouble(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo,System.Object,System.Boolean)">
            <summary>
            Convert to a postgres double with maximum precision.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ExtendedBackendToNativeTypeConverter">
            <summary>
            Provide event handlers to convert extended native supported data types from their backend
            text representation to a .NET object.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ExtendedBackendToNativeTypeConverter.ToPoint(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo,System.String,System.Int16,System.Int32)">
            <summary>
            Convert a postgresql point to a System.NpgsqlPoint.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ExtendedBackendToNativeTypeConverter.ToBox(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo,System.String,System.Int16,System.Int32)">
            <summary>
            Convert a postgresql point to a System.RectangleF.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ExtendedBackendToNativeTypeConverter.ToLSeg(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo,System.String,System.Int16,System.Int32)">
            <summary>
            LDeg.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ExtendedBackendToNativeTypeConverter.ToPath(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo,System.String,System.Int16,System.Int32)">
            <summary>
            Path.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ExtendedBackendToNativeTypeConverter.ToPolygon(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo,System.String,System.Int16,System.Int32)">
            <summary>
            Polygon.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ExtendedBackendToNativeTypeConverter.ToCircle(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo,System.String,System.Int16,System.Int32)">
            <summary>
            Circle.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ExtendedBackendToNativeTypeConverter.ToInet(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo,System.String,System.Int16,System.Int32)">
            <summary>
            Inet.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ExtendedBackendToNativeTypeConverter.ToMacAddress(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo,System.String,System.Int16,System.Int32)">
            <summary>
            MAC Address.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ExtendedBackendToNativeTypeConverter.ToInterval(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo,System.String,System.Int16,System.Int32)">
            <summary>
            interval
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ExtendedNativeToBackendTypeConverter">
            <summary>
            Provide event handlers to convert extended native supported data types from
            native form to backend representation.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ExtendedNativeToBackendTypeConverter.ToPoint(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo,System.Object,System.Boolean)">
            <summary>
            Point.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ExtendedNativeToBackendTypeConverter.ToBox(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo,System.Object,System.Boolean)">
            <summary>
            Box.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ExtendedNativeToBackendTypeConverter.ToLSeg(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo,System.Object,System.Boolean)">
            <summary>
            LSeg.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ExtendedNativeToBackendTypeConverter.ToPath(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo,System.Object,System.Boolean)">
            <summary>
            Open path.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ExtendedNativeToBackendTypeConverter.ToPolygon(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo,System.Object,System.Boolean)">
            <summary>
            Polygon.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ExtendedNativeToBackendTypeConverter.ToMacAddress(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo,System.Object,System.Boolean)">
            <summary>
            Convert to a postgres MAC Address.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ExtendedNativeToBackendTypeConverter.ToCircle(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo,System.Object,System.Boolean)">
            <summary>
            Circle.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ExtendedNativeToBackendTypeConverter.ToIPAddress(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo,System.Object,System.Boolean)">
            <summary>
            Convert to a postgres inet.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ExtendedNativeToBackendTypeConverter.ToInterval(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo,System.Object,System.Boolean)">
            <summary>
            Convert to a postgres interval
            </summary>
        </member>
        <member name="T:Revenj.Utility.Sorting">
            <summary>
            Sorting algorithms
            </summary>
        </member>
        <member name="M:Revenj.Utility.Sorting.TopologicalSort``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``0}})">
            <summary>
            Topological ordering of directed graph.
            </summary>
            <typeparam name="T">Node type</typeparam>
            <param name="nodes">Graph nodes</param>
            <param name="dependencies">Node dependencies</param>
            <returns>Sorted nodes</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Integration.Mef.ExportConfigurationBuilder">
            <summary>
            Configures an Export on an Autofac component.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Integration.Mef.ExportConfigurationBuilder.As``1">
            <summary>
            Export the component under typed contract <typeparamref name="TContract"/>.
            </summary>
            <typeparam name="TContract">Contract type.</typeparam>
            <returns>Builder for additional configuration.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Integration.Mef.ExportConfigurationBuilder.AsNamed``1(System.String)">
            <summary>
            Export the component under named contract <paramref name="name"/>.
            </summary>
            <typeparam name="TExportedValue">Exported value type.</typeparam>
            <param name="name">Contract name.</param>
            <returns>Builder for additional configuration.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Integration.Mef.ExportConfigurationBuilder.WithMetadata(System.String,System.Object)">
            <summary>
            Add metadata to the export.
            </summary>
            <param name="key">Metadata key.</param>
            <param name="value">Metadata value.</param>
            <returns>Builder for additional configuration.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Integration.Mef.ExportConfigurationBuilder.WithMetadata(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
            <summary>
            Add metadata to the export.
            </summary>
            <param name="metadata">Metadata.</param>
            <returns>Builder for additional configuration.</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentRegistrationLifetimeDecorator">
            <summary>
            Wraps a component registration, switching its lifetime.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.Util.ReflectionExtensions">
            <summary>
            Extension methods for reflection-related types.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.Util.ReflectionExtensions.TryGetDeclaringProperty(System.Reflection.ParameterInfo,System.Reflection.PropertyInfo@)">
            <summary>
            Maps from a property-set-value parameter to the declaring property.
            </summary>
            <param name="pi">Parameter to the property setter.</param>
            <param name="prop">The property info on which the setter is specified.</param>
            <returns>True if the parameter is a property setter.</returns>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlSchema">
            <summary>
            Provides the underlying mechanism for reading schema information.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlSchema.#ctor(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection)">
            <summary>
            Creates an NpgsqlSchema that can read schema information from the database.
            </summary>
            <param name="connection">An open database connection for reading metadata.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlSchema.GetMetaDataCollections">
            <summary>
            Returns the MetaDataCollections that lists all possible collections.
            </summary>
            <returns>The MetaDataCollections</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlSchema.GetRestrictions">
            <summary>
            Returns the Restrictions that contains the meaning and position of the values in the restrictions array.
            </summary>
            <returns>The Restrictions</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlSchema.GetDatabases(System.String[])">
            <summary>
            Returns the Databases that contains a list of all accessable databases.
            </summary>
            <param name="restrictions">The restrictions to filter the collection.</param>
            <returns>The Databases</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlSchema.GetTables(System.String[])">
            <summary>
            Returns the Tables that contains table and view names and the database and schema they come from.
            </summary>
            <param name="restrictions">The restrictions to filter the collection.</param>
            <returns>The Tables</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlSchema.GetColumns(System.String[])">
            <summary>
            Returns the Columns that contains information about columns in tables. 
            </summary>
            <param name="restrictions">The restrictions to filter the collection.</param>
            <returns>The Columns.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlSchema.GetViews(System.String[])">
            <summary>
            Returns the Views that contains view names and the database and schema they come from.
            </summary>
            <param name="restrictions">The restrictions to filter the collection.</param>
            <returns>The Views</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlSchema.GetUsers(System.String[])">
            <summary>
            Returns the Users containing user names and the sysid of those users.
            </summary>
            <param name="restrictions">The restrictions to filter the collection.</param>
            <returns>The Users.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectionStringBuilder.Clone">
            <summary>
            Return an exact copy of this NpgsqlConnectionString.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectionStringBuilder.SetValue(System.String,System.Object)">
            <summary>
            This function will set value for known key, both private member and base[key].
            </summary>
            <param name="keyword"></param>
            <param name="value"></param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectionStringBuilder.SetValue(Revenj.DatabasePersistence.Postgres.Npgsql.Keywords,System.Object)">
            <summary>
            The function will modify private member only, not base[key].
            </summary>
            <param name="keyword"></param>
            <param name="value"></param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectionStringBuilder.Clear">
            <summary>
            Clear the member and assign them to the default value.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectionStringBuilder.Compatible">
            <summary>
            Compatibilty version. When possible, behaviour caused by breaking changes will be preserved
            if this version is less than that where the breaking change was introduced.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnectionStringBuilder.Item(System.String)">
            <summary>
            Case insensative accessor for indivual connection string values.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyIn">
            <summary>
            Represents a PostgreSQL COPY FROM STDIN operation with a corresponding SQL statement
            to execute against a PostgreSQL database
            and an associated stream used to read data from (if provided by user)
            or for writing it (when generated by driver).
            Eg. new NpgsqlCopyIn("COPY mytable FROM STDIN", connection, streamToRead).Start();
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyIn.#ctor(System.String,Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection)">
            <summary>
            Creates NpgsqlCommand to run given query upon Start(). Data for the requested COPY IN operation can then be written to CopyData stream followed by a call to End() or Cancel().
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyIn.#ctor(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand,Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection)">
            <summary>
            Given command is run upon Start(). Data for the requested COPY IN operation can then be written to CopyData stream followed by a call to End() or Cancel().
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyIn.#ctor(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand,Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnection,System.IO.Stream)">
            <summary>
            Given command is executed upon Start() and all data from fromStream is passed to it as copy data.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyIn.FieldIsBinary(System.Int32)">
            <summary>
            Returns true if this operation is currently active and field at given location is in binary format.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyIn.Start">
            <summary>
            Command specified upon creation is executed as a non-query.
            If CopyStream is set upon creation, it will be flushed to server as copy data, and operation will be finished immediately.
            Otherwise the CopyStream member can be used for writing copy data to server and operation finished with a call to End() or Cancel().
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyIn.End">
            <summary>
            Called after writing all data to CopyStream to successfully complete this copy operation.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyIn.Cancel(System.String)">
            <summary>
            Withdraws an already started copy operation. The operation will fail with given error message.
            Will do nothing if current operation is not active.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyIn.IsActive">
            <summary>
            Returns true if the connection is currently reserved for this operation.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyIn.CopyStream">
            <summary>
            The stream provided by user or generated upon Start().
            User may provide a stream to constructor; it is used to pass to server all data read from it.
            Otherwise, call to Start() sets this to a writable NpgsqlCopyInStream that passes all data written to it to server.
            In latter case this is only available while the copy operation is active and null otherwise.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyIn.IsBinary">
            <summary>
            Returns true if this operation is currently active and in binary format.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyIn.FieldCount">
            <summary>
            Returns number of fields expected on each input row if this operation is currently active, otherwise -1
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyIn.NpgsqlCommand">
            <summary>
            The Command used to execute this copy operation.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyIn.CopyBufferSize">
            <summary>
            Set before a COPY IN query to define size of internal buffer for reading from given CopyStream.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.RegistrationExtensions">
            <summary>
            Adds registration syntax to the <see cref="T:Revenj.Extensibility.Autofac.ContainerBuilder"/> type.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.RegisterModule(Revenj.Extensibility.Autofac.ContainerBuilder,Revenj.Extensibility.Autofac.Core.IModule)">
            <summary>
            Add a module to the container.
            </summary>
            <param name="builder">The builder to register the module with.</param>
            <param name="module">The module to add.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.RegisterModule``1(Revenj.Extensibility.Autofac.ContainerBuilder)">
            <summary>
            Add a module to the container.
            </summary>
            <param name="builder">The builder to register the module with.</param>
            <typeparam name="TModule">The module to add.</typeparam>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.RegisterComponent(Revenj.Extensibility.Autofac.ContainerBuilder,Revenj.Extensibility.Autofac.Core.IComponentRegistration)">
            <summary>
            Add a component to the container.
            </summary>
            <param name="builder">The builder to register the component with.</param>
            <param name="registration">The component to add.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.RegisterSource(Revenj.Extensibility.Autofac.ContainerBuilder,Revenj.Extensibility.Autofac.Core.IRegistrationSource)">
            <summary>
            Add a registration source to the container.
            </summary>
            <param name="builder">The builder to register the registration source via.</param>
            <param name="registrationSource">The registration source to add.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.RegisterInstance``1(Revenj.Extensibility.Autofac.ContainerBuilder,``0)">
            <summary>
            Register an instance as a component.
            </summary>
            <typeparam name="T">The type of the instance.</typeparam>
            <param name="builder">Container builder.</param>
            <param name="instance">The instance to register.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
            <remarks>If no services are explicitly specified for the instance, the
            static type <typeparamref name="T"/> will be used as the default service (i.e. *not* <code>instance.GetType()</code>).</remarks>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.RegisterType``1(Revenj.Extensibility.Autofac.ContainerBuilder)">
            <summary>
            Register a component to be created through reflection.
            </summary>
            <typeparam name="TImplementor">The type of the component implementation.</typeparam>
            <param name="builder">Container builder.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.RegisterType(Revenj.Extensibility.Autofac.ContainerBuilder,System.Type)">
            <summary>
            Register a component to be created through reflection.
            </summary>
            <param name="implementationType">The type of the component implementation.</param>
            <param name="builder">Container builder.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.Register``1(Revenj.Extensibility.Autofac.ContainerBuilder,System.Func{Revenj.Extensibility.Autofac.IComponentContext,``0})">
            <summary>
            Register a delegate as a component.
            </summary>
            <typeparam name="T">The type of the instance.</typeparam>
            <param name="builder">Container builder.</param>
            <param name="delegate">The delegate to register.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.Register``1(Revenj.Extensibility.Autofac.ContainerBuilder,System.Func{Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},``0})">
            <summary>
            Register a delegate as a component.
            </summary>
            <typeparam name="T">The type of the instance.</typeparam>
            <param name="builder">Container builder.</param>
            <param name="delegate">The delegate to register.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.RegisterGeneric(Revenj.Extensibility.Autofac.ContainerBuilder,System.Type)">
            <summary>
            Register an un-parameterised generic type, e.g. Repository&lt;&gt;.
            Concrete types will be made as they are requested, e.g. with Resolve&lt;Repository&lt;int&gt;&gt;().
            </summary>
            <param name="builder">Container builder.</param>
            <param name="implementor">The open generic implementation type.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.PreserveExistingDefaults``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2})">
            <summary>
            Specifies that the component being registered should only be made the default for services
            that have not already been registered.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TSingleRegistrationStyle">Registration style.</typeparam>
            <typeparam name="TActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to set service mapping on.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.PreserveExistingDefaults``2(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,Revenj.Extensibility.Autofac.Features.Scanning.ScanningActivatorData,``1})">
            <summary>
            Specifies that the components being registered should only be made the default for services
            that have not already been registered.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TRegistrationStyle">Registration style.</typeparam>
            <param name="registration">Registration to set service mapping on.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.RegisterAssemblyTypes(Revenj.Extensibility.Autofac.ContainerBuilder,System.Reflection.Assembly[])">
            <summary>
            Register the types in an assembly.
            </summary>
            <param name="builder">Container builder.</param>
            <param name="assemblies">The assemblies from which to register types.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.Where``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Func{System.Type,System.Boolean})">
            <summary>
            Specifies a subset of types to register from a scanned assembly.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TRegistrationStyle">Registration style.</typeparam>
            <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to filter types from.</param>
            <param name="predicate">Predicate that returns true for types to register.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.As``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Func{System.Type,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Service}})">
            <summary>
            Specifies how a type from a scanned assembly is mapped to a service.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TRegistrationStyle">Registration style.</typeparam>
            <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to set service mapping on.</param>
            <param name="serviceMapping">Function mapping types to services.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.As``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Func{System.Type,Revenj.Extensibility.Autofac.Core.Service})">
            <summary>
            Specifies how a type from a scanned assembly is mapped to a service.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TRegistrationStyle">Registration style.</typeparam>
            <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to set service mapping on.</param>
            <param name="serviceMapping">Function mapping types to services.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.As``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Func{System.Type,System.Type})">
            <summary>
            Specifies how a type from a scanned assembly is mapped to a service.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TRegistrationStyle">Registration style.</typeparam>
            <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to set service mapping on.</param>
            <param name="serviceMapping">Function mapping types to services.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.As``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Type}})">
            <summary>
            Specifies how a type from a scanned assembly is mapped to a service.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TRegistrationStyle">Registration style.</typeparam>
            <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to set service mapping on.</param>
            <param name="serviceMapping">Function mapping types to services.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.AsSelf``1(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,Revenj.Extensibility.Autofac.Features.Scanning.ScanningActivatorData,Revenj.Extensibility.Autofac.Builder.DynamicRegistrationStyle})">
            <summary>
            Specifies that a type from a scanned assembly provides its own concrete type as a service.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <param name="registration">Registration to set service mapping on.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.AsSelf``2(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,Revenj.Extensibility.Autofac.Builder.SingleRegistrationStyle})">
            <summary>
            Specifies that a type provides its own concrete type as a service.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TConcreteActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to set service mapping on.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.AsSelf``1(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,Revenj.Extensibility.Autofac.Builder.ReflectionActivatorData,Revenj.Extensibility.Autofac.Builder.DynamicRegistrationStyle})">
            <summary>
            Specifies that a type provides its own concrete type as a service.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <param name="registration">Registration to set service mapping on.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.WithMetadata``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}}})">
            <summary>
            Specify how a type from a scanned assembly provides metadata.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TRegistrationStyle">Registration style.</typeparam>
            <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to set metadata on.</param>
            <param name="metadataMapping">A function mapping the type to a list of metadata items.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.WithMetadataFrom``1(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{System.Object,Revenj.Extensibility.Autofac.Features.Scanning.ScanningActivatorData,Revenj.Extensibility.Autofac.Builder.DynamicRegistrationStyle})">
            <summary>
            Use the properties of an attribute (or interface implemented by an attribute) on the scanned type
            to provide metadata values.
            </summary>
            <remarks>Inherited attributes are supported; however, there must be at most one matching attribute
            in the inheritance chain.</remarks>
            <typeparam name="TAttribute">The attribute applied to the scanned type.</typeparam>
            <param name="registration">Registration to set metadata on.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.WithMetadata``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.String,System.Func{System.Type,System.Object})">
            <summary>
            Specify how a type from a scanned assembly provides metadata.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TRegistrationStyle">Registration style.</typeparam>
            <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to set service mapping on.</param>
            <param name="metadataKey">Key of the metadata item.</param>
            <param name="metadataValueMapping">A function retrieving the value of the item from the component type.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.Named``1(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{System.Object,Revenj.Extensibility.Autofac.Features.Scanning.ScanningActivatorData,Revenj.Extensibility.Autofac.Builder.DynamicRegistrationStyle},System.Func{System.Type,System.String})">
            <summary>
            Specifies how a type from a scanned assembly is mapped to a named service.
            </summary>
            <param name="registration">Registration to set service mapping on.</param>
            <typeparam name="TService">Service type provided by the component.</typeparam>
            <param name="serviceNameMapping">Function mapping types to service names.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.Named``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Func{System.Type,System.String},System.Type)">
            <summary>
            Specifies how a type from a scanned assembly is mapped to a named service.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TRegistrationStyle">Registration style.</typeparam>
            <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to set service mapping on.</param>
            <param name="serviceType">Service type provided by the component.</param>
            <param name="serviceNameMapping">Function mapping types to service names.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.Keyed``1(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{System.Object,Revenj.Extensibility.Autofac.Features.Scanning.ScanningActivatorData,Revenj.Extensibility.Autofac.Builder.DynamicRegistrationStyle},System.Func{System.Type,System.Object})">
            <summary>
            Specifies how a type from a scanned assembly is mapped to a keyed service.
            </summary>
            <param name="registration">Registration to set service mapping on.</param>
            <typeparam name="TService">Service type provided by the component.</typeparam>
            <param name="serviceKeyMapping">Function mapping types to service keys.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.Keyed``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Func{System.Type,System.Object},System.Type)">
            <summary>
            Specifies how a type from a scanned assembly is mapped to a keyed service.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TRegistrationStyle">Registration style.</typeparam>
            <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to set service mapping on.</param>
            <param name="serviceType">Service type provided by the component.</param>
            <param name="serviceKeyMapping">Function mapping types to service keys.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.AsImplementedInterfaces``1(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,Revenj.Extensibility.Autofac.Features.Scanning.ScanningActivatorData,Revenj.Extensibility.Autofac.Builder.DynamicRegistrationStyle})">
            <summary>
            Specifies that a type from a scanned assembly is registered as providing all of its
            implemented interfaces.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <param name="registration">Registration to set service mapping on.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.AsImplementedInterfaces``2(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,Revenj.Extensibility.Autofac.Builder.SingleRegistrationStyle})">
            <summary>
            Specifies that a type is registered as providing all of its implemented interfaces.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TConcreteActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to set service mapping on.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.AsImplementedInterfaces``1(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,Revenj.Extensibility.Autofac.Builder.ReflectionActivatorData,Revenj.Extensibility.Autofac.Builder.DynamicRegistrationStyle})">
            <summary>
            Specifies that a type is registered as providing all of its implemented interfaces.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <param name="registration">Registration to set service mapping on.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.FindConstructorsWith``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Reflection.BindingFlags)">
            <summary>
            Set the policy used to find candidate constructors on the implementation type.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
            <typeparam name="TStyle">Registration style.</typeparam>
            <param name="registration">Registration to set policy on.</param>
            <param name="bindingFlags">Binding flags used when searching for constructors.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.FindConstructorsWith``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},Revenj.Extensibility.Autofac.Core.Activators.Reflection.IConstructorFinder)">
            <summary>
            Set the policy used to find candidate constructors on the implementation type.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
            <typeparam name="TStyle">Registration style.</typeparam>
            <param name="registration">Registration to set policy on.</param>
            <param name="constructorFinder">Policy to be used when searching for constructors.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.UsingConstructor``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Type[])">
            <summary>
            Set the policy used to select from available constructors on the implementation type.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
            <typeparam name="TStyle">Registration style.</typeparam>
            <param name="registration">Registration to set policy on.</param>
            <param name="signature">Constructor signature to match.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.UsingConstructor``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},Revenj.Extensibility.Autofac.Core.Activators.Reflection.IConstructorSelector)">
            <summary>
            Set the policy used to select from available constructors on the implementation type.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TStyle">Registration style.</typeparam>
            <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to set policy on.</param>
            <param name="constructorSelector">Policy to be used when selecting a constructor.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.WithParameter``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.String,System.Object)">
            <summary>
            Configure an explicit value for a constructor parameter.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TStyle">Registration style.</typeparam>
            <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to set parameter on.</param>
            <param name="parameterName">Name of a constructor parameter on the target type.</param>
            <param name="parameterValue">Value to supply to the parameter.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.WithParameter``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},Revenj.Extensibility.Autofac.Core.Parameter)">
            <summary>
            Configure an explicit value for a constructor parameter.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TStyle">Registration style.</typeparam>
            <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to set parameter on.</param>
            <param name="parameter">The parameter to supply to the constructor.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.WithParameter``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Func{System.Reflection.ParameterInfo,Revenj.Extensibility.Autofac.IComponentContext,System.Boolean},System.Func{System.Reflection.ParameterInfo,Revenj.Extensibility.Autofac.IComponentContext,System.Object})">
            <summary>
            Configure an explicit value for a constructor parameter.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TStyle">Registration style.</typeparam>
            <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to set parameter on.</param>
            <param name="parameterSelector">A predicate selecting the parameter to set.</param>
            <param name="valueProvider"></param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.WithParameters``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Configure explicit values for constructor parameters.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TStyle">Registration style.</typeparam>
            <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to set parameter on.</param>
            <param name="parameters">The parameters to supply to the constructor.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.WithProperty``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.String,System.Object)">
            <summary>
            Configure an explicit value for a property.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TStyle">Registration style.</typeparam>
            <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to set property on.</param>
            <param name="propertyName">Name of a property on the target type.</param>
            <param name="propertyValue">Value to supply to the property.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.WithProperty``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},Revenj.Extensibility.Autofac.Core.Parameter)">
            <summary>
            Configure an explicit value for a property.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TStyle">Registration style.</typeparam>
            <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to set parameter on.</param>
            <param name="property">The property to supply.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.WithProperties``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Configure explicit values for properties.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TStyle">Registration style.</typeparam>
            <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to set parameter on.</param>
            <param name="properties">The properties to supply.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.Targeting``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},Revenj.Extensibility.Autofac.Core.IComponentRegistration)">
            <summary>
            Sets the target of the registration (used for metadata generation.)
            </summary>
            <typeparam name="TLimit">The type of the limit.</typeparam>
            <typeparam name="TActivatorData">The type of the activator data.</typeparam>
            <typeparam name="TSingleRegistrationStyle">Registration style</typeparam>
            <param name="registration">Registration to set target for.</param>
            <param name="target">The target.</param>
            <returns>
            Registration builder allowing the registration to be configured.
            </returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.OnRegistered``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Action{Revenj.Extensibility.Autofac.Core.ComponentRegisteredEventArgs})">
            <summary>
            Provide a handler to be called when the component is registered.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TSingleRegistrationStyle">Registration style.</typeparam>
            <typeparam name="TActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration add handler to.</param>
            <param name="handler">The handler.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.OnRegistered``2(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,Revenj.Extensibility.Autofac.Features.Scanning.ScanningActivatorData,``1},System.Action{Revenj.Extensibility.Autofac.Core.ComponentRegisteredEventArgs})">
            <summary>
            Provide a handler to be called when the component is registred.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TRegistrationStyle">Registration style.</typeparam>
            <param name="registration">Registration add handler to.</param>
            <param name="handler">The handler.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.AsClosedTypesOf``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Type)">
            <summary>
            Specifies that a type from a scanned assembly is registered if it implements an interface
            that closes the provided open generic interface type.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TRegistrationStyle">Registration style.</typeparam>
            <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to set service mapping on.</param>
            <param name="openGenericServiceType">The open generic interface or base class type for which implementations will be found.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.AssignableTo``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Type)">
            <summary>
            Filters the scanned types to include only those assignable to the provided
            type.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TRegistrationStyle">Registration style.</typeparam>
            <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to filter types from.</param>
            <param name="type">The type or interface which all classes must be assignable from.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.AssignableTo``1(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{System.Object,Revenj.Extensibility.Autofac.Features.Scanning.ScanningActivatorData,Revenj.Extensibility.Autofac.Builder.DynamicRegistrationStyle})">
            <summary>
            Filters the scanned types to include only those assignable to the provided
            type.
            </summary>
            <param name="registration">Registration to filter types from.</param>
            <typeparam name="T">The type or interface which all classes must be assignable from.</typeparam>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.Except``1(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{System.Object,Revenj.Extensibility.Autofac.Features.Scanning.ScanningActivatorData,Revenj.Extensibility.Autofac.Builder.DynamicRegistrationStyle})">
            <summary>
            Filters the scanned types to exclude the provided type.
            </summary>
            <param name="registration">Registration to filter types from.</param>
            <typeparam name="T">The concrete type to exclude.</typeparam>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.Except``1(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{System.Object,Revenj.Extensibility.Autofac.Features.Scanning.ScanningActivatorData,Revenj.Extensibility.Autofac.Builder.DynamicRegistrationStyle},System.Action{Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,Revenj.Extensibility.Autofac.Builder.ConcreteReflectionActivatorData,Revenj.Extensibility.Autofac.Builder.SingleRegistrationStyle}})">
            <summary>
            Filters the scanned types to exclude the provided type, providing specific configuration for
            the excluded type.
            </summary>
            <param name="registration">Registration to filter types from.</param>
            <param name="customisedRegistration">Registration for the excepted type.</param>
            <typeparam name="T">The concrete type to exclude.</typeparam>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.InNamespaceOf``1(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{System.Object,Revenj.Extensibility.Autofac.Features.Scanning.ScanningActivatorData,Revenj.Extensibility.Autofac.Builder.DynamicRegistrationStyle})">
            <summary>
            Filters the scanned types to include only those in the namespace of the provided type
            or one of its sub-namespaces.
            </summary>
            <param name="registration">Registration to filter types from.</param>
            <typeparam name="T">A type in the target namespace.</typeparam>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.InNamespace``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.String)">
            <summary>
            Filters the scanned types to include only those in the provided namespace
            or one of its sub-namespaces.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TRegistrationStyle">Registration style.</typeparam>
            <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to filter types from.</param>
            <param name="ns">The namespace from which types will be selected.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.RegisterAdapter``2(Revenj.Extensibility.Autofac.ContainerBuilder,System.Func{Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},``0,``1})">
            <summary>
            Adapt all components implementing service <typeparamref name="TFrom"/>
            to provide <typeparamref name="TTo"/> using the provided <paramref name="adapter"/>
            function.
            </summary>
            <typeparam name="TFrom">Service type to adapt from.</typeparam>
            <typeparam name="TTo">Service type to adapt to. Must not be the
            same as <typeparamref name="TFrom"/>.</typeparam>
            <param name="builder">Container builder.</param>
            <param name="adapter">Function adapting <typeparamref name="TFrom"/> to
            service <typeparamref name="TTo"/>, given the context and parameters.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.RegisterAdapter``2(Revenj.Extensibility.Autofac.ContainerBuilder,System.Func{Revenj.Extensibility.Autofac.IComponentContext,``0,``1})">
            <summary>
            Adapt all components implementing service <typeparamref name="TFrom"/>
            to provide <typeparamref name="TTo"/> using the provided <paramref name="adapter"/>
            function.
            </summary>
            <typeparam name="TFrom">Service type to adapt from.</typeparam>
            <typeparam name="TTo">Service type to adapt to. Must not be the
            same as <typeparamref name="TFrom"/>.</typeparam>
            <param name="builder">Container builder.</param>
            <param name="adapter">Function adapting <typeparamref name="TFrom"/> to
            service <typeparamref name="TTo"/>, given the context.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.RegisterAdapter``2(Revenj.Extensibility.Autofac.ContainerBuilder,System.Func{``0,``1})">
            <summary>
            Adapt all components implementing service <typeparamref name="TFrom"/>
            to provide <typeparamref name="TTo"/> using the provided <paramref name="adapter"/>
            function.
            </summary>
            <typeparam name="TFrom">Service type to adapt from.</typeparam>
            <typeparam name="TTo">Service type to adapt to. Must not be the
            same as <typeparamref name="TFrom"/>.</typeparam>
            <param name="builder">Container builder.</param>
            <param name="adapter">Function adapting <typeparamref name="TFrom"/> to
            service <typeparamref name="TTo"/>.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.RegisterGenericDecorator(Revenj.Extensibility.Autofac.ContainerBuilder,System.Type,System.Type,System.Object,System.Object)">
            <summary>
            Decorate all components implementing open generic service <paramref name="decoratedServiceType"/>.
            The <paramref name="fromKey"/> and <paramref name="toKey"/> parameters must be different values.
            </summary>
            <param name="builder">Container builder.</param>
            <param name="decoratedServiceType">Service type being decorated. Must be an open generic type.</param>
            <param name="fromKey">Service key or name associated with the components being decorated.</param>
            <param name="toKey">Service key or name given to the decorated components.</param>
            <param name="decoratorType">The type of the decorator. Must be an open generic type, and accept a parameter
            of type <paramref name="decoratedServiceType"/>, which will be set to the instance being decorated.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.RegisterDecorator``1(Revenj.Extensibility.Autofac.ContainerBuilder,System.Func{Revenj.Extensibility.Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},``0,``0},System.Object,System.Object)">
            <summary>
            Decorate all components implementing service <typeparamref name="TService"/>
            using the provided <paramref name="decorator"/> function.
            The <paramref name="fromKey"/> and <paramref name="toKey"/> parameters must be different values.
            </summary>
            <typeparam name="TService">Service type being decorated.</typeparam>
            <param name="builder">Container builder.</param>
            <param name="decorator">Function decorating a component instance that provides
            <typeparamref name="TService"/>, given the context and parameters.</param>
            <param name="fromKey">Service key or name associated with the components being decorated.</param>
            <param name="toKey">Service key or name given to the decorated components.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.RegisterDecorator``1(Revenj.Extensibility.Autofac.ContainerBuilder,System.Func{Revenj.Extensibility.Autofac.IComponentContext,``0,``0},System.Object,System.Object)">
            <summary>
            Decorate all components implementing service <typeparamref name="TService"/>
            using the provided <paramref name="decorator"/> function.
            The <paramref name="fromKey"/> and <paramref name="toKey"/> parameters must be different values.
            </summary>
            <typeparam name="TService">Service type being decorated.</typeparam>
            <param name="builder">Container builder.</param>
            <param name="decorator">Function decorating a component instance that provides
            <typeparamref name="TService"/>, given the context.</param>
            <param name="fromKey">Service key or name associated with the components being decorated.</param>
            <param name="toKey">Service key or name given to the decorated components.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.RegisterDecorator``1(Revenj.Extensibility.Autofac.ContainerBuilder,System.Func{``0,``0},System.Object,System.Object)">
            <summary>
            Decorate all components implementing service <typeparamref name="TService"/>
            using the provided <paramref name="decorator"/> function.
            The <paramref name="fromKey"/> and <paramref name="toKey"/> parameters must be different values.
            </summary>
            <typeparam name="TService">Service type being decorated.</typeparam>
            <param name="builder">Container builder.</param>
            <param name="decorator">Function decorating a component instance that provides
            <typeparamref name="TService"/>.</param>
            <param name="fromKey">Service key or name associated with the components being decorated.</param>
            <param name="toKey">Service key or name given to the decorated components.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.RegistrationExtensions.OnRelease``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Action{``0})">
            <summary>
            Run a supplied action instead of disposing instances when they're no
            longer required.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TActivatorData">Activator data type.</typeparam>
            <typeparam name="TRegistrationStyle">Registration style.</typeparam>
            <param name="registration">Registration to set release action for.</param>
            <param name="releaseAction">An action to perform instead of disposing the instance.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
            <remarks>Only one release action can be configured per registration.</remarks>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.PropertyWiringFlags">
            <summary>
            Options that can be applied when autowiring properties on a component. (Multiple options can
            be specified using bitwise 'or' - e.g. AllowCircularDependencies | PreserveSetValues.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.PropertyWiringFlags.Default">
            <summary>
            Default behavior. Circular dependencies are not allowed; existing non-default
            property values are overwritten.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.PropertyWiringFlags.AllowCircularDependencies">
            <summary>
            Allows property-property and property-constructor circular dependency wiring.
            This flag moves property wiring from the Activating to the Activated event.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.PropertyWiringFlags.PreserveSetValues">
            <summary>
            If specified, properties that already have a non-default value will be left
            unchanged in the wiring operation.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Features.Metadata.Meta`1">
            <summary>
            Provides a value along with a dictionary of metadata describing the value.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.Metadata.Meta`1.#ctor(`0,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Create a new instance.
            </summary>
            <param name="value">The value described by the instance.</param>
            <param name="metadata">The metadata describing the value.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Features.Metadata.Meta`1.Value">
            <summary>
            The value described by <see cref="P:Revenj.Extensibility.Autofac.Features.Metadata.Meta`1.Metadata"/>.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Features.Metadata.Meta`1.Metadata">
            <summary>
            Metadata describing the value.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Features.Collections.CollectionRegistrationExtensions">
            <summary>
            Internal implementation of the RegisterCollection/MemberOf-style collection feature.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Registration.CopyOnWriteRegistry">
            <summary>
            Delegates registration lookups to a specified registry. When write operations are applied,
            initialises a new 'writeable' registry.
            </summary>
            <remarks>
            Safe for concurrent access by multiple readers. Write operations are single-threaded.
            </remarks>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.NamedPropertyParameter">
            <summary>
            A property identified by name. When applied to a reflection-based
            component, the name will be matched against property names.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.NamedPropertyParameter.#ctor(System.String,System.Object)">
            <summary>
            Create a <see cref="T:Revenj.Extensibility.Autofac.Core.NamedPropertyParameter"/> with the specified constant value.
            </summary>
            <param name="name">The name of the property.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.NamedPropertyParameter.Name">
            <summary>
            The name of the property.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Disposer">
            <summary>
            Maintains a set of objects to dispose, and disposes them in the reverse order
            from which they were added when the Disposer is itself disposed.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Core.Disposer._items">
            <summary>
            Contents all implement IDisposable.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Disposer.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Disposer.AddInstanceForDisposal(System.IDisposable)">
            <summary>
            Adds an object to the disposer. When the disposer is
            disposed, so will the object be.
            </summary>
            <param name="instance">The instance.</param>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.ActivatingEventArgs`1">
            <summary>
            Fired after the construction of an instance but before that instance
            is shared with any other or any members are invoked on it.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.IActivatingEventArgs`1">
            <summary>
            Fired after the construction of an instance but before that instance
            is shared with any other or any members are invoked on it.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.IActivatingEventArgs`1.ReplaceInstance(System.Object)">
            <summary>
            The instance can be replaced if needed, e.g. by an interface proxy.
            </summary>
            <param name="instance">The object to use instead of the activated instance.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IActivatingEventArgs`1.Context">
            <summary>
            The context in which the activation occurred.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IActivatingEventArgs`1.Component">
            <summary>
            The component providing the instance.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IActivatingEventArgs`1.Instance">
            <summary>
            The instance that will be used to satisfy the request.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.IActivatingEventArgs`1.Parameters">
            <summary>
            The parameters supplied to the activator.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.ActivatingEventArgs`1.#ctor(Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.IComponentContext,Revenj.Extensibility.Autofac.Core.IComponentRegistration,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Core.ActivatedEventArgs`1"/> class.
            </summary>
            <param name="service">Service which is activating</param>
            <param name="context">The context.</param>
            <param name="component">The component.</param>
            <param name="parameters">The parameters.</param>
            <param name="instance">The instance.</param>        
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.ActivatingEventArgs`1.Revenj#Extensibility#Autofac#Core#IActivatingEventArgs{T}#ReplaceInstance(System.Object)">
            <summary>
            The instance can be replaced if needed, e.g. by an interface proxy.
            </summary>
            <param name="instance">The object to use instead of the activated instance.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.ActivatingEventArgs`1.Service">
            <summary>
            The service which is activating.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.ActivatingEventArgs`1.Context">
            <summary>
            The context in which the activation occurred.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.ActivatingEventArgs`1.Component">
            <summary>
            The component providing the instance.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.ActivatingEventArgs`1.Instance">
            <summary>
            The instance that will be used to satisfy the request.
            </summary>
            <remarks>
            The instance can be replaced if needed, e.g. by an interface proxy.
            </remarks>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.ActivatingEventArgs`1.Parameters">
            <summary>
            The parameters supplied to the activator.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.ModuleElement">
            <summary>
            Element describing a module registration.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ModuleElement.Type">
            <summary>
            Gets the type of the module. Must expose <see cref="!:IModule"/>.
            </summary>
            <value>The type.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ModuleElement.Parameters">
            <summary>
            Gets the parameters used to construct the component.
            </summary>
            <value>The parameters.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ModuleElement.Properties">
            <summary>
            Gets the properties to be explicitly set on the component.
            </summary>
            <value>The explicit properties.</value>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.ComponentElement">
            <summary>
            Element describing a component registration.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ComponentElement.Type">
            <summary>
            Gets the type of the component.
            </summary>
            <value>The type.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ComponentElement.Service">
            <summary>
            Gets the service exposed by the component. For multiple-service components,
            use the services element instead.
            </summary>
            <value>The service.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ComponentElement.MemberOf">
            <summary>
            Allows the component to be added to another composite component.
            </summary>
            <value>The name of the composite component.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ComponentElement.Name">
            <summary>
            Allows the component to be added to another composite component.
            </summary>
            <value>The name of the composite component.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ComponentElement.InstanceScope">
            <summary>
            Sets the scope of the component instances.
            </summary>
            <value>singleton (default,) factory or container.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ComponentElement.Ownership">
            <summary>
            Sets the ownership over the component instances.
            </summary>
            <value>container (default) or external.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ComponentElement.InjectProperties">
            <summary>
            Sets up property injection for the component instances. This uses the
            OnActivated event so that circular dependencies can be handled.
            </summary>
            <value>never (default,) all, unset.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ComponentElement.Services">
            <summary>
            Gets the services exposed by the component.
            </summary>
            <value>The services.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ComponentElement.Parameters">
            <summary>
            Gets the parameters used to construct the component.
            </summary>
            <value>The parameters.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ComponentElement.Properties">
            <summary>
            Gets the properties to be explicitly set on the component.
            </summary>
            <value>The explicit properties.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ComponentElement.Metadata">
            <summary>
            Gets the extended properties associated with the registration.
            </summary>
            <value>The extended properties.</value>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Builder.RegistrationExtensions">
            <summary>
            Adds registration syntax for less commonly-used features.
            </summary>
            <remarks>
            These features are in this namespace because they will remain accessible to
            applications originally written against Autofac 1.4. In Autofac 2, this functionality
            is implicitly provided and thus making explicit registrations is rarely necessary.
            </remarks>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationExtensions.RegisterGeneratedFactory(Revenj.Extensibility.Autofac.ContainerBuilder,System.Type)">
            <summary>
            Registers a factory delegate.
            </summary>
            <param name="builder">Container builder.</param>
            <param name="delegateType">Factory type to generate.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
            <remarks>Factory delegates are provided automatically in Autofac 2,
            and this method is generally not required.</remarks>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationExtensions.RegisterGeneratedFactory(Revenj.Extensibility.Autofac.ContainerBuilder,System.Type,Revenj.Extensibility.Autofac.Core.Service)">
            <summary>
            Registers a factory delegate.
            </summary>
            <param name="builder">Container builder.</param>
            <param name="delegateType">Factory type to generate.</param>
            <param name="service">The service that the delegate will return instances of.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
            <remarks>Factory delegates are provided automatically in Autofac 2, and
            this method is generally not required.</remarks>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationExtensions.RegisterGeneratedFactory``1(Revenj.Extensibility.Autofac.ContainerBuilder,Revenj.Extensibility.Autofac.Core.Service)">
            <summary>
            Registers a factory delegate.
            </summary>
            <typeparam name="TDelegate">The type of the delegate.</typeparam>
            <param name="builder">Container builder.</param>
            <param name="service">The service that the delegate will return instances of.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
            <remarks>Factory delegates are provided automatically in Autofac 2,
            and this method is generally not required.</remarks>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationExtensions.RegisterGeneratedFactory``1(Revenj.Extensibility.Autofac.ContainerBuilder)">
            <summary>
            Registers a factory delegate.
            </summary>
            <typeparam name="TDelegate">The type of the delegate.</typeparam>
            <param name="builder">Container builder.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
            <remarks>Factory delegates are provided automatically in Autofac 2,
            and this method is generally not required.</remarks>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationExtensions.NamedParameterMapping``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2})">
            <summary>
            Changes the parameter mapping mode of the supplied delegate type to match
            parameters by name.
            </summary>
            <typeparam name="TDelegate">Factory delegate type</typeparam>
            <typeparam name="TGeneratedFactoryActivatorData">Activator data type</typeparam>
            <typeparam name="TSingleRegistrationStyle">Registration style</typeparam>
            <param name="registration">Registration to change parameter mapping mode of.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationExtensions.PositionalParameterMapping``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2})">
            <summary>
            Changes the parameter mapping mode of the supplied delegate type to match
            parameters by position.
            </summary>
            <typeparam name="TDelegate">Factory delegate type</typeparam>
            <typeparam name="TGeneratedFactoryActivatorData">Activator data type</typeparam>
            <typeparam name="TSingleRegistrationStyle">Registration style</typeparam>
            <param name="registration">Registration to change parameter mapping mode of.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationExtensions.TypedParameterMapping``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2})">
            <summary>
            Changes the parameter mapping mode of the supplied delegate type to match
            parameters by type.
            </summary>
            <typeparam name="TDelegate">Factory delegate type</typeparam>
            <typeparam name="TGeneratedFactoryActivatorData">Activator data type</typeparam>
            <typeparam name="TSingleRegistrationStyle">Registration style</typeparam>
            <param name="registration">Registration to change parameter mapping mode of.</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationExtensions.RegisterCollection(Revenj.Extensibility.Autofac.ContainerBuilder,System.String,System.Type)">
            <summary>
            Registers the type as a collection. If no services or names are specified, the
            default services will be IList&lt;T&gt;, ICollection&lt;T&gt;, and IEnumerable&lt;T&gt;        
            </summary>
            <param name="elementType">The type of the collection elements.</param>
            <param name="builder">Container builder.</param>
            <param name="collectionName">A unique name for the collection that can be passed to MemberOf().</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
            <remarks>Collections are provided automatically in Autofac 2,
            and this method is generally not required.</remarks>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationExtensions.RegisterCollection``1(Revenj.Extensibility.Autofac.ContainerBuilder,System.String)">
            <summary>
            Registers the type as a collection. If no services or names are specified, the
            default services will be IList&lt;T&gt;, ICollection&lt;T&gt;, and IEnumerable&lt;T&gt;        
            </summary>
            <typeparam name="T">The type of the collection elements.</typeparam>
            <param name="builder">Container builder.</param>
            <param name="collectionName">A unique name for the collection that can be passed to MemberOf().</param>
            <returns>Registration builder allowing the registration to be configured.</returns>
            <remarks>Collections are provided automatically in Autofac 2,
            and this method is generally not required.</remarks>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationExtensions.MemberOf``3(Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.String)">
            <summary>
            Include the element explicitly in a collection configured using RegisterCollection.
            </summary>
            <typeparam name="TLimit">Registration limit type.</typeparam>
            <typeparam name="TSingleRegistrationStyle">Registration style.</typeparam>
            <typeparam name="TActivatorData">Activator data type.</typeparam>
            <param name="registration">Registration to export.</param>
            <param name="collectionName">The collection name, as passed to RegisterCollection.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlRowDescription">
             <summary>
             This class represents a RowDescription message sent from
             the PostgreSQL.
             </summary>
            
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlRowDescription.FieldData">
            <summary>
            This struct represents the internal data of the RowDescription message.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlFactory">
            <summary>
            A factory to create instances of various Npgsql objects.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlFactory.CreateCommand">
            <summary>
            Creates an NpgsqlCommand object.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.StringRowReader">
            <summary>
            Implements <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.RowReader"/> for version 3 of the protocol.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlFlush">
             <summary>
             This class represents the Parse message sent to PostgreSQL
             server.
             </summary>
            
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInStream">
            <summary>
            Stream for writing data to a table on a PostgreSQL version 7.4 or newer database during an active COPY FROM STDIN operation.
            <b>Passes data exactly as is and when given</b>, so see to it that you use server encoding, correct format and reasonably sized writes!
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInStream.#ctor(Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlConnector)">
            <summary>
            Created only by NpgsqlCopyInState.StartCopy()
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInStream.Close">
            <summary>
            Successfully completes copying data to server. Returns after operation is finished.
            Does nothing if this stream is not the active copy operation writer.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInStream.Cancel(System.String)">
            <summary>
            Withdraws an already started copy operation. The operation will fail with given error message.
            Does nothing if this stream is not the active copy operation writer.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes given bytes to server.
            Fails if this stream is not the active copy operation writer.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInStream.Flush">
            <summary>
            Flushes stream contents to server.
            Fails if this stream is not the active copy operation writer.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Not readable
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Not seekable
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInStream.SetLength(System.Int64)">
            <summary>
            Not supported
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInStream.IsActive">
            <summary>
            True while this stream can be used to write copy data to server
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInStream.CanRead">
            <summary>
            False
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInStream.CanWrite">
            <summary>
            True
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInStream.CanSeek">
            <summary>
            False
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInStream.Length">
            <summary>
            Number of bytes written so far
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyInStream.Position">
            <summary>
            Number of bytes written so far; not settable
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Util.SequenceExtensions.JoinWith(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Joins the strings into one single string interspersing the elements with the separator (a-la
            System.String.Join()).
            </summary>
            <param name="elements">The elements.</param>
            <param name="separator">The separator.</param>
            <returns>The joined string.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Util.SequenceExtensions.Append``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Appends the item to the specified sequence.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sequence">The sequence.</param>
            <param name="trailingItem">The trailing item.</param>
            <returns></returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Util.SequenceExtensions.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Prepends the item to the specified sequence.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sequence">The sequence.</param>
            <param name="leadingItem">The leading item.</param>
            <returns></returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Features.Metadata.MetaRegistrationSource">
            <summary>
            Support the <see cref="T:Revenj.Extensibility.Autofac.Features.Metadata.Meta`1"/>
            types automatically whenever type T is registered with the container.
            Metadata values come from the component registration's metadata.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Registration.ServiceRegistrationInfo">
            <summary>
            Tracks the services known to the registry.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Autofac.Core.Registration.ServiceRegistrationInfo._sourcesToQuery">
            <summary>
            Used for bookkeeping so that the same source is not queried twice (may be null.)
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Registration.ServiceRegistrationInfo.#ctor(Revenj.Extensibility.Autofac.Core.Service)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Core.Registration.ServiceRegistrationInfo"/> class.
            </summary>
            <param name="service">The tracked service.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Registration.ServiceRegistrationInfo.IsInitialized">
            <summary>
            The first time a service is requested, initialization (e.g. reading from sources)
            happens. This value will then be set to true. Calling many methods on this type before
            initialisation is an error.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Registration.ServiceRegistrationInfo.Implementations">
            <summary>
            The known implementations.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.Registration.ServiceRegistrationInfo.IsRegistered">
            <summary>
            True if any implementations are known.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.ServiceElementCollection">
            <summary>
            A collection of service elements.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.ServiceElementCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Configuration.ServiceElementCollection"/> class.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlSync">
             <summary>
             This class represents the Parse message sent to PostgreSQL
             server.
             </summary>
            
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval">
            <summary>
            Represents the PostgreSQL interval datatype.
            <remarks>PostgreSQL differs from .NET in how it's interval type doesn't assume 24 hours in a day
            (to deal with 23- and 25-hour days caused by daylight savings adjustments) and has a concept
            of months that doesn't exist in .NET's <see cref="T:System.TimeSpan"/> class. (Neither datatype
            has any concessions for leap-seconds).
            <para>For most uses just casting to and from TimeSpan will work correctly  in particular,
            the results of subtracting one <see cref="T:System.DateTime"/> or the PostgreSQL date, time and
            timestamp types from another should be the same whether you do so in .NET or PostgreSQL 
            but if the handling of days and months in PostgreSQL is important to your application then you
            should use this class instead of <see cref="T:System.TimeSpan"/>.</para>
            <para>If you don't know whether these differences are important to your application, they
            probably arent! Just use <see cref="T:System.TimeSpan"/> and do not use this class directly </para>
            <para>To avoid forcing unnecessary provider-specific concerns on users who need not be concerned
            with them a call to <see cref="!:IDataRecord.GetValue(int)"/> on a field containing an
            <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> value will return a <see cref="T:System.TimeSpan"/> rather than an
            <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/>. If you need the extra functionality of <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/>
            then use <see cref="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetInterval(System.Int32)"/>.</para>
            </remarks>
            <seealso cref="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Ticks"/>
            <seealso cref="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.JustifyDays"/>
            <seealso cref="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.JustifyMonths"/>
            <seealso cref="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Canonicalize"/>
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.TicksPerMicrosecond">
            <summary>
            Represents the number of ticks (100ns periods) in one microsecond. This field is constant.
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.TicksPerMillsecond">
            <summary>
            Represents the number of ticks (100ns periods) in one millisecond. This field is constant.
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.TicksPerSecond">
            <summary>
            Represents the number of ticks (100ns periods) in one second. This field is constant.
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.TicksPerMinute">
            <summary>
            Represents the number of ticks (100ns periods) in one minute. This field is constant.
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.TicksPerHour">
            <summary>
            Represents the number of ticks (100ns periods) in one hour. This field is constant.
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.TicksPerDay">
            <summary>
            Represents the number of ticks (100ns periods) in one day. This field is constant.
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.HoursPerDay">
            <summary>
            Represents the number of hours in one day (assuming no daylight savings adjustments). This field is constant.
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.DaysPerMonth">
            <summary>
            Represents the number of days assumed in one month if month justification or unjustifcation is performed.
            This is set to 30 for consistency with PostgreSQL. Note that this is means that month adjustments cause
            a year to be taken as 30 &#xd7; 12 = 360 rather than 356/366 days.
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.TicksPerMonth">
            <summary>
            Represents the number of ticks (100ns periods) in one day, assuming 30 days per month. <seealso cref="F:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.DaysPerMonth"/>
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.MonthsPerYear">
            <summary>
            Represents the number of months in a year. This field is constant.
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.MaxValue">
            <summary>
            Represents the maximum <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/>. This field is read-only.
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.MinValue">
            <summary>
            Represents the minimum <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/>. This field is read-only.
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Zero">
            <summary>
            Represents the zero <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/>. This field is read-only.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.#ctor(System.Int64)">
            <summary>
            Initializes a new <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to the specified number of ticks.
            </summary>
            <param name="ticks">A time period expressed in 100ns units.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.#ctor(System.TimeSpan)">
            <summary>
            Initializes a new <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to hold the same time as a <see cref="T:System.TimeSpan"/>
            </summary>
            <param name="timespan">A time period expressed in a <see cref="T:System.TimeSpan"/></param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.#ctor(System.Int32,System.Int32,System.Int64)">
            <summary>
            Initializes a new <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to the specified number of months, days
            &amp; ticks.
            </summary>
            <param name="months">Number of months.</param>
            <param name="days">Number of days.</param>
            <param name="ticks">Number of 100ns units.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to the specified number of
            days, hours, minutes &amp; seconds.
            </summary>
            <param name="days">Number of days.</param>
            <param name="hours">Number of hours.</param>
            <param name="minutes">Number of minutes.</param>
            <param name="seconds">Number of seconds.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to the specified number of
            days, hours, minutes, seconds &amp; milliseconds.
            </summary>
            <param name="days">Number of days.</param>
            <param name="hours">Number of hours.</param>
            <param name="minutes">Number of minutes.</param>
            <param name="seconds">Number of seconds.</param>
            <param name="milliseconds">Number of milliseconds.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to the specified number of
            months, days, hours, minutes, seconds &amp; milliseconds.
            </summary>
            <param name="months">Number of months.</param>
            <param name="days">Number of days.</param>
            <param name="hours">Number of hours.</param>
            <param name="minutes">Number of minutes.</param>
            <param name="seconds">Number of seconds.</param>
            <param name="milliseconds">Number of milliseconds.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to the specified number of
            years, months, days, hours, minutes, seconds &amp; milliseconds.
            <para>Years are calculated exactly equivalent to 12 months.</para>
            </summary>
            <param name="years">Number of years.</param>
            <param name="months">Number of months.</param>
            <param name="days">Number of days.</param>
            <param name="hours">Number of hours.</param>
            <param name="minutes">Number of minutes.</param>
            <param name="seconds">Number of seconds.</param>
            <param name="milliseconds">Number of milliseconds.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.FromTicks(System.Int64)">
            <summary>
            Creates an <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> from a number of ticks.
            </summary>
            <param name="ticks">The number of ticks (100ns units) in the interval.</param>
            <returns>A <see cref="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Canonicalize"/>d <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> with the given number of ticks.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.FromMicroseconds(System.Double)">
            <summary>
            Creates an <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> from a number of microseconds.
            </summary>
            <param name="ticks">The number of microseconds in the interval.</param>
            <returns>A <see cref="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Canonicalize"/>d <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> with the given number of microseconds.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.FromMilliseconds(System.Double)">
            <summary>
            Creates an <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> from a number of milliseconds.
            </summary>
            <param name="ticks">The number of milliseconds in the interval.</param>
            <returns>A <see cref="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Canonicalize"/>d <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> with the given number of milliseconds.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.FromSeconds(System.Double)">
            <summary>
            Creates an <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> from a number of seconds.
            </summary>
            <param name="ticks">The number of seconds in the interval.</param>
            <returns>A <see cref="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Canonicalize"/>d <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> with the given number of seconds.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.FromMinutes(System.Double)">
            <summary>
            Creates an <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> from a number of minutes.
            </summary>
            <param name="ticks">The number of minutes in the interval.</param>
            <returns>A <see cref="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Canonicalize"/>d <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> with the given number of minutes.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.FromHours(System.Double)">
            <summary>
            Creates an <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> from a number of hours.
            </summary>
            <param name="ticks">The number of hours in the interval.</param>
            <returns>A <see cref="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Canonicalize"/>d <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> with the given number of hours.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.FromDays(System.Double)">
            <summary>
            Creates an <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> from a number of days.
            </summary>
            <param name="ticks">The number of days in the interval.</param>
            <returns>A <see cref="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Canonicalize"/>d <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> with the given number of days.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.FromMonths(System.Double)">
            <summary>
            Creates an <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> from a number of months.
            </summary>
            <param name="ticks">The number of months in the interval.</param>
            <returns>A <see cref="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Canonicalize"/>d <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> with the given number of months.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Add(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval)">
            <summary>
            Adds another interval to this instance and returns the result.
            </summary>
            <param name="interval">An <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to add to this instance.</param>
            <returns>An <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"></see> whose values are the sums of the two instances.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Subtract(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval)">
            <summary>
            Subtracts another interval from this instance and returns the result.
            </summary>
            <param name="interval">An <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to subtract from this instance.</param>
            <returns>An <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"></see> whose values are the differences of the two instances.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Negate">
            <summary>
            Returns an <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> whose value is the negated value of this instance.
            </summary>
            <returns>An <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> whose value is the negated value of this instance.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Duration">
            <summary>
            This absolute value of this instance. In the case of some, but not all, components being negative,
            the rules used for justification are used to determine if the instance is positive or negative.
            </summary>
            <returns>An <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> whose value is the absolute value of this instance.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.JustifyDays">
            <summary>
            Equivalent to PostgreSQL's justify_days function.
            </summary>
            <returns>An <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> based on this one, but with any hours outside of the range [-23, 23]
            converted into days.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.UnjustifyDays">
            <summary>
            Opposite to PostgreSQL's justify_days function.
            </summary>
            <returns>An <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> based on this one, but with any days converted to multiples of 24hours.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.JustifyMonths">
            <summary>
            Equivalent to PostgreSQL's justify_months function.
            </summary>
            <returns>An <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> based on this one, but with any days outside of the range [-30, 30]
            converted into months.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.UnjustifyMonths">
            <summary>
            Opposite to PostgreSQL's justify_months function.
            </summary>
            <returns>An <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> based on this one, but with any months converted to multiples of 30days.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.JustifyInterval">
            <summary>
            Equivalent to PostgreSQL's justify_interval function.
            </summary>
            <returns>An <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> based on this one,
            but with any months converted to multiples of 30days
            and then with any days converted to multiples of 24hours</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.UnjustifyInterval">
            <summary>
            Opposite to PostgreSQL's justify_interval function.
            </summary>
            <returns>An <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> based on this one, but with any months converted to multiples of 30days and then any days converted to multiples of 24hours;</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Canonicalize" -->
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.op_Implicit(System.TimeSpan)~Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval">
            <summary>
            Implicit cast of a <see cref="T:System.TimeSpan"/> to an <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/>
            </summary>
            <param name="timespan">A <see cref="T:System.TimeSpan"/></param>
            <returns>An eqivalent, canonical, <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/>.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.op_Explicit(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval)~System.TimeSpan">
            <summary>
            Implicit cast of an <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to a <see cref="T:System.TimeSpan"/>.
            </summary>
            <param name="interval">A <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/>.</param>
            <returns>An equivalent <see cref="T:System.TimeSpan"/>.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Equals(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval)">
            <summary>
            Returns true if another <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> is exactly the same as this instance.
            </summary>
            <param name="other">An <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> for comparison.</param>
            <returns>true if the two <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> instances are exactly the same,
            false otherwise.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Equals(System.Object)">
            <summary>
            Returns true if another object is an <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/>, that is exactly the same as
            this instance
            </summary>
            <param name="obj">An <see cref="T:System.Object"/> for comparison.</param>
            <returns>true if the argument is an <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> and is exactly the same
            as this one, false otherwise.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Compare(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval)">
            <summary>
            Compares two <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> instances.
            </summary>
            <param name="x">The first <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/>.</param>
            <param name="y">The second <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/>.</param>
            <returns>0 if the two are equal or equivalent. A value greater than zero if x is greater than y,
            a value less than zero if x is less than y.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.GetHashCode">
            <summary>
            A hash code suitable for uses with hashing algorithms.
            </summary>
            <returns>An signed integer.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.CompareTo(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval)">
            <summary>
            Compares this instance with another/
            </summary>
            <param name="other">An <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to compare this with.</param>
            <returns>0 if the instances are equal or equivalent. A value less than zero if
            this instance is less than the argument. A value greater than zero if this instance
            is greater than the instance.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.CompareTo(System.Object)">
            <summary>
            Compares this instance with another/
            </summary>
            <param name="other">An object to compare this with.</param>
            <returns>0 if the argument is an <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> and the instances are equal or equivalent.
            A value less than zero if the argument is an <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> and
            this instance is less than the argument.
            A value greater than zero if the argument is an <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> and this instance
            is greater than the instance.</returns>
            A value greater than zero if the argument is null.
            <exception cref="T:System.ArgumentException">The argument is not an <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/>.</exception>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Parse(System.String)">
            <summary>
            Parses a <see cref="T:System.String"/> and returns a <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> instance.
            Designed to use the formats generally returned by PostgreSQL.
            </summary>
            <param name="str">The <see cref="T:System.String"/> to parse.</param>
            <returns>An <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> represented by the argument.</returns>
            <exception cref="T:System.ArgumentNullException">The string was null.</exception>
            <exception cref="T:System.OverflowException">A value obtained from parsing the string exceeded the values allowed for the relevant component.</exception>
            <exception cref="T:System.FormatException">The string was not in a format that could be parsed to produce an <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/>.</exception>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.TryParse(System.String,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval@)">
            <summary>
            Attempt to parse a <see cref="T:System.String"/> to produce an <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/>.
            </summary>
            <param name="str">The <see cref="T:System.String"/> to parse.</param>
            <param name="result">(out) The <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> produced, or <see cref="F:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Zero"/> if the parsing failed.</param>
            <returns>true if the parsing succeeded, false otherwise.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.ToString">
            <summary>
            Create a <see cref="T:System.String"/> representation of the <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> instance.
            The format returned is of the form:
            [M mon[s]] [d day[s]] [HH:mm:ss[.f[f[f[f[f[f[f[f[f]]]]]]]]]]
            A zero <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> is represented as 00:00:00
            <remarks>
            Ticks are 100ns, Postgress resolution is only to 1s at most. Hence we lose 1 or more decimal
            precision in storing values in the database. Despite this, this method will output that extra
            digit of precision. It's forward-compatible with any future increases in resolution up to 100ns,
            and also makes this ToString() more applicable to any other use-case.
            </remarks>
            </summary>
            <returns>The <see cref="T:System.String"/> representation.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.op_Addition(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval)">
            <summary>
            Adds two <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> together.
            </summary>
            <param name="x">The first <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to add.</param>
            <param name="y">The second <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to add.</param>
            <returns>An <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> whose values are the sum of the arguments.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.op_Subtraction(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval)">
            <summary>
            Subtracts one <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> from another.
            </summary>
            <param name="x">The <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to subtract the other from.</param>
            <param name="y">The <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to subtract from the other.</param>
            <returns>An <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> whose values are the difference of the arguments</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.op_Equality(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval)">
            <summary>
            Returns true if two <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> are exactly the same.
            </summary>
            <param name="x">The first <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to compare.</param>
            <param name="y">The second <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to compare.</param>
            <returns>true if the two arguments are exactly the same, false otherwise.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.op_Inequality(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval)">
            <summary>
            Returns false if two <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> are exactly the same.
            </summary>
            <param name="x">The first <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to compare.</param>
            <param name="y">The second <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to compare.</param>
            <returns>false if the two arguments are exactly the same, true otherwise.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.op_LessThan(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval)">
            <summary>
            Compares two <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> instances to see if the first is less than the second
            </summary>
            <param name="x">The first <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to compare.</param>
            <param name="y">The second <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to compare.</param>
            <returns>true if the first <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> is less than second, false otherwise.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.op_LessThanOrEqual(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval)">
            <summary>
            Compares two <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> instances to see if the first is less than or equivalent to the second
            </summary>
            <param name="x">The first <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to compare.</param>
            <param name="y">The second <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to compare.</param>
            <returns>true if the first <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> is less than or equivalent to second, false otherwise.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.op_GreaterThan(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval)">
            <summary>
            Compares two <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> instances to see if the first is greater than the second
            </summary>
            <param name="x">The first <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to compare.</param>
            <param name="y">The second <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to compare.</param>
            <returns>true if the first <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> is greater than second, false otherwise.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.op_GreaterThanOrEqual(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval)">
            <summary>
            Compares two <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> instances to see if the first is greater than or equivalent the second
            </summary>
            <param name="x">The first <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to compare.</param>
            <param name="y">The second <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> to compare.</param>
            <returns>true if the first <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> is greater than or equivalent to the second, false otherwise.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.op_UnaryPlus(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval)">
            <summary>
            Returns the instance.
            </summary>
            <param name="x">An <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/>.</param>
            <returns>The argument.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.op_UnaryNegation(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval)">
            <summary>
            Negates an <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> instance.
            </summary>
            <param name="x">An <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/>.</param>
            <returns>The negation of the argument.</returns>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Ticks">
            <summary>
            The total number of ticks(100ns units) contained. This is the resolution of the
            <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/>  type. This ignores the number of days and
            months held. If you want them included use <see cref="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.UnjustifyInterval"/> first.
            <remarks>The resolution of the PostgreSQL
            interval type is by default 1s = 1,000 ns. It may be smaller as follows:
            <list type="number">
            <item>
            <term>interval(0)</term>
            <description>resolution of 1s (1 second)</description>
            </item>
            <item>
            <term>interval(1)</term>
            <description>resolution of 100ms = 0.1s (100 milliseconds)</description>
            </item>
            <item>
            <term>interval(2)</term>
            <description>resolution of 10ms = 0.01s (10 milliseconds)</description>
            </item>
            <item>
            <term>interval(3)</term>
            <description>resolution of 1ms = 0.001s (1 millisecond)</description>
            </item>
            <item>
            <term>interval(4)</term>
            <description>resolution of 100s = 0.0001s (100 microseconds)</description>
            </item>
            <item>
            <term>interval(5)</term>
            <description>resolution of 10s = 0.00001s (10 microseconds)</description>
            </item>
            <item>
            <term>interval(6) or interval</term>
            <description>resolution of 1s = 0.000001s (1 microsecond)</description>
            </item>
            </list>
            <para>As such, if the 100-nanosecond resolution is significant to an application, a PostgreSQL interval will
            not suffice for those purposes.</para>
            <para>In more frequent cases though, the resolution of the interval suffices.
            <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> will always suffice to handle the resolution of any interval value, and upon
            writing to the database, will be rounded to the resolution used.</para>
            </remarks>
            <returns>The number of ticks in the instance.</returns>
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Microseconds">
            <summary>
            Gets the number of whole microseconds held in the instance.
            <returns>An  in the range [-999999, 999999].</returns>
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Milliseconds">
            <summary>
            Gets the number of whole milliseconds held in the instance.
            <returns>An  in the range [-999, 999].</returns>
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Seconds">
            <summary>
            Gets the number of whole seconds held in the instance.
            <returns>An  in the range [-59, 59].</returns>
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Minutes">
            <summary>
            Gets the number of whole minutes held in the instance.
            <returns>An  in the range [-59, 59].</returns>
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Hours">
            <summary>
            Gets the number of whole hours held in the instance.
            <remarks>Note that this can be less than -23 or greater than 23 unless <see cref="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.JustifyDays"/>
            has been used to produce this instance.</remarks>
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Days">
            <summary>
            Gets the number of days held in the instance.
            <remarks>Note that this does not pay attention to a time component with -24 or less hours or
            24 or more hours, unless <see cref="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.JustifyDays"/> has been called to produce this instance.</remarks>
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Months">
            <summary>
            Gets the number of months held in the instance.
            <remarks>Note that this does not pay attention to a day component with -30 or less days or
            30 or more days, unless <see cref="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.JustifyMonths"/> has been called to produce this instance.</remarks>
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.Time">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> representing the time component of the instance.
            <remarks>Note that this may have a value beyond the range 23:59:59.9999999 unless
            <see cref="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.JustifyDays"/> has been called to produce this instance.</remarks>
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.TotalTicks">
            <summary>
            The total number of ticks (100ns units) in the instance, assuming 24 hours in each day and
            30 days in a month.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.TotalMicroseconds">
            <summary>
            The total number of microseconds in the instance, assuming 24 hours in each day and
            30 days in a month.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.TotalMilliseconds">
            <summary>
            The total number of milliseconds in the instance, assuming 24 hours in each day and
            30 days in a month.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.TotalSeconds">
            <summary>
            The total number of seconds in the instance, assuming 24 hours in each day and
            30 days in a month.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.TotalMinutes">
            <summary>
            The total number of minutes in the instance, assuming 24 hours in each day and
            30 days in a month.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.TotalHours">
            <summary>
            The total number of hours in the instance, assuming 24 hours in each day and
            30 days in a month.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.TotalDays">
            <summary>
            The total number of days in the instance, assuming 24 hours in each day and
            30 days in a month.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval.TotalMonths">
            <summary>
            The total number of months in the instance, assuming 24 hours in each day and
            30 days in a month.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTime.Normalize">
            <summary>
            Normalise this time; if it is 24:00:00, convert it to 00:00:00
            </summary>
            <returns>This time, normalised</returns>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTime.Ticks">
            <summary>
            The total number of ticks(100ns units) contained. This is the resolution of the
            <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTime"/>  type.
            <remarks>The resolution of the PostgreSQL
            interval type is by default 1s = 1,000 ns. It may be smaller as follows:
            <list type="number">
            <item>
            <term>time(0)</term>
            <description>resolution of 1s (1 second)</description>
            </item>
            <item>
            <term>time(1)</term>
            <description>resolution of 100ms = 0.1s (100 milliseconds)</description>
            </item>
            <item>
            <term>time(2)</term>
            <description>resolution of 10ms = 0.01s (10 milliseconds)</description>
            </item>
            <item>
            <term>time(3)</term>
            <description>resolution of 1ms = 0.001s (1 millisecond)</description>
            </item>
            <item>
            <term>time(4)</term>
            <description>resolution of 100s = 0.0001s (100 microseconds)</description>
            </item>
            <item>
            <term>time(5)</term>
            <description>resolution of 10s = 0.00001s (10 microseconds)</description>
            </item>
            <item>
            <term>time(6) or interval</term>
            <description>resolution of 1s = 0.000001s (1 microsecond)</description>
            </item>
            </list>
            <para>As such, if the 100-nanosecond resolution is significant to an application, a PostgreSQL time will
            not suffice for those purposes.</para>
            <para>In more frequent cases though, the resolution of time suffices.
            <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTime"/> will always suffice to handle the resolution of any time value, and upon
            writing to the database, will be rounded to the resolution used.</para>
            </remarks>
            <returns>The number of ticks in the instance.</returns>
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTime.Microseconds">
            <summary>
            Gets the number of whole microseconds held in the instance.
            <returns>An integer in the range [0, 999999].</returns>
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTime.Milliseconds">
            <summary>
            Gets the number of whole milliseconds held in the instance.
            <returns>An integer in the range [0, 999].</returns>
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTime.Seconds">
            <summary>
            Gets the number of whole seconds held in the instance.
            <returns>An interger in the range [0, 59].</returns>
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTime.Minutes">
            <summary>
            Gets the number of whole minutes held in the instance.
            <returns>An integer in the range [0, 59].</returns>
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTime.Hours">
            <summary>
            Gets the number of whole hours held in the instance.
            <remarks>Note that the time 24:00:00 can be stored for roundtrip compatibility. Any calculations on such a
            value will normalised it to 00:00:00.</remarks>
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTimeTZ.Normalize">
            <summary>
            Normalise this time; if it is 24:00:00, convert it to 00:00:00
            </summary>
            <returns>This time, normalised</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTimeTZ.CompareTo(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTimeTZ)">
            <summary>
            Compares this with another <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTimeTZ"/>. As per postgres' rules,
            first the times are compared as if they were both in the same timezone. If they are equal then
            then timezones are compared (+01:00 being "smaller" than -01:00).
            </summary>
            <param name="other">the <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTimeTZ"/> to compare with.</param>
            <returns>An integer which is 0 if they are equal, &lt; 0 if this is the smaller and &gt; 0 if this is the larger.</returns>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTimeTZ.Microseconds">
            <summary>
            Gets the number of whole microseconds held in the instance.
            <returns>An integer in the range [0, 999999].</returns>
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTimeTZ.Milliseconds">
            <summary>
            Gets the number of whole milliseconds held in the instance.
            <returns>An integer in the range [0, 999].</returns>
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTimeTZ.Seconds">
            <summary>
            Gets the number of whole seconds held in the instance.
            <returns>An interger in the range [0, 59].</returns>
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTimeTZ.Minutes">
            <summary>
            Gets the number of whole minutes held in the instance.
            <returns>An integer in the range [0, 59].</returns>
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlTimeTZ.Hours">
            <summary>
            Gets the number of whole hours held in the instance.
            <remarks>Note that the time 24:00:00 can be stored for roundtrip compatibility. Any calculations on such a
            value will normalised it to 00:00:00.</remarks>
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString">
            <summary>
            <para>Implements a bit string; a collection of zero or more bits which can each be 1 or 0.</para>
            <para>BitString's behave as a list of bools, though like most strings and unlike most collections the position
            tends to be of as much significance as the value.</para>
            <para>BitStrings are often used as masks, and are commonly cast to and from other values.</para>
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.Empty">
            <summary>
            Represents the empty string.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.#ctor(System.Collections.Generic.IEnumerable{System.Boolean})">
            <summary>
            Create a BitString from an enumeration of boolean values. The BitString will contain
            those booleans in the order they came in.
            </summary>
            <param name="bits">The boolean values.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.#ctor(System.Boolean,System.Int32)">
            <summary>
            Creates a BitString filled with a given number of true or false values.
            </summary>
            <param name="value">The value to fill the string with.</param>
            <param name="count">The number of bits to fill.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.#ctor(System.String)">
            <summary>
            Creats a bitstring from a <see cref="T:System.String">string</see>.
            <param name="str">The <see cref="T:System.String">string to copy from</see>.</param>
            <seealso cref="!:Npgsql.BitString.Parse(System.String)"/>
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.#ctor(System.Boolean)">
            <summary>
            Creates a single-bit element from a boolean value.
            </summary>
            <param name="boolean">The <see cref="T:System.Boolean">bool</see> value which determines whether
            the bit is 1 or 0.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.#ctor(System.UInt32)">
            <summary>
            Creates a bitstring from an unsigned integer value. The string will be the shortest required to
            contain the integer (e.g. 1 bit for 0 or 1, 2 for 2 or 3, 3 for 4-7, and so on).
            </summary>
            <param name="integer">The <see cref="T:System.UInt32">integer</see>.</param>
            <remarks>This method is not CLS Compliant, and may not be available to some languages.</remarks>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.#ctor(System.Int32)">
            <summary>
            Creates a bitstring from an integer value. The string will be the shortest required to
            contain the integer (e.g. 1 bit for 0 or 1, 2 for 2 or 3, 3 for 4-7, and so on).
            </summary>
            <param name="integer">The <see cref="T:System.Int32">integer</see>.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.IndexOf(System.Boolean)">
            <summary>
            Finds the first instance of a given value
            </summary>
            <param name="item">The value - whether true or false - to search for.</param>
            <returns>The index of the value found, or -1 if none are present.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.Contains(System.Boolean)">
            <summary>
            True if there is at least one bit with the value looked for.
            </summary>
            <param name="item">The value - true or false - to detect.</param>
            <returns>True if at least one bit was the same as item, false otherwise.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.CopyTo(System.Boolean[],System.Int32)">
            <summary>
            Copies the bitstring to an array of bools.
            </summary>
            <param name="array">The <see cref="T:System.Boolean">boolean</see> array to copy to.</param>
            <param name="arrayIndex">The index in the array to start copying from.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.GetEnumerator">
            <summary>
            Returns an enumerator that enumerates through the string.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.Concat(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString)">
            <summary>
            Creats a bitstring by concatenating another onto this one.
            </summary>
            <param name="append">The string to append to this one.</param>
            <returns>The combined strings.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.Substring(System.Int32,System.Int32)">
            <summary>
            Returns a substring of this string.
            </summary>
            <param name="start">The position to start from, must be between 0 and the length of the string.</param>
            <param name="length">The length of the string to return, must be greater than zero, and may not be
            so large that the start + length exceeds the bounds of this instance.</param>
            <returns>The Bitstring identified</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.Substring(System.Int32)">
            <summary>
            Returns a substring of this string.
            </summary>
            <param name="start">The position to start from, must be between 0 and the length of the string,
            the rest of the string is returned.</param>
            <returns>The Bitstring identified</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.And(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString)">
            <summary>
            A logical and between this string and another. The two strings must be the same length.
            </summary>
            <param name="operand">Another BitString to AND with this one.</param>
            <returns>A bitstring with 1 where both BitStrings had 1 and 0 otherwise.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.Or(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString)">
            <summary>
            A logical or between this string and another. The two strings must be the same length.
            </summary>
            <param name="operand">Another BitString to OR with this one.</param>
            <returns>A bitstring with 1 where either BitString had 1 and 0 otherwise.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.Xor(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString)">
            <summary>
            A logical xor between this string and another. The two strings must be the same length.
            </summary>
            <param name="operand">Another BitString to XOR with this one.</param>
            <returns>A bitstring with 1 where one BitStrings and the other had 0,
            and 0 where they both had 1 or both had 0.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.Not">
            <summary>
            A bitstring that is the logical inverse of this one.
            </summary>
            <returns>A bitstring of the same length as this with 1 where this has 0 and vice-versa.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.LShift(System.Int32)">
            <summary>
            Shifts the string operand bits to the left, filling with zeros to produce a
            string of the same length.
            </summary>
            <param name="operand">The number of bits to shift to the left.</param>
            <returns>A left-shifted bitstring.</returns>
            <remarks><para>The behaviour of LShift is closer to what one would expect from dealing
            with PostgreSQL bit-strings than in using the same operations on integers in .NET</para>
            <para>In particular, negative operands result in a right-shift, and operands greater than
            the length of the string will shift it entirely, resulting in a zero-filled string.</para>
            </remarks>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.RShift(System.Int32)">
            <summary>
            Shifts the string operand bits to the right, filling with zeros to produce a
            string of the same length.
            </summary>
            <param name="operand">The number of bits to shift to the right.</param>
            <returns>A right-shifted bitstring.</returns>
            <remarks><para>The behaviour of RShift is closer to what one would expect from dealing
            with PostgreSQL bit-strings than in using the same operations on integers in .NET</para>
            <para>In particular, negative operands result in a left-shift, and operands greater than
            the length of the string will shift it entirely, resulting in a zero-filled string. It also performs
            a logical shift, rather than an arithmetic shift, so it always sets the vacated bit positions to zero
            (like PostgreSQL and like .NET for unsigned integers but not for signed integers).</para>
            </remarks>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.Equals(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString)">
            <summary>
            Returns true if the this string is identical to the argument passed.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.CompareTo(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString)">
            <summary>
            Compares two strings. Strings are compared as strings, so while 0 being less than 1 will
            mean a comparison between two strings of the same size is the same as treating them as numbers,
            in the case of two strings of differing lengths the comparison starts at the right-most (most significant)
            bit, and if all bits of the shorter string are exhausted without finding a comparison, then the larger
            string is deemed to be greater than the shorter (0010 is greater than 0001 but less than 00100).
            </summary>
            <param name="other">Another string to compare with this one.</param>
            <returns>A value if the two strings are identical, an integer less
            than zero if this is less than the argument, and an integer greater
            than zero otherwise.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.CompareTo(System.Object)">
            <summary>
            Compares the string with another object.
            </summary>
            <param name="obj">The object to compare with.</param>
            <returns>If the object is null then this string is considered greater. If the object is another BitString
            then they are compared as in <see cref="!:CompareTo(Npgsql.BitString)">the explicit comparison for BitStrings</see>
            in any other case a <see cref="T:System.ArgumentException"/> is thrown.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.Equals(System.Object)">
            <summary>
            Compares this BitString with an object for equality.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.GetHashCode">
            <summary>
            Returns a code for use in hashing operations.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.ToString(System.String)">
            <summary>
            Returns a string representation of the BitString.
            </summary>
            <param name="format">
            A string which can contain a letter and optionally a number which sets a minimum size for the string
            returned. In each case using the lower-case form of the letter will result in a lower-case string
            being returned.
            <list type="table">
            <item>
            <term>B</term>
            <description>A string of 1s and 0s.</description>
            </item>
            <item>
            <term>X</term>
            <description>An hexadecimal string (will result in an error unless the string's length is divisible by 4).</description>
            </item>
            <item>
            <term>G</term>
            <description>A string of 1s and 0s in single-quotes preceded by 'B' (Postgres bit string literal syntax).</description>
            </item>
            <term>Y</term>
            <description>An hexadecimal string in single-quotes preceded by 'X' (Postgres bit literal syntax, will result in an error unless the string's length is divisible by 4.</description>
            </list>
            <term>C</term>
            <description>The format produced by format-string "Y" if legal, otherwise that produced by format-string "G".</description>
            <term>E</term>
            <description>The most compact safe representation for Postgres. If single bit will be either a 0 or a 1. Otherwise if it
            can be that produce by format string "Y" it will, otherwise if there are less than 9bits in length it will be that
            produced by format-string "G". For longer strings that cannot be represented in hexadecimal it will be a string
            representing the first part of the string in format "Y" followed by the PostgreSQL concatenation operator, followed
            by the final bits in the format "G". E.g. "X'13DCE'||B'110'"</description>
            If format is empty or null, it is treated as if "B" had been passed (the default repreesentation, and that
            generally used by PostgreSQL for display).
            </param>
            <returns>The formatted string.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.ToString">
            <summary>
            Returns a string representation for the Bitstring
            </summary>
            <returns>A string containing '0' and '1' characters.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.ToString(System.String,System.IFormatProvider)">
            <summary>
            Returns the same string as <see cref="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.ToString(System.String)"/>. formatProvider is ignored.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.Parse(System.String)">
            <summary>
            Parses a string to produce a BitString. Most formats that can be produced by
            <see cref="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.ToString(System.String)"/> can be accepted, but hexadecimal
            can be interpreted with the preceding X' to mark the following characters as
            being hexadecimal rather than binary.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.op_BitwiseAnd(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString)">
            <summary>
            Performs a logical AND on the two operands.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.op_BitwiseOr(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString)">
            <summary>
            Performs a logcial OR on the two operands.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.op_ExclusiveOr(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString)">
            <summary>
            Perofrms a logical EXCLUSIVE-OR on the two operands
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.op_OnesComplement(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString)">
            <summary>
            Performs a logical NOT on the operand.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.op_Addition(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString)">
            <summary>
            Concatenates the operands.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.op_LeftShift(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString,System.Int32)">
            <summary>
            Left-shifts the string BitString.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.op_RightShift(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString,System.Int32)">
            <summary>
            Right-shifts the string BitString.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.op_Equality(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString)">
            <summary>
            Compares the two operands.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.op_Inequality(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString)">
            <summary>
            Compares the two operands.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.op_LessThan(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString)">
            <summary>
            Compares the two operands.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.op_GreaterThan(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString)">
            <summary>
            Compares the two operands.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.op_LessThanOrEqual(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString)">
            <summary>
            Compares the two operands.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.op_GreaterThanOrEqual(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString,Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString)">
            <summary>
            Compares the two operands.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.ToString(System.Text.Encoding)">
            <summary>
            Interprets the bitstring as a series of bits in an encoded character string,
            encoded according to the Encoding passed, and returns that string.
            The bitstring must contain a whole number of octets(bytes) and also be
            valid according to the Encoding passed.
            </summary>
            <param name="encoding">The <see cref="T:System.Text.Encoding"/> to use in producing the string.</param>
            <returns>The string that was encoded in the BitString.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.ToByteEnumerable">
            <summary>
            Interprets the bitstring as a series of octets (bytes) and returns those octets. Fails
            if the Bitstring does not contain a whole number of octets (its length is not evenly
            divisible by 8).
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.ToSByteEnumerable">
            <summary>
            Interprets the bitstring as a series of signed octets (bytes) and returns those octets. Fails
            if the Bitstring does not contain a whole number of octets (its length is not evenly
            divisible by 8).
            <remarks>This method is not CLS-Compliant and may not be available to languages that cannot
            handle signed bytes.</remarks>
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.ToUInt16Enumerable">
            <summary>
            Interprets the bitstring as a series of unsigned 16-bit integers and returns those integers.
            Fails if the Bitstring's length is not evenly divisible by 16.
            <remarks>This method is not CLS-Compliant and may not be available to languages that cannot
            handle unsigned integers.</remarks>
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.ToInt16Enumerable">
            <summary>
            Interprets the bitstring as a series of 16-bit integers and returns those integers.
            Fails if the Bitstring's length is not evenly divisible by 16.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.ToUInt32Enumerable">
            <summary>
            Interprets the bitstring as a series of unsigned 32-bit integers and returns those integers.
            Fails if the Bitstring's length is not evenly divisible by 32.
            <remarks>This method is not CLS-Compliant and may not be available to languages that cannot
            handle unsigned integers.</remarks>
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.ToInt32Enumerable">
            <summary>
            Interprets the bitstring as a series of signed 32-bit integers and returns those integers.
            Fails if the Bitstring's length is not evenly divisible by 32.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.ToUInt64Enumerable">
            <summary>
            Interprets the bitstring as a series of unsigned 64-bit integers and returns those integers.
            Fails if the Bitstring's length is not evenly divisible by 64.
            <remarks>This method is not CLS-Compliant and may not be available to languages that cannot
            handle unsigned integers.</remarks>
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.ToInt64Enumerable">
            <summary>
            Interprets the bitstring as a series of signed 64-bit integers and returns those integers.
            Fails if the Bitstring's length is not evenly divisible by 64.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.Length">
            <summary>
            The length of the string.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.BitString.Item(System.Int32)">
            <summary>
            Retrieves the value of the bit at the given index.
            </summary>
        </member>
        <member name="T:Revenj.Utility.TypeUtility">
            <summary>
            Utility for working with reflection
            </summary>
        </member>
        <member name="M:Revenj.Utility.TypeUtility.GetTypeHierarchy(System.Type)">
            <summary>
            Get type hierarchy for specified type.
            All interfaces and base types will be returned.
            Result will be cached.
            </summary>
            <param name="startType">specified type</param>
            <returns>all implemented interfaces and base types</returns>
        </member>
        <member name="T:Revenj.IUnitOfWork">
            <summary>
            Unit of work pattern.
            IDataContext with a transaction.
            Don't forget to Commit() before disposing
            </summary>
        </member>
        <member name="M:Revenj.IUnitOfWork.Commit">
            <summary>
            Confirm database transaction. 
            After commit, unit of work needs to be disposed
            </summary>
        </member>
        <member name="M:Revenj.IUnitOfWork.Rollback">
            <summary>
            Rollback database transaction.
            After rollback, unit of work needs to be disposed
            </summary>
        </member>
        <member name="T:Revenj.LocatorHelper">
            <summary>
            Helper class for IServiceLocator
            </summary>
        </member>
        <member name="M:Revenj.LocatorHelper.DoWork(System.IServiceProvider)">
            <summary>
            Create new unit of work from current locator
            </summary>
            <param name="locator">service locator</param>
            <returns>unit of work</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Util.ReleaseAction">
            <summary>
            Adapts an action to the <see cref="T:System.IDisposable"/> interface.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.IStartable">
            <summary>
            When implemented by a component, an instance of the component will be resolved
            and started as soon as the container is built. Autofac will not call the Start()
            method when subsequent instances are resolved. If this behaviour is required, use
            an <code>OnActivated()</code> event handler instead.
            </summary>
            <remarks>
            For equivalent "Stop" functionality, implement <see cref="T:System.IDisposable"/>. Autofac
            will always dispose a component before any of its dependencies (except in the presence
            of circular dependencies, in which case the components in the cycle are disposed in
            reverse-construction order.)
            </remarks>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.IStartable.Start">
            <summary>
            Perform once-off startup processing.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.MetadataElement">
            <summary>
            Element describing a component property.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.MetadataElement.Name">
            <summary>
            Gets the name of the property.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.MetadataElement.Value">
            <summary>
            Gets the value to be set (will be converted.)
            </summary>
            <value>The value.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.MetadataElement.Type">
            <summary>
            Gets the type of the value.
            </summary>
            <value>The type of the value. Defaults to string if not specified.</value>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3">
            <summary>
            Data structure used to construct registrations.
            </summary>
            <typeparam name="TLimit">The most specific type to which instances of the registration
            can be cast.</typeparam>
            <typeparam name="TActivatorData">Activator builder type.</typeparam>
            <typeparam name="TRegistrationStyle">Registration style type.</typeparam>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.ExternallyOwned">
            <summary>
            Configure the component so that instances are never disposed by the container.
            </summary>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.OwnedByLifetimeScope">
            <summary>
            Configure the component so that instances that support IDisposable are
            disposed by the container (default.)
            </summary>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.InstancePerDependency">
            <summary>
            Configure the component so that every dependent component or call to Resolve()
            gets a new, unique instance (default.)
            </summary>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.SingleInstance">
            <summary>
            Configure the component so that every dependent component or call to Resolve()
            gets the same, shared instance.
            </summary>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.InstancePerLifetimeScope">
            <summary>
            Configure the component so that every dependent component or call to Resolve()
            within a single ILifetimeScope gets the same, shared instance. Dependent components in
            different lifetime scopes will get different instances.
            </summary>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.InstancePerMatchingLifetimeScope(System.Object)">
            <summary>
            Configure the component so that every dependent component or call to Resolve()
            within a ILifetimeScope tagged with the provided tag value gets the same, shared instance.
            Dependent components in lifetime scopes that are children of the tagged scope will
            share the parent's instance. If no appropriately tagged scope can be found in the
            hierarchy an <see cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/> is thrown.
            </summary>
            <param name="lifetimeScopeTag">Tag applied to matching lifetime scopes.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.InstancePerOwned``1">
            <summary>
            Configure the component so that every dependent component or call to Resolve()
            within a ILifetimeScope created by an owned instance gets the same, shared instance.
            Dependent components in lifetime scopes that are children of the owned instance scope will
            share the parent's instance. If no appropriate owned instance scope can be found in the
            hierarchy an <see cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/> is thrown.
            </summary>
            <typeparam name="TService">Service type.</typeparam>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.InstancePerOwned(System.Type)">
            <summary>
            Configure the component so that every dependent component or call to Resolve()
            within a ILifetimeScope created by an owned instance gets the same, shared instance.
            Dependent components in lifetime scopes that are children of the owned instance scope will
            share the parent's instance. If no appropriate owned instance scope can be found in the
            hierarchy an <see cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/> is thrown.
            </summary>
            <param name="serviceType">Service type.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.InstancePerOwned``1(System.Object)">
            <summary>
            Configure the component so that every dependent component or call to Resolve()
            within a ILifetimeScope created by an owned instance gets the same, shared instance.
            Dependent components in lifetime scopes that are children of the owned instance scope will
            share the parent's instance. If no appropriate owned instance scope can be found in the
            hierarchy an <see cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/> is thrown.
            </summary>
            <typeparam name="TService">The service type provided by the component.</typeparam>
            <param name="serviceKey">Key to associate with the component.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.InstancePerOwned(System.Object,System.Type)">
            <summary>
            Configure the component so that every dependent component or call to Resolve()
            within a ILifetimeScope created by an owned instance gets the same, shared instance.
            Dependent components in lifetime scopes that are children of the owned instance scope will
            share the parent's instance. If no appropriate owned instance scope can be found in the
            hierarchy an <see cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/> is thrown.
            </summary>
            <param name="serviceKey">Key to associate with the component.</param>
            <param name="serviceType">The service type provided by the component.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.As``1">
            <summary>
            Configure the services that the component will provide. The generic parameter(s) to As()
            will be exposed as TypedService instances.
            </summary>
            <typeparam name="TService">Service type.</typeparam>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.As``2">
            <summary>
            Configure the services that the component will provide. The generic parameter(s) to As()
            will be exposed as TypedService instances.
            </summary>
            <typeparam name="TService1">Service type.</typeparam>
            <typeparam name="TService2">Service type.</typeparam>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.As``3">
            <summary>
            Configure the services that the component will provide. The generic parameter(s) to As()
            will be exposed as TypedService instances.
            </summary>
            <typeparam name="TService1">Service type.</typeparam>
            <typeparam name="TService2">Service type.</typeparam>
            <typeparam name="TService3">Service type.</typeparam>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.As(System.Type[])">
            <summary>
            Configure the services that the component will provide.
            </summary>
            <param name="services">Service types to expose.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.As(Revenj.Extensibility.Autofac.Core.Service[])">
            <summary>
            Configure the services that the component will provide.
            </summary>
            <param name="services">Services to expose.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.Named(System.String,System.Type)">
            <summary>
            Provide a textual name that can be used to retrieve the component.
            </summary>
            <param name="serviceName">Named service to associate with the component.</param>
            <param name="serviceType">The service type provided by the component.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.Named``1(System.String)">
            <summary>
            Provide a textual name that can be used to retrieve the component.
            </summary>
            <param name="serviceName">Named service to associate with the component.</param>
            <typeparam name="TService">The service type provided by the component.</typeparam>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.Keyed(System.Object,System.Type)">
            <summary>
            Provide a key that can be used to retrieve the component.
            </summary>
            <param name="serviceKey">Key to associate with the component.</param>
            <param name="serviceType">The service type provided by the component.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.Keyed``1(System.Object)">
            <summary>
            Provide a key that can be used to retrieve the component.
            </summary>
            <param name="serviceKey">Key to associate with the component.</param>
            <typeparam name="TService">The service type provided by the component.</typeparam>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.OnPreparing(System.Action{Revenj.Extensibility.Autofac.Core.PreparingEventArgs})">
            <summary>
            Add a handler for the Preparing event. This event allows manipulating of the parameters
            that will be provided to the component.
            </summary>
            <param name="handler">The event handler.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.OnActivating(System.Action{Revenj.Extensibility.Autofac.Core.IActivatingEventArgs{`0}})">
            <summary>
            Add a handler for the Activating event.
            </summary>
            <param name="handler">The event handler.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.OnActivated(System.Action{Revenj.Extensibility.Autofac.Core.IActivatedEventArgs{`0}})">
            <summary>
            Add a handler for the Activated event.
            </summary>
            <param name="handler">The event handler.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.PropertiesAutowired(Revenj.Extensibility.Autofac.PropertyWiringFlags)">
            <summary>
            Configure the component so that any properties whose types are registered in the
            container will be wired to instances of the appropriate service.
            </summary>
            <param name="wiringFlags">Set wiring options such as circular dependency wiring support.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.WithMetadata(System.String,System.Object)">
            <summary>
            Associates data with the component.
            </summary>
            <param name="key">Key by which the data can be located.</param>
            <param name="value">The data value.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.WithMetadata(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
            <summary>
            Associates data with the component.
            </summary>
            <param name="properties">The extended properties to associate with the component.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.WithMetadata``1(System.Action{Revenj.Extensibility.Autofac.Builder.MetadataConfiguration{``0}})">
            <summary>
            Associates data with the component.
            </summary>
            <typeparam name="TMetadata">A type with properties whose names correspond to the
            property names to configure.</typeparam>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.ActivatorData">
            <summary>
            The activator data.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.RegistrationStyle">
            <summary>
            The registration style.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.IRegistrationBuilder`3.RegistrationData">
            <summary>
            The registration data.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlBufferedStream" -->
        <member name="F:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlBufferedStream.MaxShadowBufferSize">
            <summary><code>MaxShadowBufferSize</code> is chosed such that shadow buffers are not allocated on the Large Object Heap.
            Currently, an object is allocated on the LOH if it is larger than 85000 bytes. See LARGE_OBJECT_SIZE in ndp\clr\src\vm\gc.h
            We will go with exactly 80 KBytes, although this is somewhat arbitrary.</summary>
        </member>
        <member name="T:Revenj.Utility.AssemblyScanner">
            <summary>
            Utility for scanning and loading assemblies in current AppDomain.
            Microsoft-specific assemblies will be skipped.
            </summary>
        </member>
        <member name="F:Revenj.Utility.AssemblyScanner.AllAssemblies">
            <summary>
            Cache for <see cref="M:Revenj.Utility.AssemblyScanner.GetAssemblies"/>
            </summary>
        </member>
        <member name="F:Revenj.Utility.AssemblyScanner.AllTypes">
            <summary>
            Cache for <see cref="M:Revenj.Utility.AssemblyScanner.GetAllTypes"/>
            </summary>
        </member>
        <member name="M:Revenj.Utility.AssemblyScanner.GetAssemblies">
            <summary>
            Gets all referenced assemblies from current AppDomain, excluding dynamic or Microsoft-specific assemblies.
            Assemblies will be cached after first call.
            </summary>
            <returns>All referenced assemblies.</returns>
        </member>
        <member name="M:Revenj.Utility.AssemblyScanner.GetAllTypes">
            <summary>
            Get all types from assemblies.
            Types will be cached after first call.
            </summary>
            <returns>Types in assemblies</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.ComponentContextHelper">
            <summary>
            Helper for ResolveComponent
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ComponentContextHelper.ResolveComponent(Revenj.Extensibility.Autofac.IComponentContext,Revenj.Extensibility.Autofac.Core.Service,Revenj.Extensibility.Autofac.Core.IComponentRegistration,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter})">
            <summary>
            Resolve an instance of the provided registration within the context.
            </summary>
            <param name="context">provided context</param>
            <param name="service">Service which is trying to be resolved</param>
            <param name="registration">The registration.</param>
            <param name="parameters">Parameters for the instance.</param>
            <returns>
            The component instance.
            </returns>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.Registration.ComponentNotRegisteredException"/>
            <exception cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.TypedService">
            <summary>
            Identifies a service according to a type to which it can be assigned.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.TypedService.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Core.TypedService"/> class.
            </summary>
            <param name="serviceType">Type of the service.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.TypedService.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">The <paramref name="obj"/> parameter is null.</exception>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.TypedService.Equals(Revenj.Extensibility.Autofac.Core.TypedService)">
            <summary>
            Equality comparision for use in Dictionary
            </summary>
            <param name="service">service</param>
            <returns>equals</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.TypedService.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.TypedService.ChangeType(System.Type)">
            <summary>
            Return a new service of the same kind, but carrying
            <paramref name="newType"/> as the <see cref="P:Revenj.Extensibility.Autofac.Core.TypedService.ServiceType"/>.
            </summary>
            <param name="newType">The new service type.</param>
            <returns>A new service with the service type.</returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.TypedService.ServiceType">
            <summary>
            Gets the type of the service.
            </summary>
            <value>The type of the service.</value>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.TypedService.Description">
            <summary>
            Gets a human-readable description of the service.
            </summary>
            <value>The description.</value>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.RegistrationSourceAddedEventArgs">
            <summary>
            Fired when an <see cref="T:Revenj.Extensibility.Autofac.Core.IRegistrationSource"/> is added to the registry.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.RegistrationSourceAddedEventArgs.#ctor(Revenj.Extensibility.Autofac.Core.IComponentRegistry,Revenj.Extensibility.Autofac.Core.IRegistrationSource)">
            <summary>
            Construct an instance of the <see cref="T:Revenj.Extensibility.Autofac.Core.RegistrationSourceAddedEventArgs"/> class.
            </summary>
            <param name="componentRegistry">The registry to which the source was added.</param>
            <param name="registrationSource">The source that was added.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.RegistrationSourceAddedEventArgs.RegistrationSource">
            <summary>
            The registry to which the source was added.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Core.RegistrationSourceAddedEventArgs.ComponentRegistry">
            <summary>
            The source that was added.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.ContainerBuilder">
            <summary>
            Used to build an <see cref="T:Revenj.Extensibility.Autofac.IContainer"/> from component registrations.
            </summary>
            <example>
            <code>
            var builder = new ContainerBuilder();
            
            builder.RegisterType&lt;Logger&gt;()
                .As&lt;ILogger&gt;()
                .SingleInstance();
            
            builder.Register(c =&gt; new MessageHandler(c.Resolve&lt;ILogger&gt;()));
            
            var container = builder.Build();
            // resolve components from container...
            </code>
            </example>
            <remarks>Most <see cref="T:Revenj.Extensibility.Autofac.ContainerBuilder"/> functionality is accessed
            via extension methods in <see cref="T:Revenj.Extensibility.Autofac.RegistrationExtensions"/>.</remarks>
            <seealso cref="T:Revenj.Extensibility.Autofac.IContainer"/>
            <see cref="T:Revenj.Extensibility.Autofac.RegistrationExtensions"/>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ContainerBuilder.RegisterCallback(System.Action{Revenj.Extensibility.Autofac.Core.IComponentRegistry})">
            <summary>
            Register a callback that will be invoked when the container is configured.
            </summary>
            <remarks>This is primarily for extending the builder syntax.</remarks>
            <param name="configurationCallback">Callback to execute.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.ContainerBuilder.Build(Revenj.Extensibility.Autofac.Builder.ContainerBuildOptions)">
            <summary>
            Create a new container with the component registrations that have been made.
            </summary>
            <param name="options">Options that influence the way the container is initialised.</param>
            <remarks>
            Build can only be called once per <see cref="T:Revenj.Extensibility.Autofac.ContainerBuilder"/>
            - this prevents ownership issues for provided instances.
            Build enables support for the relationship types that come with Autofac (e.g.
            Func, Owned, Meta, Lazy, IEnumerable.) To exclude support for these types,
            first create the container, then call Update() on the builder.
            </remarks>
            <returns>A new container with the configured component registrations.</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.ListItemElement">
            <summary>
            Configuration for values in a list
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ListItemElement.Key">
            <summary>
            Gets the key to be set (will be converted.)
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Configuration.ListItemElement.Value">
            <summary>
            Gets the value to be set (will be converted.)
            </summary>
            <value>The value.</value>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.ExternallyOwned">
            <summary>
            Configure the component so that instances are never disposed by the container.
            </summary>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.OwnedByLifetimeScope">
            <summary>
            Configure the component so that instances that support IDisposable are
            disposed by the container (default.)
            </summary>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.InstancePerDependency">
            <summary>
            Configure the component so that every dependent component or call to Resolve()
            gets a new, unique instance (default.)
            </summary>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.SingleInstance">
            <summary>
            Configure the component so that every dependent component or call to Resolve()
            gets the same, shared instance.
            </summary>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.InstancePerLifetimeScope">
            <summary>
            Configure the component so that every dependent component or call to Resolve()
            within a single ILifetimeScope gets the same, shared instance. Dependent components in
            different lifetime scopes will get different instances.
            </summary>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.InstancePerMatchingLifetimeScope(System.Object)">
            <summary>
            Configure the component so that every dependent component or call to Resolve()
            within a ILifetimeScope tagged with the provided tag value gets the same, shared instance.
            Dependent components in lifetime scopes that are children of the tagged scope will
            share the parent's instance. If no appropriately tagged scope can be found in the
            hierarchy an <see cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/> is thrown.
            </summary>
            <param name="lifetimeScopeTag">Tag applied to matching lifetime scopes.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.InstancePerOwned``1">
            <summary>
            Configure the component so that every dependent component or call to Resolve()
            within a ILifetimeScope created by an owned instance gets the same, shared instance.
            Dependent components in lifetime scopes that are children of the owned instance scope will
            share the parent's instance. If no appropriate owned instance scope can be found in the
            hierarchy an <see cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/> is thrown.
            </summary>
            <typeparam name="TService">The service type provided by the component.</typeparam>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.InstancePerOwned(System.Type)">
            <summary>
            Configure the component so that every dependent component or call to Resolve()
            within a ILifetimeScope created by an owned instance gets the same, shared instance.
            Dependent components in lifetime scopes that are children of the owned instance scope will
            share the parent's instance. If no appropriate owned instance scope can be found in the
            hierarchy an <see cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/> is thrown.
            </summary>
            <param name="serviceType">The service type provided by the component.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.InstancePerOwned``1(System.Object)">
            <summary>
            Configure the component so that every dependent component or call to Resolve()
            within a ILifetimeScope created by an owned instance gets the same, shared instance.
            Dependent components in lifetime scopes that are children of the owned instance scope will
            share the parent's instance. If no appropriate owned instance scope can be found in the
            hierarchy an <see cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/> is thrown.
            </summary>
            <typeparam name="TService">The service type provided by the component.</typeparam>
            <param name="serviceKey">Key to associate with the component.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.InstancePerOwned(System.Object,System.Type)">
            <summary>
            Configure the component so that every dependent component or call to Resolve()
            within a ILifetimeScope created by an owned instance gets the same, shared instance.
            Dependent components in lifetime scopes that are children of the owned instance scope will
            share the parent's instance. If no appropriate owned instance scope can be found in the
            hierarchy an <see cref="T:Revenj.Extensibility.Autofac.Core.DependencyResolutionException"/> is thrown.
            </summary>
            <param name="serviceKey">Key to associate with the component.</param>
            <param name="serviceType">The service type provided by the component.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.As``1">
            <summary>
            Configure the services that the component will provide. The generic parameter(s) to As()
            will be exposed as TypedService instances.
            </summary>
            <typeparam name="TService">Service type.</typeparam>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.As``2">
            <summary>
            Configure the services that the component will provide. The generic parameter(s) to As()
            will be exposed as TypedService instances.
            </summary>
            <typeparam name="TService1">Service type.</typeparam>
            <typeparam name="TService2">Service type.</typeparam>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.As``3">
            <summary>
            Configure the services that the component will provide. The generic parameter(s) to As()
            will be exposed as TypedService instances.
            </summary>
            <typeparam name="TService1">Service type.</typeparam>
            <typeparam name="TService2">Service type.</typeparam>
            <typeparam name="TService3">Service type.</typeparam>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.As(System.Type[])">
            <summary>
            Configure the services that the component will provide.
            </summary>
            <param name="services">Service types to expose.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.As(Revenj.Extensibility.Autofac.Core.Service[])">
            <summary>
            Configure the services that the component will provide.
            </summary>
            <param name="services">Services to expose.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.Named(System.String,System.Type)">
            <summary>
            Provide a textual name that can be used to retrieve the component.
            </summary>
            <param name="serviceName">Named service to associate with the component.</param>
            <param name="serviceType">The service type provided by the component.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.Named``1(System.String)">
            <summary>
            Provide a textual name that can be used to retrieve the component.
            </summary>
            <param name="serviceName">Named service to associate with the component.</param>
            <typeparam name="TService">The service type provided by the component.</typeparam>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.Keyed(System.Object,System.Type)">
            <summary>
            Provide a key that can be used to retrieve the component.
            </summary>
            <param name="serviceKey">Key to associate with the component.</param>
            <param name="serviceType">The service type provided by the component.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.Keyed``1(System.Object)">
            <summary>
            Provide a key that can be used to retrieve the component.
            </summary>
            <param name="serviceKey">Key to associate with the component.</param>
            <typeparam name="TService">The service type provided by the component.</typeparam>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.OnPreparing(System.Action{Revenj.Extensibility.Autofac.Core.PreparingEventArgs})">
            <summary>
            Add a handler for the Preparing event. This event allows manipulating of the parameters
            that will be provided to the component.
            </summary>
            <param name="handler">The event handler.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.OnActivating(System.Action{Revenj.Extensibility.Autofac.Core.IActivatingEventArgs{`0}})">
            <summary>
            Add a handler for the Activating event.
            </summary>
            <param name="handler">The event handler.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.OnActivated(System.Action{Revenj.Extensibility.Autofac.Core.IActivatedEventArgs{`0}})">
            <summary>
            Add a handler for the Activated event.
            </summary>
            <param name="handler">The event handler.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.PropertiesAutowired(Revenj.Extensibility.Autofac.PropertyWiringFlags)">
            <summary>
            Configure the component so that any properties whose types are registered in the
            container will be wired to instances of the appropriate service.
            </summary>
            <param name="wiringFlags">Set wiring options such as circular dependency wiring support.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.WithMetadata(System.String,System.Object)">
            <summary>
            Associates data with the component.
            </summary>
            <param name="key">Key by which the data can be located.</param>
            <param name="value">The data value.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.WithMetadata(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
            <summary>
            Associates data with the component.
            </summary>
            <param name="properties">The extended properties to associate with the component.</param>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.WithMetadata``1(System.Action{Revenj.Extensibility.Autofac.Builder.MetadataConfiguration{``0}})">
            <summary>
            Associates data with the component.
            </summary>
            <typeparam name="TMetadata">A type with properties whose names correspond to the
            property names to configure.</typeparam>
            <returns>A registration builder allowing further configuration of the component.</returns>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.ActivatorData">
            <summary>
            The activator data.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.RegistrationStyle">
            <summary>
            The registration style.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.RegistrationBuilder`3.RegistrationData">
            <summary>
            The registration data.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Builder.ConcreteReflectionActivatorData">
            <summary>
            Reflection activator data for concrete types.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Builder.ConcreteReflectionActivatorData.#ctor(System.Type)">
            <summary>
            Specify a reflection activator for the given type.
            </summary>
            <param name="implementor">Type that will be activated.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Builder.ConcreteReflectionActivatorData.Activator">
            <summary>
            The instance activator based on the provided data.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.CompletedResponse">
            <summary>
            Represents a completed response message.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlQuery">
            <summary>
            Summary description for NpgsqlQuery
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ArrayNativeToBackendTypeConverter">
            <summary>
            Handles serialisation of .NET array or IEnumeration to pg format.
            Arrays of arrays, enumerations of enumerations, arrays of enumerations etc.
            are treated as multi-dimensional arrays (in much the same manner as an array of arrays
            is used to emulate multi-dimensional arrays in languages that lack native support for them).
            If such an enumeration of enumerations is "jagged" (as opposed to rectangular, cuboid,
            hypercuboid, hyperhypercuboid, etc) then this class will "correctly" serialise it, but pg
            will raise an error as it doesn't allow jagged arrays.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ArrayNativeToBackendTypeConverter.#ctor(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo)">
            <summary>
            Create an ArrayNativeToBackendTypeConverter with the element converter passed
            </summary>
            <param name="elementConverter">The <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo"/> that would be used to serialise the element type.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ArrayNativeToBackendTypeConverter.FromArray(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlNativeTypeInfo,System.Object,System.Boolean)">
            <summary>
            Serialise the enumeration or array.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ArrayBackendToNativeTypeConverter">
            <summary>
            Handles parsing of pg arrays into .NET arrays.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ArrayBackendToNativeTypeConverter.TokenEnumeration(System.String)">
            <summary>
            Takes a string representation of a pg 1-dimensional array
            (or a 1-dimensional row within an n-dimensional array)
            and allows enumeration of the string represenations of each items.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ArrayBackendToNativeTypeConverter.ArrayChunkEnumeration(System.String)">
            <summary>
            Takes a string representation of a pg n-dimensional array
            and allows enumeration of the string represenations of the next
            lower level of rows (which in turn can be taken as (n-1)-dimensional arrays.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ArrayBackendToNativeTypeConverter.RecursiveArrayListEnumeration(System.Collections.ArrayList)">
            <summary>
            Takes an ArrayList which may be an ArrayList of ArrayLists, an ArrayList of ArrayLists of ArrayLists
            and so on and enumerates the items that aren't ArrayLists (the leaf nodes if we think of the ArrayList
            passed as a tree). Simply uses the ArrayLists' own IEnumerators to get that of the next,
            pushing them onto a stack until we hit something that isn't an ArrayList.
            <param name="list"><see cref="T:System.Collections.ArrayList">ArrayList</see> to enumerate</param>
            <returns><see cref="T:System.Collections.IEnumerable">IEnumerable</see></returns>
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ArrayBackendToNativeTypeConverter.#ctor(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo)">
            <summary>
            Create a new ArrayBackendToNativeTypeConverter
            </summary>
            <param name="elementConverter"><see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo"/> for the element type.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ArrayBackendToNativeTypeConverter.ToArray(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo,System.String,System.Int16,System.Int32)">
            <summary>
            Creates an array from pg representation.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ArrayBackendToNativeTypeConverter.ToArrayList(Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlBackendTypeInfo,System.String,System.Int16,System.Int32)">
            <summary>
            Creates an array list from pg represenation of an array.
            Multidimensional arrays are treated as ArrayLists of ArrayLists
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ArrayBackendToNativeTypeConverter.ToArray(System.Collections.ArrayList,System.Type)">
            <summary>
            Creates an n-dimensional array from an ArrayList of ArrayLists or
            a 1-dimensional array from something else. 
            </summary>
            <param name="list"><see cref="T:System.Collections.ArrayList"/> to convert</param>
            <returns><see cref="T:System.Array"/> produced.</returns>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.ArrayBackendToNativeTypeConverter.IntSetIterator">
            <summary>
            Takes an array of ints and treats them like the limits of a set of counters.
            Retains a matching set of ints that is set to all zeros on the first ++
            On a ++ it increments the "right-most" int. If that int reaches it's 
            limit it is set to zero and the one before it is incremented, and so on.
            
            Making this a more general purpose class is pretty straight-forward, but we'll just put what we need here.
            </summary>
        </member>
        <member name="T:Revenj.Utility.TemporaryResources">
            <summary>
            Access to temporary files.
            Default temporary folder is created at Revenj/Temp subfolder in system temporary folder
            Can be overridden with configuration settings: TemporaryPath
            </summary>
        </member>
        <member name="M:Revenj.Utility.TemporaryResources.CreateFile(System.String)">
            <summary>
            Create file with specified extension.
            File will be created in configured temporary folder.
            </summary>
            <param name="extension">created file extension</param>
            <returns>path to created file</returns>
        </member>
        <member name="M:Revenj.Utility.TemporaryResources.TempFile(System.String)">
            <summary>
            Create file in temporary folder with specified name.
            </summary>
            <param name="name">file name</param>
            <returns>full path to created file</returns>
        </member>
        <member name="M:Revenj.Utility.TemporaryResources.LoadAssembly(System.IO.Stream)">
            <summary>
            Load assembly from provided stream. Assembly will be loaded into current AppDomain.
            Assembly will be saved to temporary folder and loaded from there.
            </summary>
            <param name="content">assembly content</param>
            <returns>loaded assembly</returns>
        </member>
        <member name="M:Revenj.Utility.TemporaryResources.LoadDynamicAssembly(System.Byte[])">
            <summary>
            Load assembly from provided content. Assembly will be loaded into current AppDomain.
            Assembly will be saved to dynamic temporary folder and loaded from there.
            </summary>
            <param name="content">assembly content</param>
            <returns>loaded assembly</returns>
        </member>
        <member name="M:Revenj.Utility.TemporaryResources.CloneFile(System.String)">
            <summary>
            Create copy of the file in the temporary folder.
            </summary>
            <param name="file">original file</param>
            <returns>path to copied file</returns>
        </member>
        <member name="M:Revenj.Utility.TemporaryResources.CreateRandomObject(System.Type)">
            <summary>
            Create instance of specified type and populate it with
            random values.
            </summary>
            <param name="target">object type</param>
            <returns>object instance</returns>
        </member>
        <member name="T:Revenj.Utility.PdfConverter">
            <summary>
            Utility for converting files to PDF.
            External PdfConverter utility will be invoked for conversion.
            Path to PdfConverter can't have whitespaces in it (since tool will be invoked using cmd.exe)
            PdfConverterTimeout specify maximum amount of time conversion can take (20 seconds by default).
            </summary>
        </member>
        <member name="M:Revenj.Utility.PdfConverter.Convert(System.Byte[],System.String)">
            <summary>
            Convert provided file content to PDF. 
            Specify extension of the file.
            </summary>
            <param name="content">file content</param>
            <param name="ext">file extension</param>
            <returns>PDF converted file</returns>
        </member>
        <member name="M:Revenj.Utility.PdfConverter.Convert(System.IO.Stream,System.String,System.Boolean)">
            <summary>
            Convert provided stream content to PDF.
            Specify extension of the file
            </summary>
            <param name="content">file content</param>
            <param name="ext">file extension</param>
            <param name="disposeStream">dispose provided stream after conversion</param>
            <returns>PDF converted stream</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.PositionalParameter">
            <summary>
            A parameter that is identified according to an integer representing its
            position in an argument list. When applied to a reflection-based
            component, <see cref="P:Revenj.Extensibility.Autofac.PositionalParameter.Position"/> will be matched against
            the indices of the component's constructor arguments. When applied to
            a delegate-based component, the parameter can be accessed using
            <see cref="M:Revenj.Extensibility.Autofac.ParameterExtensions.Positional``1(System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.Parameter},System.Int32)"/>.
            </summary>
            <example>
            Component with parameter:
            <code>
            public class MyComponent
            {
                public MyComponent(int amount) { ... }
            }
            </code>
            Providing the parameter:
            <code>
            var builder = new ContainerBuilder();
            builder.RegisterType&lt;MyComponent&gt;();
            var container = builder.Build();
            var myComponent = container.Resolve&lt;MyComponent&gt;(new PositionalParameter(0, 123));
            </code>
            </example>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.PositionalParameter.#ctor(System.Int32,System.Object)">
            <summary>
            Construct a positional parameter with the specified constant value.
            </summary>
            <param name="position">The zero-based position of the parameter.</param>
            <param name="value">The parameter value.</param>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.PositionalParameter.Position">
            <summary>
            The zero-based position of the parameter.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Features.LazyDependencies.LazyWithMetadataRegistrationSource">
            <summary>
            Support the <see cref="T:System.Lazy`2"/>
            types automatically whenever type T is registered with the container.
            Metadata values come from the component registration's metadata.
            When a dependency of a lazy type is used, the instantiation of the underlying
            component will be delayed until the Value property is first accessed.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.Indexed.KeyedServiceIndex`2.#ctor(Revenj.Extensibility.Autofac.IComponentContext)">
            <summary></summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.Indexed.KeyedServiceIndex`2.TryGetValue(`0,`1@)">
            <summary></summary>
        </member>
        <member name="P:Revenj.Extensibility.Autofac.Features.Indexed.KeyedServiceIndex`2.Item(`0)">
            <summary></summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.GeneratedFactories.GeneratedFactoryRegistrationSource.RegistrationsFor(Revenj.Extensibility.Autofac.Core.Service,System.Func{Revenj.Extensibility.Autofac.Core.Service,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.IComponentRegistration}})">
            <summary>
            Retrieve registrations for an unregistered service, to be used
            by the container.
            </summary>
            <param name="service">The service that was requested.</param>
            <param name="registrationAccessor">A function that will return existing registrations for a service.</param>
            <returns>Registrations providing the service.</returns>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Features.Collections.CollectionRegistrationSource.RegistrationsFor(Revenj.Extensibility.Autofac.Core.Service,System.Func{Revenj.Extensibility.Autofac.Core.Service,System.Collections.Generic.IEnumerable{Revenj.Extensibility.Autofac.Core.IComponentRegistration}})">
            <summary>
            Retrieve registrations for an unregistered service, to be used
            by the container.
            </summary>
            <param name="service">The service that was requested.</param>
            <param name="registrationAccessor">A function that will return existing registrations for a service.</param>
            <returns>Registrations providing the service.</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Lifetime.RootScopeLifetime">
            <summary>
            Attaches the component's lifetime to the root scope.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Lifetime.RootScopeLifetime.FindScope(Revenj.Extensibility.Autofac.Core.ISharingLifetimeScope)">
            <summary>
            Given the most nested scope visible within the resolve operation, find
            the scope for the component.
            </summary>
            <param name="mostNestedVisibleScope">The most nested visible scope.</param>
            <returns>The scope for the component.</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Core.Activators.Reflection.MatchingSignatureConstructorSelector">
            <summary>
            Selects a constructor based on its signature.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.Reflection.MatchingSignatureConstructorSelector.#ctor(System.Type[])">
            <summary>
            Match constructors with the provided signature.
            </summary>
            <param name="signature">Signature to match.</param>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Core.Activators.Reflection.MatchingSignatureConstructorSelector.SelectConstructorBinding(Revenj.Extensibility.Autofac.Core.Activators.Reflection.ConstructorParameterBinding[])">
            <summary>
            Selects the best constructor from the available constructors.
            </summary>
            <param name="constructorBindings">Available constructors.</param>
            <returns>The best constructor.</returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.Util.Enforce">
            <summary>
            Helper methods used throughout the codebase.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.Util.Enforce.ArgumentNotNull``1(``0,System.String)">
            <summary>
            Enforce that an argument is not null. Returns the
            value if valid so that it can be used inline in
            base initialiser syntax.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="name"></param>
            <returns><paramref name="value"/></returns>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.ModuleElementCollection">
            <summary>
            A collection of module elements.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.ModuleElementCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Configuration.ModuleElementCollection"/> class.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.Autofac.Configuration.AssemblyElementCollection">
            <summary>
            A collection of assembly elements.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.Autofac.Configuration.AssemblyElementCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Revenj.Extensibility.Autofac.Configuration.AssemblyElementCollection"/> class.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.MD5CryptoServiceProvider">
            <summary>
            C# implementation of the MD5 cryptographic hash function.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.MD5CryptoServiceProvider.#ctor">
            <summary>
            Creates a new MD5CryptoServiceProvider.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.MD5CryptoServiceProvider.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Drives the hashing function.
            </summary>
            <param name="rgb">Byte array containing the data to hash.</param>
            <param name="start">Where in the input buffer to start.</param>
            <param name="size">Size in bytes of the data in the buffer to hash.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.MD5CryptoServiceProvider.HashFinal">
            <summary>
            This finalizes the hash.  Takes the data from the chaining variables and returns it.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.MD5CryptoServiceProvider.Initialize">
            <summary>
            Resets the class after use.  Called automatically after hashing is done.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.MD5CryptoServiceProvider.ProcessBlock(System.Byte[],System.Int32)">
            <summary>
            This is the meat of the hash function.  It is what processes each block one at a time.
            </summary>
            <param name="inputBuffer">Byte array to process data from.</param>
            <param name="inputOffset">Where in the byte array to start processing.</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.MD5CryptoServiceProvider.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Pads and then processes the final block.
            </summary>
            <param name="inputBuffer">Buffer to grab data from.</param>
            <param name="inputOffset">Position in buffer in bytes to get data from.</param>
            <param name="inputCount">How much data in bytes in the buffer to use.</param>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlNotificationEventArgs">
            <summary>
            EventArgs class to send Notification parameters.
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlNotificationEventArgs.PID">
            <summary>
            Process ID of the PostgreSQL backend that sent this notification.
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlNotificationEventArgs.Condition">
            <summary>
            Condition that triggered that notification.
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlNotificationEventArgs.AdditionalInformation">
            <summary>
            Additional Information From Notifiying Process (for future use, currently postgres always sets this to an empty string)
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException">
            <summary>
            The exception that is thrown when the PostgreSQL backend reports errors.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.#ctor(System.Collections.IList)">
            <summary>
            Construct a backend error exception based on a list of one or more
            backend errors.  The basic Exception.Message will be built from the
            first (usually the only) error in the list.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.ToString">
            <summary>
            Format a .NET style exception string.
            Include all errors in the list, including any hints.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.AppendString(System.IO.StringWriter,System.String,System.String)">
            <summary>
            Append a line to the given Stream, first checking for zero-length.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.Item(System.Int32)">
            <summary>
            Provide access to the entire list of errors provided by the PostgreSQL backend.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.Severity">
            <summary>
            Severity code.  All versions.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.Code">
            <summary>
            Error code.  PostgreSQL 7.4 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.BaseMessage">
            <summary>
            Basic error message.  All versions.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.Detail">
            <summary>
            Detailed error message.  PostgreSQL 7.4 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.Hint">
            <summary>
            Suggestion to help resolve the error.  PostgreSQL 7.4 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.Position">
            <summary>
            Position (one based) within the query string where the error was encounterd.  PostgreSQL 7.4 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.Where">
            <summary>
            Trace back information.  PostgreSQL 7.4 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.File">
            <summary>
            Source file (in backend) reporting the error.  PostgreSQL 7.4 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.Line">
            <summary>
            Source file line number (in backend) reporting the error.  PostgreSQL 7.4 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.Routine">
            <summary>
            Source routine (in backend) reporting the error.  PostgreSQL 7.4 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.SchemaName">
            <summary>
            Schema name which relates to the error. PostgreSQL 9.3 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.TableName">
            <summary>
            Table name which relates to the error. PostgreSQL 9.3 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.ColumnName">
            <summary>
            Column name which relates to the error. PostgreSQL 9.3 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.DataTypeName">
            <summary>
            Data type of column which relates to the error. PostgreSQL 9.3 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.ConstraintName">
            <summary>
            Constraint name which relates to the error. PostgreSQL 9.3 and up.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.ErrorSql">
            <summary>
            String containing the sql sent which produced this error.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlException.Errors">
            <summary>
            Returns the entire list of errors provided by the PostgreSQL backend.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader">
            <summary>
            Provides a means of reading a forward-only stream of rows from a PostgreSQL backend.  This class cannot be inherited.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetDataTypeName(System.Int32)">
            <summary>
            Return the data type name of the column at index <param name="Index"></param>.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetFieldType(System.Int32)">
            <summary>
            Return the data type of the column at index <param name="Index"></param>.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetProviderSpecificFieldType(System.Int32)">
            <summary>
            Return the Npgsql specific data type of the column at requested ordinal.
            </summary>
            <param name="ordinal">column position</param>
            <returns>Appropriate Npgsql type for column.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetName(System.Int32)">
            <summary>
            Return the column name of the column at index <param name="Index"></param>.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetDataTypeOID(System.Int32)">
            <summary>
            Return the data type OID of the column at index <param name="Index"></param>.
            </summary>
            FIXME: Why this method returns String?
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetOrdinal(System.String)">
            <summary>
            Return the column name of the column named <param name="Name"></param>.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetFieldDbType(System.Int32)">
            <summary>
            Return the data DbType of the column at index <param name="Index"></param>.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetFieldNpgsqlDbType(System.Int32)">
            <summary>
            Return the data NpgsqlDbType of the column at index <param name="Index"></param>.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetInterval(System.Int32)">
            <summary>
            Get the value of a column as a <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/>.
            <remarks>If the differences between <see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> and <see cref="!:System.Timespan"/>
            in handling of days and months is not important to your application, use <see cref="!:GetTimeSpan()"/>
            instead.</remarks>
            </summary>
            <param name="i">Index of the field to find.</param>
            <returns><see cref="T:Revenj.DatabasePersistence.Postgres.NpgsqlTypes.NpgsqlInterval"/> value of the field.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetGuid(System.Int32)">
            <summary>
            Gets the value of a column converted to a Guid.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetInt16(System.Int32)">
            <summary>
            Gets the value of a column as Int16.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetInt32(System.Int32)">
            <summary>
            Gets the value of a column as Int32.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetInt64(System.Int32)">
            <summary>
            Gets the value of a column as Int64.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetFloat(System.Int32)">
            <summary>
            Gets the value of a column as Single.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetDouble(System.Int32)">
            <summary>
            Gets the value of a column as Double.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetString(System.Int32)">
            <summary>
            Gets the value of a column as String.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetDecimal(System.Int32)">
            <summary>
            Gets the value of a column as Decimal.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetTimeSpan(System.Int32)">
            <summary>
            Gets the value of a column as TimeSpan.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetValues(System.Object[])">
            <summary>
            Copy values from each column in the current row into <param name="Values"></param>.
            </summary>
            <returns>The number of column values copied.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetProviderSpecificValues(System.Object[])">
            <summary>
            Copy values from each column in the current row into <param name="Values"></param>.
            </summary>
            <param name="values">An array appropriately sized to store values from all columns.</param>
            <returns>The number of column values copied.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetBoolean(System.Int32)">
            <summary>
            Gets the value of a column as Boolean.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetByte(System.Int32)">
            <summary>
            Gets the value of a column as Byte.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetChar(System.Int32)">
            <summary>
            Gets the value of a column as Char.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetDateTime(System.Int32)">
            <summary>
            Gets the value of a column as DateTime.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetSchemaTable">
            <summary>
            Returns a System.Data.DataTable that describes the column metadata of the DataReader.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.GetTableNameFromQuery">
            <summary>
             This methods parses the command text and tries to get the tablename
             from it.
            </summary>
        </member>
        <member name="E:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.ReaderClosed">
            <summary>
            Is raised whenever Close() is called.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.FieldCount">
            <summary>
            Gets the number of columns in the current row.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.Item(System.Int32)">
            <summary>
            Gets the value of a column in its native format.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.Item(System.String)">
            <summary>
            Gets the value of a column in its native format.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.Depth">
            <summary>
            Gets a value indicating the depth of nesting for the current row.  Always returns zero.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.IsClosed">
            <summary>
            Gets a value indicating whether the data reader is closed.
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.KeyLookup.primaryKey">
            <summary>
            Contains the column names as the keys
            </summary>
        </member>
        <member name="F:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlDataReader.KeyLookup.uniqueColumns">
            <summary>
            Contains all unique columns
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.ForwardsOnlyDataReader">
            <summary>
            This is the primary implementation of NpgsqlDataReader. It is the one used in normal cases (where the 
            preload-reader option is not set in the connection string to resolve some potential backwards-compatibility
            issues), the only implementation used internally, and in cases where CachingDataReader is used, it is still
            used to do the actual "leg-work" of turning a response stream from the server into a datareader-style
            object - with CachingDataReader then filling it's cache from here.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.ForwardsOnlyDataReader.GetNextResponseObject">
            <summary>
            Iterate through the objects returned through from the server.
            If it's a CompletedResponse the rowsaffected count is updated appropriately,
            and we iterate again, otherwise we return it (perhaps updating our cache of pending
            rows if appropriate).
            </summary>
            <returns>The next <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.IServerResponseObject"/> we will deal with.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.ForwardsOnlyDataReader.GetNextRowDescription">
            <summary>
            Advances the data reader to the next result, when multiple result sets were returned by the PostgreSQL backend.
            </summary>
            <returns>True if the reader was advanced, otherwise false.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.ForwardsOnlyDataReader.Dispose(System.Boolean)">
            <summary>
            Releases the resources used by the <see cref="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCommand">NpgsqlCommand</see>.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.ForwardsOnlyDataReader.Close">
            <summary>
            Closes the data reader object.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.ForwardsOnlyDataReader.NextResult">
            <summary>
            Advances the data reader to the next result, when multiple result sets were returned by the PostgreSQL backend.
            </summary>
            <returns>True if the reader was advanced, otherwise false.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.ForwardsOnlyDataReader.Read">
            <summary>
            Advances the data reader to the next row.
            </summary>
            <returns>True if the reader was advanced, otherwise false.</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.ForwardsOnlyDataReader.GetValue(System.Int32)">
            <summary>
            Return the value of the column at index <param name="Index"></param>.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.ForwardsOnlyDataReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Gets raw data from a column.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.ForwardsOnlyDataReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
            <summary>
            Gets raw data from a column.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.ForwardsOnlyDataReader.IsDBNull(System.Int32)">
            <summary>
            Report whether the value in a column is DBNull.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.ForwardsOnlyDataReader.RecordsAffected">
            <summary>
            Gets the number of rows changed, inserted, or deleted by execution of the SQL statement.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.ForwardsOnlyDataReader.HasRows">
            <summary>
            Indicates if NpgsqlDatareader has rows to be read.
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.CachingDataReader">
            <summary>
            <para>Provides an implementation of NpgsqlDataReader in which all data is pre-loaded into memory.
            This operates by first creating a ForwardsOnlyDataReader as usual, and then loading all of it's
            Rows into memory. There is a general principle that when there is a trade-off between a class design that
            is more efficient and/or scalable on the one hand and one that is less efficient but has more functionality
            (in this case the internal-only functionality of caching results) that one can build the less efficent class
            from the most efficient without significant extra loss in efficiency, but not the other way around. The relationship
            between ForwardsOnlyDataReader and CachingDataReader is an example of this).</para>
            <para>Since the interface presented to the user is still forwards-only, queues are used to
            store this information, so that dequeueing as we go we give the garbage collector the best opportunity
            possible to reclaim any memory that is no longer in use.</para>
            <para>ForwardsOnlyDataReader being used to actually
            obtain the information from the server means that the "leg-work" is still only done (and need only be
            maintained) in one place.</para>
            <para>This class exists to allow for certain potential backwards-compatibility issues to be resolved
            with little effort on the part of affected users. It is considerably less efficient than ForwardsOnlyDataReader
            and hence never used internally.</para>
            </summary>
        </member>
        <member name="T:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyFormat">
            <summary>
            Represents information about COPY operation data transfer format as returned by server.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyFormat.#ctor(System.Byte,System.Int16[])">
            <summary>
            Only created when a CopyInResponse or CopyOutResponse is received by NpgsqlState.ProcessBackendResponses()
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyFormat.FieldIsBinary(System.Int32)">
            <summary>
            Returns true if this operation is currently active and field at given location is in binary format.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyFormat.IsBinary">
            <summary>
            Returns true if this operation is currently active and in binary format.
            </summary>
        </member>
        <member name="P:Revenj.DatabasePersistence.Postgres.Npgsql.NpgsqlCopyFormat.FieldCount">
            <summary>
            Returns number of fields if this operation is currently active, otherwise -1
            </summary>
        </member>
    </members>
</doc>
