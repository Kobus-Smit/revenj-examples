<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Revenj.Core.Interface</name>
    </assembly>
    <members>
        <member name="T:Revenj.CollectionExtensions">
            <summary>
            Helper methods for working with collections
            </summary>
        </member>
        <member name="M:Revenj.CollectionExtensions.UnionAll``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Add UnionAll so it is visible in Intellisense since often Concat
            should be used instead of Union.
            Union will remove duplicate elements, while UnionAll will not.
            </summary>
            <typeparam name="T">collection type</typeparam>
            <param name="first">starting collection</param>
            <param name="second">collection to be appended</param>
            <returns>concatenated collection</returns>
        </member>
        <member name="M:Revenj.CollectionExtensions.ToSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Create HashSet from source collection. Common missing LINQ method
            </summary>
            <typeparam name="T">collection type</typeparam>
            <param name="collection">source collection</param>
            <returns>collection as set</returns>
        </member>
        <member name="T:Revenj.Common.FrameworkException">
            <summary>
            Generic framework exception.
            For internal errors:
            * incorrect plugin configuration
            * framework asserts
            ...
            </summary>
        </member>
        <member name="M:Revenj.Common.FrameworkException.#ctor">
            <summary>
            Please provide meaningful message for exception.
            </summary>
        </member>
        <member name="M:Revenj.Common.FrameworkException.#ctor(System.String)">
            <summary>
            Error with small meaningful description.
            </summary>
            <param name="message">description</param>
        </member>
        <member name="M:Revenj.Common.FrameworkException.#ctor(System.String,System.Exception)">
            <summary>
            Bubble up exception with additional description.
            </summary>
            <param name="message">description</param>
            <param name="inner">exception that caused this error</param>
        </member>
        <member name="M:Revenj.Common.FrameworkException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor for deserialization
            </summary>
            <param name="info">serialization info</param>
            <param name="context">serialization context</param>
        </member>
        <member name="T:Revenj.StringExtensions">
            <summary>
            Helper methods for working with strings.
            Instead of string.Format("....", ...) write "....".With(...)
            </summary>
        </member>
        <member name="M:Revenj.StringExtensions.With(System.String,System.Object)">
            <summary>
            Single argument helper method.
            "print {0} now".With(arg)
            </summary>
            <param name="value">template string</param>
            <param name="arg">formatting argument</param>
            <returns>formatted string</returns>
        </member>
        <member name="M:Revenj.StringExtensions.With(System.String,System.Object,System.Object)">
            <summary>
            Double argument helper method.
            "print {0} {1}".With(arg1, arg2)
            </summary>
            <param name="value">template string</param>
            <param name="arg1">first formatting argument</param>
            <param name="arg2">second formatting argument</param>
            <returns>formatted string</returns>
        </member>
        <member name="M:Revenj.StringExtensions.With(System.String,System.Object,System.Object,System.Object)">
            <summary>
            Triple argument helper method.
            "print {0}, {1} and {2}".With(arg1, arg2, arg3)
            </summary>
            <param name="value">template string</param>
            <param name="arg1">first formatting argument</param>
            <param name="arg2">second formatting argument</param>
            <param name="arg3">third formatting argument</param>
            <returns>formatted string</returns>
        </member>
        <member name="M:Revenj.StringExtensions.With(System.String,System.Object[])">
            <summary>
            Generic helper method. For unlimited number of arguments
            "print {0} ... {n}".With(arg1, ... argN)
            </summary>
            <param name="value">template string</param>
            <param name="args">formatting arguments</param>
            <returns>formatted string</returns>
        </member>
        <member name="T:Revenj.DatabasePersistence.IDatabaseQuery">
            <summary>
            ADO.NET database abstraction.
            Execute SQL queries on database.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.IDatabaseQuery.NewCommand">
            <summary>
            Create new database command for specific ADO.NET driver.
            </summary>
            <returns>new command</returns>
        </member>
        <member name="P:Revenj.DatabasePersistence.IDatabaseQuery.InTransaction">
            <summary>
            Is current query inside a transaction.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.IDatabaseQuery.Execute(System.Data.IDbCommand)">
            <summary>
            Execute query on the database without the regards for result.
            Connection and transaction information will be appended to the provided command.
            command.Execute() will be called.
            </summary>
            <param name="command">database command</param>
            <returns>base ExecuteNonQuery result</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.IDatabaseQuery.Execute(System.Data.IDbCommand,System.Action{System.Data.IDataReader})">
            <summary>
            Execute query on the database and loop through the reader.
            Connection and transaction information will be appended to the provided command.
            command.ExecuteDataReader() will be called.
            </summary>
            <param name="command">database command</param>
            <param name="action">handle result returned from the database</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.IDatabaseQuery.Fill(System.Data.IDbCommand,System.Data.DataSet)">
            <summary>
            Execute query on the database and fill DataSet with the result.
            Connection and transaction information will be appended to the provided command.
            </summary>
            <param name="command">command to execute</param>
            <param name="ds">data set to fill</param>
            <returns>how many rows were changed</returns>
        </member>
        <member name="T:Revenj.DatabasePersistence.DatabaseQueryHelper">
            <summary>
            Utilities for ADO.NET access.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.DatabaseQueryHelper.Field``1(System.Data.IDataRecord,System.String)">
            <summary>
            Read field from the record.
            </summary>
            <typeparam name="T">field type</typeparam>
            <param name="dr">data reader</param>
            <param name="name">field name</param>
            <returns>field value</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.DatabaseQueryHelper.Execute(Revenj.DatabasePersistence.IDatabaseQuery,System.String,System.Object[])">
            <summary>
            Execute query on the database without the regards for result.
            Connection and transaction information will be appended to the provided command.
            </summary>
            <param name="query">ADO.NET driver</param>
            <param name="sql">SQL to execute</param>
            <param name="parameters">SQL parameters</param>
            <returns>comand.Execute() result</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.DatabaseQueryHelper.CreateCommand(Revenj.DatabasePersistence.IDatabaseQuery,System.String,System.Object[])">
            <summary>
            Create database command using provided SQL and by
            replacing ? with parameter arguments.
            </summary>
            <param name="query">ADO.NET driver</param>
            <param name="sql">SQL to execute</param>
            <param name="parameters">parameters to bind</param>
            <returns></returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.DatabaseQueryHelper.Execute(Revenj.DatabasePersistence.IDatabaseQuery,System.String,System.Action{System.Data.IDataReader},System.Object[])">
            <summary>
            Execute query on the database and loop through the reader.
            Connection and transaction information will be appended to the provided command.
            Provided parameters will be inserted into the command.
            command.ExecuteDataReader() will be called.
            </summary>
            <param name="query">ADO.NET driver</param>
            <param name="sql">SQL to execute</param>
            <param name="action">data reader converter</param>
            <param name="parameters">command parameters</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.DatabaseQueryHelper.Fill``1(Revenj.DatabasePersistence.IDatabaseQuery,System.String,System.Func{System.Data.IDataReader,``0},System.Object[])">
            <summary>
            Execute query on the database and loop through the reader.
            Return list populated from instance factory.
            Connection and transaction information will be appended to the provided command.
            command.ExecuteDataReader() will be called.
            </summary>
            <typeparam name="T">result type</typeparam>
            <param name="query">ADO.NET driver</param>
            <param name="sql">SQL to execute</param>
            <param name="instancer">object factory</param>
            <param name="parameters">additional command parameters</param>
            <returns>populated list</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.DatabaseQueryHelper.Fill(Revenj.DatabasePersistence.IDatabaseQuery,System.String,System.Object[])">
            <summary>
            Execute query on the database and fill DataTable with the result.
            Connection and transaction information will be appended to the provided command.
            </summary>
            <param name="query">ADO.NET driver</param>
            <param name="sql">SQL to execute</param>
            <param name="parameters">SQL additional parameters</param>
            <returns>populated table</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.DatabaseQueryHelper.Fill(Revenj.DatabasePersistence.IDatabaseQuery,System.Data.IDbCommand)">
            <summary>
            Execute query on the database and fill DataTable with the result.
            Connection and transaction information will be appended to the provided command.
            </summary>
            <param name="query">ADO.NET driver</param>
            <param name="command">command to execute</param>
            <returns>populated table</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.DatabaseQueryHelper.Get``1(Revenj.DatabasePersistence.IDatabaseQuery,System.String,System.Func{System.Data.IDataReader,``0},System.Object[])">
            <summary>
            Execute query on the database and return converted result.
            Connection and transaction information will be appended to the provided command.
            </summary>
            <typeparam name="T">result type</typeparam>
            <param name="query">ADO.NET driver</param>
            <param name="sql">SQL to execute</param>
            <param name="instancer">object factory</param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="T:Revenj.DatabasePersistence.IDatabaseQueryManager">
            <summary>
            ADO.NET driver manager.
            Create new database drivers and close existing ones.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.IDatabaseQueryManager.StartQuery(System.Boolean)">
            <summary>
            Start new ADO.NET driver.
            If query is created with a transaction, it must be explicitly committed.
            </summary>
            <param name="withTransaction">use transaction</param>
            <returns>database query</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.IDatabaseQueryManager.EndQuery(Revenj.DatabasePersistence.IDatabaseQuery,System.Boolean)">
            <summary>
            Close existing ADO.NET driver.
            If query is created with a transaction provide true for success to commit transaction.
            </summary>
            <param name="query">database query</param>
            <param name="success">was query successful</param>
        </member>
        <member name="T:Revenj.DatabasePersistence.DatabaseQueryManagerHelper">
            <summary>
            Utilities for ADO.NET driver manager.
            </summary>
        </member>
        <member name="M:Revenj.DatabasePersistence.DatabaseQueryManagerHelper.BeginTransaction(Revenj.DatabasePersistence.IDatabaseQueryManager)">
            <summary>
            Start database query with a transaction.
            </summary>
            <param name="manager">query manager</param>
            <returns>ADO.NET driver</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.DatabaseQueryManagerHelper.CreateQuery(Revenj.DatabasePersistence.IDatabaseQueryManager)">
            <summary>
            Start database query without a transaction.
            </summary>
            <param name="manager">query manager</param>
            <returns>ADO.NET driver</returns>
        </member>
        <member name="M:Revenj.DatabasePersistence.DatabaseQueryManagerHelper.Commit(Revenj.DatabasePersistence.IDatabaseQueryManager,Revenj.DatabasePersistence.IDatabaseQuery)">
            <summary>
            Commit started transaction.
            </summary>
            <param name="manager">query manager</param>
            <param name="query">ADO.NET driver</param>
        </member>
        <member name="M:Revenj.DatabasePersistence.DatabaseQueryManagerHelper.Rollback(Revenj.DatabasePersistence.IDatabaseQueryManager,Revenj.DatabasePersistence.IDatabaseQuery)">
            <summary>
            Rollback started transaction.
            </summary>
            <param name="manager">query manager</param>
            <param name="query">ADO.NET driver</param>
        </member>
        <member name="T:Revenj.DomainPatterns.IDataCache`1">
            <summary>
            Data cache service using uri lookup.
            Identifiable object resolved from this service will be cached.
            Invalidate uris on object change.
            </summary>
            <typeparam name="TValue">domain object type</typeparam>
        </member>
        <member name="M:Revenj.DomainPatterns.IDataCache`1.Invalidate(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Changed objects should be removed from cache.
            </summary>
            <param name="uris">changed uris</param>
        </member>
        <member name="T:Revenj.DomainPatterns.IDataSourceCache`1">
            <summary>
            Entire data source cache service.
            When entire class of objects is kept in memory, data source cache can be used.
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Revenj.DomainPatterns.IDataSourceCache`1.InvalidateAll">
            <summary>
            Invalidate entire cache.
            </summary>
        </member>
        <member name="T:Revenj.DomainPatterns.ICacheable">
            <summary>
            Cacheable domain objects.
            Dependencies can be tracked through relationship,
            so invalidation can be detected.
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.ICacheable.GetRelationships">
            <summary>
            Get relationship for this domain object.
            </summary>
            <returns>collection of referenced types and uris</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.CacheHelper">
            <summary>
            Cache utility
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.CacheHelper.Invalidate``1(Revenj.DomainPatterns.IDataCache{``0},System.String)">
            <summary>
            Invalidate single aggregate root.
            </summary>
            <typeparam name="TValue">aggregate root type</typeparam>
            <param name="cache">cache service</param>
            <param name="uri">uri to invalidate</param>
        </member>
        <member name="M:Revenj.DomainPatterns.CacheHelper.GetInvalidValues``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Build dependency collection information.
            Collect invalid types and uris for provided domain objects.
            </summary>
            <typeparam name="TValue">domain object type</typeparam>
            <param name="values">domain objects</param>
            <returns>dependency collection information</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.IDataContext">
            <summary>
            Access to data. Proxy to various features, such as 
            repositories, reports, notifications, OLAP, validation...
            Cache will be used if available.
            Data is available using current scope.
            If transaction is used, changes will be visible to other scopes only after commit.
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.IDataContext.Find``1(System.String)">
            <summary>
            Find identifiable data from provided URI
            </summary>
            <typeparam name="T">data type</typeparam>
            <param name="uri">identity</param>
            <returns>found value</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IDataContext.Find``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Find identifiable data from provided URIs
            </summary>
            <typeparam name="T">data type</typeparam>
            <param name="uris">identification</param>
            <returns>found values</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IDataContext.Query``1">
            <summary>
            LINQ queries to data
            </summary>
            <typeparam name="T">data type</typeparam>
            <returns>LINQ projection</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IDataContext.Search``1(Revenj.DomainPatterns.ISpecification{``0},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Search data using provided specification.
            Specification is optional.
            </summary>
            <typeparam name="T">data type</typeparam>
            <param name="filter">filter predicate</param>
            <param name="limit">limit maximum number of results</param>
            <param name="offset">skip initial results</param>
            <returns>found items</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IDataContext.Count``1(Revenj.DomainPatterns.ISpecification{``0})">
            <summary>
            Count data using provided specification.
            Specification is optional.
            </summary>
            <typeparam name="T">data type</typeparam>
            <param name="filter">filter predicate</param>
            <returns>total found items</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IDataContext.Exists``1(Revenj.DomainPatterns.ISpecification{``0})">
            <summary>
            Check if data exists using provided specification.
            Specification is optional.
            </summary>
            <typeparam name="T">data type</typeparam>
            <param name="filter">filter predicate</param>
            <returns>items exists</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IDataContext.Create``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Create new aggregate roots. 
            Data will be sent immediately to the backing store.
            </summary>
            <typeparam name="T">aggregate type</typeparam>
            <param name="aggregates">new aggregates</param>
        </member>
        <member name="M:Revenj.DomainPatterns.IDataContext.Update``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``0}})">
            <summary>
            Update existing aggregate roots. Provide pair of old and new.
            Old value is optional. Change track value will be used on null values.
            Lookup to DB will be performed if neither old value or change track value is available.
            Data will be sent immediately to the backing store.
            </summary>
            <typeparam name="T">aggregate type</typeparam>
            <param name="pairs">aggregate pairs</param>
        </member>
        <member name="M:Revenj.DomainPatterns.IDataContext.Delete``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Delete existing aggregate roots.
            Data will be sent immediately to the backing store.
            </summary>
            <typeparam name="T">aggregate type</typeparam>
            <param name="aggregates">remove provided aggregate roots</param>
        </member>
        <member name="M:Revenj.DomainPatterns.IDataContext.Submit``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Raise domain events (within current transaction)
            If currently inside transaction and transaction is rolled back, event will not be saved
            </summary>
            <typeparam name="T">event type</typeparam>
            <param name="events">domain events</param>
        </member>
        <member name="M:Revenj.DomainPatterns.IDataContext.Queue``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Queue domain event for out-of-transaction submission to the store
            If error happens during submission (loss of power, DB connection problems, event will be lost)
            If current transaction is rolled back, event will still be persisted
            </summary>
            <typeparam name="T">event type</typeparam>
            <param name="events">domain events</param>
        </member>
        <member name="M:Revenj.DomainPatterns.IDataContext.Populate``1(Revenj.DomainPatterns.IReport{``0})">
            <summary>
            Populate report
            </summary>
            <typeparam name="T">report type</typeparam>
            <param name="report">arguments for report</param>
            <returns>populated report</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IDataContext.Track``1">
            <summary>
            Change tracking.
            </summary>
            <typeparam name="T">data type</typeparam>
            <returns>notifications</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IDataContext.History``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            History for aggregate root changes.
            </summary>
            <typeparam name="T">aggregate type</typeparam>
            <param name="uris">identifiers</param>
            <returns>found history</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IDataContext.CubeBuilder``2">
            <summary>
            OLAP cube builder. Data analysis using dimensions and facts
            </summary>
            <typeparam name="TCube">cube type</typeparam>
            <typeparam name="TSource">cube source type</typeparam>
            <returns>cube builder</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IDataContext.InvalidItems``2(Revenj.DomainPatterns.ISpecification{``1})">
            <summary>
            Data which fails specified validation.
            Filtered using provided specification.
            </summary>
            <typeparam name="TValidation">validation type</typeparam>
            <typeparam name="TResult">validation target</typeparam>
            <param name="specification">search only subset of data</param>
            <returns>found invalid items</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.DataContextHelper">
            <summary>
            Data context helper methods
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.DataContextHelper.Search``1(Revenj.DomainPatterns.IDataContext,Revenj.DomainPatterns.ISpecification{``0})">
            <summary>
            Search data using provided specification.
            </summary>
            <typeparam name="T">data type</typeparam>
            <param name="context">data context</param>
            <param name="filter">filter predicate</param>
            <returns>found items</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.DataContextHelper.Search``1(Revenj.DomainPatterns.IDataContext)">
            <summary>
            Search all data.
            </summary>
            <typeparam name="T">data type</typeparam>
            <param name="context">data context</param>
            <returns>found items</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.DataContextHelper.Count``1(Revenj.DomainPatterns.IDataContext)">
            <summary>
            Count all data.
            </summary>
            <typeparam name="T">data type</typeparam>
            <param name="context">data context</param>
            <returns>total found items</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.DataContextHelper.Exists``1(Revenj.DomainPatterns.IDataContext)">
            <summary>
            Data exists.
            </summary>
            <typeparam name="T">data type</typeparam>
            <param name="context">data context</param>
            <returns>items exists</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.DataContextHelper.Create``1(Revenj.DomainPatterns.IDataContext,``0)">
            <summary>
            Create new aggregate root.
            Data will be sent immediately to the backing store.
            </summary>
            <typeparam name="T">aggregate type</typeparam>
            <param name="context">data context</param>
            <param name="root">root instance</param>
        </member>
        <member name="M:Revenj.DomainPatterns.DataContextHelper.Update``1(Revenj.DomainPatterns.IDataContext,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Bulk update existing aggregate roots.
            Data will be sent immediately to the backing store.
            Change tracking value will be used if available.
            </summary>
            <typeparam name="T">aggregate type</typeparam>
            <param name="context">data context</param>
            <param name="aggregates">aggregate root instances</param>
        </member>
        <member name="M:Revenj.DomainPatterns.DataContextHelper.Update``1(Revenj.DomainPatterns.IDataContext,``0[])">
            <summary>
            Bulk update existing aggregate roots.
            Data will be sent immediately to the backing store.
            Change tracking value will be used if available.
            </summary>
            <typeparam name="T">aggregate type</typeparam>
            <param name="context">data context</param>
            <param name="aggregates">aggregate root instances</param>
        </member>
        <member name="M:Revenj.DomainPatterns.DataContextHelper.Update``1(Revenj.DomainPatterns.IDataContext,System.Collections.Generic.List{``0})">
            <summary>
            Bulk update existing aggregate roots.
            Data will be sent immediately to the backing store.
            Change tracking value will be used if available.
            </summary>
            <typeparam name="T">aggregate type</typeparam>
            <param name="context">data context</param>
            <param name="aggregates">aggregate root instances</param>
        </member>
        <member name="M:Revenj.DomainPatterns.DataContextHelper.Update``1(Revenj.DomainPatterns.IDataContext,``0)">
            <summary>
            Update existing aggregate root.
            Data will be sent immediately to the backing store.
            Change tracking value will be used if available.
            </summary>
            <typeparam name="T">aggregate type</typeparam>
            <param name="context">data context</param>
            <param name="root">root instance</param>
        </member>
        <member name="M:Revenj.DomainPatterns.DataContextHelper.Update``1(Revenj.DomainPatterns.IDataContext,``0,``0)">
            <summary>
            Update existing aggregate root.
            Data will be sent immediately to the backing store.
            </summary>
            <typeparam name="T">aggregate type</typeparam>
            <param name="context">data context</param>
            <param name="oldRoot">old instance</param>
            <param name="newRoot">new instance</param>
        </member>
        <member name="M:Revenj.DomainPatterns.DataContextHelper.Delete``1(Revenj.DomainPatterns.IDataContext,``0)">
            <summary>
            Delete existing aggregate root.
            Data will be sent immediately to the backing store.
            </summary>
            <typeparam name="T">aggregate type</typeparam>
            <param name="context">data context</param>
            <param name="root">root instance</param>
        </member>
        <member name="M:Revenj.DomainPatterns.DataContextHelper.History``1(Revenj.DomainPatterns.IDataContext,System.String)">
            <summary>
            Find history for provided aggregate root.
            </summary>
            <typeparam name="T">aggregate type</typeparam>
            <param name="context">data context</param>
            <param name="uri">root URI</param>
            <returns>found history</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.DataContextHelper.InvalidItems``2(Revenj.DomainPatterns.IDataContext)">
            <summary>
            Data which fails specified validation.
            </summary>
            <typeparam name="TValidation">validation type</typeparam>
            <typeparam name="TResult">validation target</typeparam>
            <returns>found invalid items</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.DataContextHelper.Submit``1(Revenj.DomainPatterns.IDataContext,``0)">
            <summary>
            Submit single Domain Event
            If currently inside transaction and transaction is rolled back, event will not be saved
            </summary>
            <typeparam name="TEvent">domain event type</typeparam>
            <param name="context">data context</param>
            <param name="domainEvent">domain event</param>
        </member>
        <member name="M:Revenj.DomainPatterns.DataContextHelper.Queue``1(Revenj.DomainPatterns.IDataContext,``0)">
            <summary>
            Queue domain event for out-of-transaction submission to the store
            If error happens during submission (loss of power, DB connection problems, event will be lost)
            If current transaction is rolled back, event will still be persisted
            </summary>
            <typeparam name="TEvent">domain event type</typeparam>
            <param name="context">data context</param>
            <param name="domainEvent">domain event</param>
        </member>
        <member name="T:Revenj.DomainPatterns.NotifyInfo">
            <summary>
            Notification information.
            </summary>
        </member>
        <member name="F:Revenj.DomainPatterns.NotifyInfo.Name">
            <summary>
            Domain object name
            </summary>
        </member>
        <member name="F:Revenj.DomainPatterns.NotifyInfo.Operation">
            <summary>
            Type of operation
            </summary>
        </member>
        <member name="F:Revenj.DomainPatterns.NotifyInfo.Source">
            <summary>
            Source of notification
            </summary>
        </member>
        <member name="F:Revenj.DomainPatterns.NotifyInfo.URI">
            <summary>
            Object identifiers
            </summary>
        </member>
        <member name="T:Revenj.DomainPatterns.NotifyInfo.OperationEnum">
            <summary>
            Operation types
            </summary>
        </member>
        <member name="F:Revenj.DomainPatterns.NotifyInfo.OperationEnum.Insert">
            <summary>
            Aggregate root or event insert
            </summary>
        </member>
        <member name="F:Revenj.DomainPatterns.NotifyInfo.OperationEnum.Update">
            <summary>
            Aggregate root was changed, but URI remained the same
            </summary>
        </member>
        <member name="F:Revenj.DomainPatterns.NotifyInfo.OperationEnum.Change">
            <summary>
            Aggregate root was changed and URI is changed also
            </summary>
        </member>
        <member name="F:Revenj.DomainPatterns.NotifyInfo.OperationEnum.Delete">
            <summary>
            Aggregate root was deleted
            </summary>
        </member>
        <member name="T:Revenj.DomainPatterns.NotifyInfo.SourceEnum">
            <summary>
            Where did the notification originate from
            </summary>
        </member>
        <member name="F:Revenj.DomainPatterns.NotifyInfo.SourceEnum.Database">
            <summary>
            Notification originated from the database
            </summary>
        </member>
        <member name="F:Revenj.DomainPatterns.NotifyInfo.SourceEnum.Local">
            <summary>
            Notification originated from the local server
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.NotifyInfo.#ctor(System.String,Revenj.DomainPatterns.NotifyInfo.OperationEnum,Revenj.DomainPatterns.NotifyInfo.SourceEnum,System.String[])">
            <summary>
            Create notification information
            </summary>
            <param name="name">domain object name</param>
            <param name="operation">operation type</param>
            <param name="source">notification source</param>
            <param name="uri">identifiers</param>
        </member>
        <member name="M:Revenj.DomainPatterns.NotifyInfo.#ctor(System.String,Revenj.DomainPatterns.NotifyInfo.OperationEnum,System.String[])">
            <summary>
            Create notification information originating from local server
            </summary>
            <param name="name">domain object name</param>
            <param name="operation">operation type</param>
            <param name="source">notification source</param>
            <param name="uri">identifiers</param>
        </member>
        <member name="T:Revenj.DomainPatterns.IDataChangeNotification">
            <summary>
            Change notification service.
            When aggregate root are persisted or events are submitted,
            notification will be available through this service.
            </summary>
        </member>
        <member name="P:Revenj.DomainPatterns.IDataChangeNotification.Notifications">
            <summary>
            Observe notifications
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.IDataChangeNotification.Track``1">
            <summary>
            Specify interest in only subset of notifications.
            </summary>
            <typeparam name="T">domain object type</typeparam>
            <returns>pair of domain object identifiers, with lazily reified instance</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.IReport`1">
            <summary>
            Report service will gather data from its specification.
            </summary>
            <typeparam name="TData">result type</typeparam>
        </member>
        <member name="M:Revenj.DomainPatterns.IReport`1.Populate(System.IServiceProvider)">
            <summary>
            Create result object.
            </summary>
            <param name="locator">service locator</param>
            <returns>populated result</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.IDocumentReport`1">
            <summary>
            Document report is a service for populating documents.
            </summary>
            <typeparam name="TData">population argument</typeparam>
        </member>
        <member name="M:Revenj.DomainPatterns.IDocumentReport`1.Create(`0)">
            <summary>
            Create document from provided data
            </summary>
            <param name="data">used for document population</param>
            <returns>populated document</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.IOlapCubeQuery`1">
            <summary>
            Service for running queries against OLAP cube.
            Pick and choose interesting dimension and fact and run aggregation on them.
            </summary>
        </member>
        <member name="P:Revenj.DomainPatterns.IOlapCubeQuery`1.Dimensions">
            <summary>
            Available dimensions
            </summary>
        </member>
        <member name="P:Revenj.DomainPatterns.IOlapCubeQuery`1.Facts">
            <summary>
            Available facts
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.IOlapCubeQuery`1.Analyze(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Boolean}},Revenj.DomainPatterns.ISpecification{`0},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Run analysis on data. 
            Data will be grouped by specified dimensions.
            Aggregation will be run on specified facts.
            Data will be returned in specified order.
            Specification is used to filter only subset of data.
            </summary>
            <param name="dimensions">dimension subset</param>
            <param name="facts">fact subset</param>
            <param name="order">custom order</param>
            <param name="filter">predicate filter</param>
            <param name="limit">maximum number of rows</param>
            <param name="offset">how many initial rows to skip</param>
            <returns>result from created query</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.OlapCubeQueryHelper">
            <summary>
            Utility for easier use of OLAP cube
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.OlapCubeQueryHelper.Analyze``1(Revenj.DomainPatterns.IOlapCubeQuery{``0},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Boolean}},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Run analysis an all data.
            Data will be grouped by specified dimensions.
            Aggregation will be run on specified facts.
            Data will be returned in specified order.
            </summary>
            <param name="query">cube query</param>
            <param name="dimensions">dimension subset</param>
            <param name="facts">fact subset</param>
            <param name="order">custom order</param>
            <param name="limit">maximum number of row</param>
            <param name="offset">how many initial rows to skip</param>
            <returns>result from created query</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.OlapCubeQueryHelper.Builder``1(Revenj.DomainPatterns.IOlapCubeQuery{``0})">
            <summary>
            Create OLAP cube builder with fluent API.
            </summary>
            <param name="query">OLAP cube</param>
            <returns>builder</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.OlapCubeQueryBuilder`1">
            <summary>
            Fluent interface for building OLAP query.
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.OlapCubeQueryBuilder`1.#ctor(Revenj.DomainPatterns.IOlapCubeQuery{`0})">
            <summary>
            Original OLAP cube query.
            </summary>
            <param name="query">OLAP cube query</param>
        </member>
        <member name="M:Revenj.DomainPatterns.OlapCubeQueryBuilder`1.Use(System.String)">
            <summary>
            Use dimension or fact.
            Group by dimension or aggregate by fact.
            </summary>
            <param name="dimensionOrFact">dimension or fact</param>
            <returns>itself</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.OlapCubeQueryBuilder`1.Ascending(System.String)">
            <summary>
            Use ascending order for specific dimension or fact.
            </summary>
            <param name="result">sort column</param>
            <returns>itself</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.OlapCubeQueryBuilder`1.Descending(System.String)">
            <summary>
            Use descending order for specific dimension or fact.
            </summary>
            <param name="result">sort column</param>
            <returns>itself</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.OlapCubeQueryBuilder`1.Take(System.Int32)">
            <summary>
            Limit maximum results returned from analysis.
            </summary>
            <param name="limit">maximum results</param>
            <returns>itself</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.OlapCubeQueryBuilder`1.Limit(System.Int32)">
            <summary>
            Limit maximum results returned from analysis.
            </summary>
            <param name="limit">maximum results</param>
            <returns>itself</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.OlapCubeQueryBuilder`1.Skip(System.Int32)">
            <summary>
            Skip initial results returned from analysis.
            </summary>
            <param name="offset">skipped results</param>
            <returns>itself</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.OlapCubeQueryBuilder`1.Offset(System.Int32)">
            <summary>
            Skip initial results returned from analysis.
            </summary>
            <param name="offset">skipped results</param>
            <returns>itself</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.OlapCubeQueryBuilder`1.Analyze">
            <summary>
            Load query data by running analysis on all data.
            </summary>
            <returns>aggregated information</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.OlapCubeQueryBuilder`1.Analyze(Revenj.DomainPatterns.ISpecification{`0})">
            <summary>
            Load query data by running analysis on subset of data.
            Specification predicate is used to filter data.
            </summary>
            <param name="specification">predicate filter</param>
            <returns>aggregated information</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.IDomainEvent">
            <summary>
            Server domain event signature.
            Domain event is meaningful business event which has happened and was logged.
            </summary>
        </member>
        <member name="P:Revenj.DomainPatterns.IDomainEvent.QueuedAt">
            <summary>
            Queue time
            </summary>
        </member>
        <member name="P:Revenj.DomainPatterns.IDomainEvent.ProcessedAt">
            <summary>
            When domain event was processed
            </summary>
        </member>
        <member name="T:Revenj.DomainPatterns.IDomainEvent`1">
            <summary>
            Domain event which is bound to an aggregate.
            Async events will be replayed on the aggregate during aggregate reconstruction.
            </summary>
            <typeparam name="TAggregate">aggregate root type</typeparam>
        </member>
        <member name="M:Revenj.DomainPatterns.IDomainEvent`1.Apply(`0)">
            <summary>
            Apply domain event on an aggregate root
            </summary>
            <param name="aggregate">aggregate root instance</param>
        </member>
        <member name="T:Revenj.DomainPatterns.IDomainEventSource`1">
            <summary>
            Domain event-sourcing. 
            Processed domain events will be raised and available through the observable Events property.
            </summary>
            <typeparam name="TEvent">domain event type</typeparam>
        </member>
        <member name="P:Revenj.DomainPatterns.IDomainEventSource`1.Events">
            <summary>
            Processed domain events
            </summary>
        </member>
        <member name="T:Revenj.DomainPatterns.IDomainEventSource">
            <summary>
            Domain event-sourcing.
            Processed domain events will be raised and available for registered event types.
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.IDomainEventSource.Track``1">
            <summary>
            Register for specific domain events.
            </summary>
            <typeparam name="TEvent">domain event type</typeparam>
            <returns>observable to processed domain events</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.IDomainEventStore`1">
            <summary>
            Domain event store.
            Events can only be submitted. Submitted events can't be changed.
            Async events can be marked as processed at a later time.
            </summary>
            <typeparam name="TEvent">domain event type</typeparam>
        </member>
        <member name="M:Revenj.DomainPatterns.IDomainEventStore`1.Submit(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Submit domain events to the store.
            After submission event will get an unique identifier.
            </summary>
            <param name="events">domain events</param>
            <returns>event identifiers</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IDomainEventStore`1.Mark(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Mark unprocessed events as processed.
            </summary>
            <param name="uris">event identifiers</param>
        </member>
        <member name="M:Revenj.DomainPatterns.IDomainEventStore`1.GetQueue">
            <summary>
            Get unprocessed events.
            </summary>
            <returns>unprocessed events</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.IDomainEventStore">
            <summary>
            Domain event store.
            Events can only be submitted. Submitted events can't be changed.
            Async events can be marked as processed at a latter time.
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.IDomainEventStore.Submit``1(``0)">
            <summary>
            Submit domain event to the store.
            After submission event will get an unique identifier
            </summary>
            <typeparam name="TEvent">domain event type</typeparam>
            <param name="domainEvent">domain event</param>
            <returns>event identifier</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IDomainEventStore.Queue``1(``0)">
            <summary>
            Queue domain event for out-of-transaction submission to the store
            If error happens during submission (loss of power, DB connection problems, event will be lost)
            If current transaction is rolled back, event will still be persisted
            </summary>
            <typeparam name="TEvent">domain event type</typeparam>
            <param name="domainEvent">domain event</param>
        </member>
        <member name="T:Revenj.DomainPatterns.IDomainEventHandler`1">
            <summary>
            Handle domain event.
            When domain event is processed by the server, all domain event handlers are invoked to
            process it. If one domain event handler throws an exception, entire submission is canceled.
            If Event[] is used, collection of events can be processed at once.
            </summary>
            <typeparam name="TEvent">domain event type</typeparam>
        </member>
        <member name="M:Revenj.DomainPatterns.IDomainEventHandler`1.Handle(`0)">
            <summary>
            Handle domain event submission.
            </summary>
            <param name="input">processing domain event(s)</param>
        </member>
        <member name="T:Revenj.DomainPatterns.DomainEventHelper">
            <summary>
            Utility for domain events
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.DomainEventHelper.Submit``1(Revenj.DomainPatterns.IDomainEventStore{``0},``0)">
            <summary>
            Submit single domain event to the store.
            Redirects call to the collection API.
            </summary>
            <typeparam name="TEvent">domain event type</typeparam>
            <param name="store">domain event store</param>
            <param name="domainEvent">raise domain event</param>
            <returns>event identifier</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.DomainEventHelper.Mark``1(Revenj.DomainPatterns.IDomainEventStore{``0},``0)">
            <summary>
            Mark single domain event as processed.
            Redirects call to the collection API.
            </summary>
            <typeparam name="TEvent">domain event type</typeparam>
            <param name="store">domain event store</param>
            <param name="domainEvent">mark domain event as processed</param>
        </member>
        <member name="T:Revenj.DomainPatterns.IDomainModel">
            <summary>
            Access to domain model. 
            Domain model can be dynamic, so access to them is available through this API.
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.IDomainModel.Find(System.String)">
            <summary>
            Find domain object type by its name.
            If domain object is not found, null will be returned.
            </summary>
            <param name="name">domain object name</param>
            <returns>found domain object type</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.IObjectHistory">
            <summary>
            Domain object which provides access to it's history
            </summary>
        </member>
        <member name="T:Revenj.DomainPatterns.IHistory`1">
            <summary>
            Collection of aggregate root snapshots.
            When aggregate root history is enabled, on each persist, 
            snapshot will be saved too.
            </summary>
            <typeparam name="TRoot"></typeparam>
        </member>
        <member name="P:Revenj.DomainPatterns.IHistory`1.Snapshots">
            <summary>
            Collection of snapshots for this aggregate root
            </summary>
        </member>
        <member name="T:Revenj.DomainPatterns.ISnapshot`1">
            <summary>
            Point in time version of an aggregate root.
            </summary>
            <typeparam name="TRoot">aggregate root type</typeparam>
        </member>
        <member name="P:Revenj.DomainPatterns.ISnapshot`1.At">
            <summary>
            When was this snapshot created
            </summary>
        </member>
        <member name="P:Revenj.DomainPatterns.ISnapshot`1.Action">
            <summary>
            Type of action by which this snapshot was created
            </summary>
        </member>
        <member name="T:Revenj.DomainPatterns.ServiceProviderHelper">
            <summary>
            Utility for service locator resolution
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.ServiceProviderHelper.Resolve``1(System.IServiceProvider)">
            <summary>
            Resolve service using provided type.
            </summary>
            <typeparam name="T">service type</typeparam>
            <param name="provider">service locator</param>
            <returns>resolved service</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.ServiceProviderHelper.Resolve``1(System.IServiceProvider,System.Type)">
            <summary>
            Resolve service using provided type and cast it to appropriate result.
            </summary>
            <typeparam name="T">result type</typeparam>
            <param name="provider">service locator</param>
            <param name="type">service type</param>
            <returns>casted resolved service</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.ISystemStartup">
            <summary>
            Service which will be called during system startup.
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.ISystemStartup.Configure(System.IServiceProvider)">
            <summary>
            Configure system behavior.
            </summary>
            <param name="locator">dynamic locator</param>
        </member>
        <member name="T:Revenj.DomainPatterns.IChangeTracking`1">
            <summary>
            Change tracking on an object.
            When object implements change tracking it will maintain original 
            version of an object at the time of reconstruction.
            </summary>
            <typeparam name="T">object type</typeparam>
        </member>
        <member name="P:Revenj.DomainPatterns.IChangeTracking`1.TrackChanges">
            <summary>
            Change tracking state for this instance
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.IChangeTracking`1.GetOriginalValue">
            <summary>
            Get original value of a tracked object.
            Original value is initial value after reconstruction.
            </summary>
            <returns>original value</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.ChangeTrackingHelper">
            <summary>
            Utility for change tracking
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.ChangeTrackingHelper.IsChanged``1(Revenj.DomainPatterns.IChangeTracking{``0})">
            <summary>
            Is state of the object changed.
            </summary>
            <typeparam name="T">object type</typeparam>
            <param name="tracking">object which implements change tracking</param>
            <returns>is object changed</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.IValidation`1">
            <summary>
            Validation service. Validation checks which items don't pass
            validation and provides an explanation why.
            </summary>
            <typeparam name="TEntity">domain object type</typeparam>
        </member>
        <member name="M:Revenj.DomainPatterns.IValidation`1.FindInvalidItems(System.Linq.IQueryable{`0})">
            <summary>
            Apply filter on provided items and filter items which fail 
            defined specifications.
            </summary>
            <param name="items">items to check</param>
            <returns>invalid items</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IValidation`1.CanPersist(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if provided objects can be persisted.
            Sometimes invalid objects are allowed to be persisted, but they are still considered invalid.
            </summary>
            <param name="items">items to check</param>
            <returns>all items can be persisted</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IValidation`1.GetErrorDescription(`0)">
            <summary>
            Reason why does provided object fail validation.
            </summary>
            <param name="item">invalid object</param>
            <returns>why is object invalid</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.IValidationResult">
            <summary>
            Validation result signature.
            </summary>
        </member>
        <member name="P:Revenj.DomainPatterns.IValidationResult.ErrorDescription">
            <summary>
            Explanation why does current identity object fails validation.
            </summary>
        </member>
        <member name="T:Revenj.DomainPatterns.ValidationHelper">
            <summary>
            Utility for validation service
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.ValidationHelper.GenerateDescription``1(Revenj.DomainPatterns.IValidation{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Aggregate errors for invalid items in a single message.
            </summary>
            <typeparam name="TEntity">domain object type</typeparam>
            <param name="validation">validation service</param>
            <param name="items">invalid items</param>
            <returns>aggregated result message</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.IDataSource">
            <summary>
            Queryable domain object signature
            </summary>
        </member>
        <member name="T:Revenj.DomainPatterns.IEntity">
            <summary>
            Entity domain object signature.
            </summary>
        </member>
        <member name="T:Revenj.DomainPatterns.IIdentifiable">
            <summary>
            Domain objects with URI property.
            URI is string representation of it's unique identity.
            </summary>
        </member>
        <member name="P:Revenj.DomainPatterns.IIdentifiable.URI">
            <summary>
            String representation of object identity
            </summary>
        </member>
        <member name="T:Revenj.DomainPatterns.IAggregateRoot">
            <summary>
            Aggregate root object signature.
            Boundary for various entities and values which are persisted as a whole.
            </summary>
        </member>
        <member name="T:Revenj.DomainPatterns.ISnowflake`1">
            <summary>
            Projection on an entity.
            Snowflake schema which specialized use for some use case.
            </summary>
            <typeparam name="TEntity"></typeparam>
        </member>
        <member name="M:Revenj.DomainPatterns.ISnowflake`1.Update(`0)">
            <summary>
            Update snowflake when entity is changed.
            </summary>
            <param name="entity">starting entity</param>
        </member>
        <member name="T:Revenj.DomainPatterns.INestedValue`1">
            <summary>
            Common type for nested values.
            </summary>
            <typeparam name="TValue">value type</typeparam>
        </member>
        <member name="P:Revenj.DomainPatterns.INestedValue`1.Value">
            <summary>
            Get actual value
            </summary>
        </member>
        <member name="T:Revenj.DomainPatterns.IRepository`1">
            <summary>
            Data access abstraction. 
            Lookup data by its identifier.
            </summary>
            <typeparam name="TValue">data type</typeparam>
        </member>
        <member name="M:Revenj.DomainPatterns.IRepository`1.Find(System.String)">
            <summary>
            Find objects by identity
            </summary>
            <param name="uri">object identity</param>
            <returns>found object, null if not found</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IRepository`1.Find(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Find objects by provided identifiers
            </summary>
            <param name="uris">object identifiers</param>
            <returns>found objects</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.IQueryableRepository`1">
            <summary>
            Data access abstraction.
            Query data using LINQ.
            </summary>
            <typeparam name="TValue">data type</typeparam>
        </member>
        <member name="M:Revenj.DomainPatterns.IQueryableRepository`1.Query``1(Revenj.DomainPatterns.ISpecification{``0})">
            <summary>
            Query data using provided expression (optional).
            If specification is provided it must be compatible with data type.
            This is only a projection, actual query will be done after materialization from IQueryable&lt;TValue&gt;
            </summary>
            <typeparam name="TCondition">specification type</typeparam>
            <param name="specification">filter predicate</param>
            <returns>data projection</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IQueryableRepository`1.Search``1(Revenj.DomainPatterns.ISpecification{``0},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Search data using provided specification.
            If specification is provided it must be compatible with data type.
            </summary>
            <typeparam name="TCondition">specification type</typeparam>
            <param name="specification">filter predicate</param>
            <param name="limit">limit maximum number of results</param>
            <param name="offset">skip initial results</param>
            <returns>found items</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IQueryableRepository`1.Count``1(Revenj.DomainPatterns.ISpecification{``0})">
            <summary>
            Count data using provided specification.
            If specification is provided it must be compatible with data type.
            </summary>
            <typeparam name="TCondition">specification type</typeparam>
            <param name="specification">filter predicate</param>
            <returns>total found items</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IQueryableRepository`1.Exists``1(Revenj.DomainPatterns.ISpecification{``0})">
            <summary>
            Check for data using provided specification.
            If specification is provided it must be compatible with data type.
            </summary>
            <typeparam name="TCondition">specification type</typeparam>
            <param name="specification">filter predicate</param>
            <returns>data has been found</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.IPersistableRepository`1">
            <summary>
            Aggregate root persistable repository.
            Besides querying capabilities, repository has set based API for persistence.
            </summary>
            <typeparam name="TRoot">aggregate root type</typeparam>
        </member>
        <member name="M:Revenj.DomainPatterns.IPersistableRepository`1.Persist(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`0}},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Persist aggregate roots. Bulk persistence.
            Inserted aggregates will return new identifiers.
            Aggregate roots will be modified in place.
            For update aggregates, if old aggregate is not provided, it will be looked up using aggregate identifier.
            </summary>
            <param name="insert">new aggregates</param>
            <param name="update">collection of old and changed aggregates</param>
            <param name="delete">remove aggregates</param>
            <returns>created identifiers</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.IRepositoryBulkReader">
            <summary>
            Provides bulk access to DB operations (if supported by implementation)
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.IRepositoryBulkReader.Reset(System.Boolean)">
            <summary>
            Reset reader for new queries.
            </summary>
            <param name="usePrepared">use prepared statements</param>
        </member>
        <member name="M:Revenj.DomainPatterns.IRepositoryBulkReader.Find``1(System.String)">
            <summary>
            Find object by identity
            </summary>
            <typeparam name="T">object type</typeparam>
            <param name="uri">string primary key representation</param>
            <returns>object which was found</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IRepositoryBulkReader.Find``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Find objects by identity
            </summary>
            <typeparam name="T">object type</typeparam>
            <param name="uris">primary keys as strings</param>
            <returns>found objects</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IRepositoryBulkReader.Search``1(Revenj.DomainPatterns.ISpecification{``0},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Search for objects using provided specification
            </summary>
            <typeparam name="T">object type</typeparam>
            <param name="filter">search filter</param>
            <param name="limit">max results</param>
            <param name="offset">skip initial results</param>
            <returns>found objects</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IRepositoryBulkReader.Count``1(Revenj.DomainPatterns.ISpecification{``0})">
            <summary>
            Count domain object using provided specification
            </summary>
            <typeparam name="T">object type</typeparam>
            <param name="filter">search filter</param>
            <returns>total found objects</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IRepositoryBulkReader.Exists``1(Revenj.DomainPatterns.ISpecification{``0})">
            <summary>
            Check if objects exists using provided specification
            </summary>
            <typeparam name="T">object type</typeparam>
            <param name="filter">search filter</param>
            <returns>objects exists</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IRepositoryBulkReader.Analyze``2(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Boolean}},Revenj.DomainPatterns.ISpecification{``1},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Run OLAP analysis on objects using provided specification
            </summary>
            <typeparam name="TCube">cube type</typeparam>
            <typeparam name="TSource">cube data source type</typeparam>
            <param name="dimensionsAndFacts">group by dimensions, analyze by facts</param>
            <param name="order">provide result in specific order</param>
            <param name="filter">search filter</param>
            <param name="limit">max results</param>
            <param name="offset">skip initial results</param>
            <returns>found objects</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.IRepositoryBulkReader.Execute">
            <summary>
            Execute queries
            </summary>
        </member>
        <member name="T:Revenj.DomainPatterns.RepositoryHelper">
            <summary>
            Utility for easier usage of repositories.
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.RepositoryHelper.Persist``1(Revenj.DomainPatterns.IPersistableRepository{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Persist aggregate roots. Bulk persistence.
            Inserted aggregates will return new identifiers.
            Aggregate roots will be modified in place.
            For update aggregates, old aggregates will be loaded from change tracking or looked up using aggregate identifier.
            </summary>
            <typeparam name="TRoot">aggregate root type</typeparam>
            <param name="repository">persistable repository</param>
            <param name="insert">new aggregates</param>
            <param name="update">collection of changed aggregates</param>
            <param name="delete">remove aggregates</param>
            <returns>created identifiers</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.RepositoryHelper.Query``1(Revenj.DomainPatterns.IQueryableRepository{``0})">
            <summary>
            Query all data of specific type.
            This is only a projection, actual query will be done after materialization from IQueryable&lt;TValue&gt;
            </summary>
            <typeparam name="TValue">data type</typeparam>
            <param name="repository">queryable repository</param>
            <returns>projection to data</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.RepositoryHelper.Search``1(Revenj.DomainPatterns.IQueryableRepository{``0})">
            <summary>
            Search all data of specified type.
            </summary>
            <typeparam name="TValue">data type</typeparam>
            <param name="repository">queryable repository</param>
            <returns>found items</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.RepositoryHelper.Count``1(Revenj.DomainPatterns.IQueryableRepository{``0})">
            <summary>
            Count all data of specified type.
            </summary>
            <typeparam name="TValue">data type</typeparam>
            <param name="repository">queryable repository</param>
            <returns>total found items</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.RepositoryHelper.Exists``1(Revenj.DomainPatterns.IQueryableRepository{``0})">
            <summary>
            Check for any data of specified type.
            </summary>
            <typeparam name="TValue">data type</typeparam>
            <param name="repository">queryable repository</param>
            <returns>items has been found</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.RepositoryHelper.Insert``1(Revenj.DomainPatterns.IPersistableRepository{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Insert new aggregate roots.
            Aggregates are modified in place.
            </summary>
            <typeparam name="TRoot">aggregate type</typeparam>
            <param name="repository">persistable repository</param>
            <param name="data">new aggregates</param>
            <returns>created identifiers</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.RepositoryHelper.Update``1(Revenj.DomainPatterns.IPersistableRepository{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Save changed aggregate roots.
            Aggregates are modified in place.
            </summary>
            <typeparam name="TRoot">aggregate type</typeparam>
            <param name="repository">persistable repository</param>
            <param name="data">aggregates to save</param>
        </member>
        <member name="M:Revenj.DomainPatterns.RepositoryHelper.Update``1(Revenj.DomainPatterns.IPersistableRepository{``0},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``0}})">
            <summary>
            Save changed aggregate roots.
            Aggregates are modified in place.
            </summary>
            <typeparam name="TRoot">aggregate type</typeparam>
            <param name="repository">persistable repository</param>
            <param name="data">collection of old and changed aggregates</param>
        </member>
        <member name="M:Revenj.DomainPatterns.RepositoryHelper.Delete``1(Revenj.DomainPatterns.IPersistableRepository{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Delete aggregate roots.
            </summary>
            <typeparam name="TRoot">aggregate type</typeparam>
            <param name="repository">persistable repository</param>
            <param name="data">aggregates to delete</param>
        </member>
        <member name="M:Revenj.DomainPatterns.RepositoryHelper.Insert``1(Revenj.DomainPatterns.IPersistableRepository{``0},``0)">
            <summary>
            Insert aggregate root.
            Return new identifier.
            Aggregate is modified in place.
            </summary>
            <typeparam name="TRoot">aggregate type</typeparam>
            <param name="repository">persistable repository</param>
            <param name="data">new aggregate</param>
            <returns>assigned identifier</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.RepositoryHelper.Update``1(Revenj.DomainPatterns.IPersistableRepository{``0},``0)">
            <summary>
            Update changed aggregate root.
            Aggregate is modified in place.
            </summary>
            <typeparam name="TRoot">aggregate type</typeparam>
            <param name="repository">persistable repository</param>
            <param name="data">changed aggregate</param>
        </member>
        <member name="M:Revenj.DomainPatterns.RepositoryHelper.Update``1(Revenj.DomainPatterns.IPersistableRepository{``0},``0,``0)">
            <summary>
            Update changed aggregate root.
            Aggregate is modified in place.
            </summary>
            <typeparam name="TRoot">aggregate type</typeparam>
            <param name="repository">persistable repository</param>
            <param name="oldValue">old aggregate instance</param>
            <param name="newValue">new aggregate instance</param>
        </member>
        <member name="M:Revenj.DomainPatterns.RepositoryHelper.Delete``1(Revenj.DomainPatterns.IPersistableRepository{``0},``0)">
            <summary>
            Delete aggregate root.
            </summary>
            <typeparam name="TRoot">aggregate type</typeparam>
            <param name="repository">persistable repository</param>
            <param name="data">aggregate to delete</param>
        </member>
        <member name="M:Revenj.DomainPatterns.RepositoryHelper.Delete``1(Revenj.DomainPatterns.IPersistableRepository{``0},System.String)">
            <summary>
            Delete aggregate root defined by provided identifier.
            Deleted aggregate is returned.
            </summary>
            <typeparam name="TRoot">aggregate type</typeparam>
            <param name="repository">persistable repository</param>
            <param name="uri">aggregate identifier</param>
            <returns>deleted aggregate root</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.RepositoryHelper.Update``1(Revenj.DomainPatterns.IPersistableRepository{``0},System.String,System.Action{``0})">
            <summary>
            Change aggregate root defined by identifier using provided action.
            </summary>
            <typeparam name="TRoot">aggregate type</typeparam>
            <param name="repository">persistable repository</param>
            <param name="uri">aggregate identifier</param>
            <param name="update">change method</param>
            <returns>found and changed aggregate</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.RepositoryHelper.Analyze``2(Revenj.DomainPatterns.IRepositoryBulkReader,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Run OLAP analysis on objects using provided specification
            </summary>
            <typeparam name="TCube">cube type</typeparam>
            <typeparam name="TSource">cube data source type</typeparam>
            <param name="bulk">bulk reader</param>
            <param name="dimensionsAndFacts">group by dimensions, analyze by facts</param>
            <returns>found objects</returns>
        </member>
        <member name="T:Revenj.DomainPatterns.ISpecification`1">
            <summary>
            Specification is predicate which states a condition.
            It can be used to filter data which satisfy defined condition.
            </summary>
            <typeparam name="TValue">specification type</typeparam>
        </member>
        <member name="P:Revenj.DomainPatterns.ISpecification`1.IsSatisfied">
            <summary>
            Expression for testing specified condition.
            </summary>
        </member>
        <member name="T:Revenj.DomainPatterns.SpecificationHelper">
            <summary>
            Utility for applying specification on data.
            </summary>
        </member>
        <member name="M:Revenj.DomainPatterns.SpecificationHelper.Filter``2(System.Linq.IQueryable{``0},Revenj.DomainPatterns.ISpecification{``1})">
            <summary>
            Apply specification on data projection.
            Specification must be compatible with data.
            </summary>
            <typeparam name="TSource">data type</typeparam>
            <typeparam name="TFilter">specification type</typeparam>
            <param name="source">data projection</param>
            <param name="filter">specification filter predicate</param>
            <returns>filtered data projection</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.SpecificationHelper.IsSatisfiedBy``1(Revenj.DomainPatterns.ISpecification{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Check if any item satisfies specification.
            </summary>
            <typeparam name="TSource">data and specification type</typeparam>
            <param name="specification">filter predicate</param>
            <param name="items">data collection</param>
            <returns>does any item satisfies specification</returns>
        </member>
        <member name="M:Revenj.DomainPatterns.SpecificationHelper.IsSatisfiedBy``1(Revenj.DomainPatterns.ISpecification{``0},``0)">
            <summary>
            Is specification satisfied by provided object.
            </summary>
            <typeparam name="TSource">object and specification type</typeparam>
            <param name="specification">condition</param>
            <param name="item">object to check</param>
            <returns>specification satisfied</returns>
        </member>
        <member name="T:Revenj.Extensibility.IDslAspect">
            <summary>
            DSL aspects will be resolved during system startup.
            Aspects will be registered for interception.
            In production mode this aspects will not be loaded.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.IDslAspect.Register(Revenj.Extensibility.IAspectRegistrator)">
            <summary>
            Register aspect into the system during system startup.
            </summary>
            <param name="aspects">aspect management service</param>
        </member>
        <member name="T:Revenj.Extensibility.ISystemAspect">
            <summary>
            System aspects will be resolved during system startup.
            Services can configure system behavior.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.ISystemAspect.Initialize(Revenj.Extensibility.IObjectFactory)">
            <summary>
            Initialize aspect and provide system scope
            </summary>
            <param name="factory">system scope</param>
        </member>
        <member name="T:Revenj.Extensibility.PluginAttribute">
            <summary>
            Attribute for registering plugins into the container.
            When plugins are not registered using standard methods,
            this alternative method can be used for registering all plugins implementing this interface.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.PluginAttribute.Scope">
            <summary>
            Registered plugins scope
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.PluginAttribute.#ctor">
            <summary>
            Plugins will have transient scope by default
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.PluginAttribute.#ctor(Revenj.Extensibility.InstanceScope)">
            <summary>
            Register plugins using specified scope
            </summary>
            <param name="scope">instance scope</param>
        </member>
        <member name="T:Revenj.Extensibility.ServiceAttribute">
            <summary>
            Attribute for registering class into the container.
            When some service is not registered using standard methods,
            this alternative method can be used for registering service where it was declared.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.ServiceAttribute.Scope">
            <summary>
            Registered service scope
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.ServiceAttribute.#ctor">
            <summary>
            Service will have transient scope by default
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.ServiceAttribute.#ctor(Revenj.Extensibility.InstanceScope)">
            <summary>
            Register service using specified scope
            </summary>
            <param name="scope">instance scope</param>
        </member>
        <member name="T:Revenj.Extensibility.IAspectRegistrator">
            <summary>
            AOP management service.
            Register aspects on join points.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.IAspectRegistrator.Before(System.Type,System.Action)">
            <summary>
            Register aspect which will be invoked before type construction.
            </summary>
            <param name="type">target class/interface</param>
            <param name="before">advice which will be invoked</param>
        </member>
        <member name="M:Revenj.Extensibility.IAspectRegistrator.After(System.Type,System.Action{System.Object})">
            <summary>
            Register aspect which will be invoked after type construction.
            Constructed instance will be provided to the advice.
            </summary>
            <param name="type">target class/interface</param>
            <param name="after">advice which will be invoked</param>
        </member>
        <member name="M:Revenj.Extensibility.IAspectRegistrator.Before(System.Type,System.Reflection.MethodInfo,System.Action{System.Object,System.Object[]})">
            <summary>
            Register aspect which will be invoked before a method call on specified type.
            Instance and arguments will be provided to the advice.
            </summary>
            <param name="type">target class/interface</param>
            <param name="method">target method</param>
            <param name="before">advice which will be invoked</param>
        </member>
        <member name="M:Revenj.Extensibility.IAspectRegistrator.Around(System.Type,System.Reflection.MethodInfo,System.Func{System.Object,System.Object[],System.Func{System.Object[],System.Object},System.Object})">
            <summary>
            Register aspect which will be invoked around a method call on specified type.
            Base method call will be provided so advice can choose to invoke it or ignore it.
            Instance and arguments will be provided.
            Advice is expected to return the result (null for void methods).
            </summary>
            <param name="type">target class/interface</param>
            <param name="method">target method</param>
            <param name="around">advice which will be invoked</param>
        </member>
        <member name="M:Revenj.Extensibility.IAspectRegistrator.After(System.Type,System.Reflection.MethodInfo,System.Func{System.Object,System.Object[],System.Object,System.Object})">
            <summary>
            Register aspect which will be invoked after method call on specified type.
            Instance, arguments and result will be provided to the advice.
            Advice can modify provided result.
            </summary>
            <param name="type">target class/interface</param>
            <param name="method">target method</param>
            <param name="after">advice which will be invoked</param>
        </member>
        <member name="T:Revenj.Extensibility.AspectRepositoryHelper">
            <summary>
            Type-safe helper for aspect registration.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Before``1(Revenj.Extensibility.IAspectRegistrator,System.Action)">
            <summary>
            Register aspect which will be invoked before type construction.
            </summary>
            <typeparam name="T">target type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="action">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.After``1(Revenj.Extensibility.IAspectRegistrator,System.Action{``0})">
            <summary>
            Register aspect which will be invoked after type construction.
            Created instance will be provided to the advice.
            </summary>
            <typeparam name="T">target type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="action">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Before(Revenj.Extensibility.IAspectRegistrator,System.Type,System.Linq.Expressions.LambdaExpression,System.Action{System.Object,System.Object[]})">
            <summary>
            Register aspect which will be invoked before a method call on specified type.
            Method call is specified with lambda expression.
            Advice is invoked with target instance and method arguments.
            </summary>
            <param name="repository">aspect management service</param>
            <param name="type">target class/interface</param>
            <param name="lambda">join point</param>
            <param name="action">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Around(Revenj.Extensibility.IAspectRegistrator,System.Type,System.Linq.Expressions.LambdaExpression,System.Func{System.Object,System.Object[],System.Func{System.Object[],System.Object},System.Object})">
            <summary>
            Register aspect which will be invoked around a method call on specified type.
            Method call is defined with lambda expression.
            Base method call will be provided so advice can choose to invoke it or ignore it.
            Instance and arguments will be provided.
            Advice is expected to return the result (null for void methods).
            </summary>
            <param name="repository">aspect management service</param>
            <param name="type">target class/interface</param>
            <param name="lambda">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.After(Revenj.Extensibility.IAspectRegistrator,System.Type,System.Linq.Expressions.LambdaExpression,System.Func{System.Object,System.Object[],System.Object,System.Object})">
            <summary>
            Register aspect which will be invoked after method call on specified type.
            Method call is defined with lambda expression.
            Advice will be provided with target instance, arguments and result.
            Advice can return alternative result.
            </summary>
            <param name="repository">aspect management service</param>
            <param name="type">target class/interface</param>
            <param name="lambda">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Before``1(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Action{``0})">
            <summary>
            Register aspect which will be invoked before a method call without argument on specified type.
            Method call is specified with expression.
            Advice is invoked with target instance.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="action">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Before``2(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Action{``0,``1})">
            <summary>
            Register aspect which will be invoked before a method call with single argument on specified type.
            Method call is specified with expression.
            Advice is invoked with target instance and provided argument.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg">method argument</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="action">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Before``3(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Action{``0,``1,``2})">
            <summary>
            Register aspect which will be invoked before a method call with two arguments on specified type.
            Method call is specified with expression.
            Advice is invoked with target instance and provided arguments.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg1">first method argument</typeparam>
            <typeparam name="TArg2">second method argument</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="action">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Before``2(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Action{``0})">
            <summary>
            Register aspect which will be invoked before a function without arguments on specified type.
            Function is specified with expression.
            Advice is invoked with target instance.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="action">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Before``3(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Func{``0,``1,``2})">
            <summary>
            Register aspect which will be invoked before a function with single argument on specified type.
            Function is specified with expression.
            Advice is invoked with target instance and provided argument.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg">function argument type</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Before``4(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Func{``0,``1,``2,``3})">
            <summary>
            Register aspect which will be invoked before a function with two arguments on specified type.
            Function is specified with expression.
            Advice is invoked with target instance and provided arguments.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg1">function first argument type</typeparam>
            <typeparam name="TArg2">function second argument type</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Around``1(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Action{System.Action})">
            <summary>
            Register aspect which will be invoked around a method call on specified type.
            Method call is defined with expression.
            Base method call will be provided so advice can choose to invoke it or ignore it.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="action">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Around``1(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Action{``0})">
            <summary>
            Register aspect which will be invoked around a method call on specified type.
            Method call is defined with expression.
            Target instance will be provided to the advice.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="action">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Around``2(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Action{``1,System.Action{``1}})">
            <summary>
            Register aspect which will be invoked on a method call with single argument on specified type.
            Method call is defined with expression.
            Target instance and argument will be provided to the aspect.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg">target argument type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="action">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Around``2(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Action{``0,``1,System.Action{``1}})">
            <summary>
            Register aspect which will be invoked on a method call with single argument on specified type.
            Method call is defined with expression.
            Base method call will be provided so advice can choose to invoke it or ignore it.
            Target instance, argument and base method call will be provided to the aspect.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg">method call argument type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="action">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Around``3(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Action{``1,``2,System.Action{``1,``2}})">
            <summary>
            Register aspect which will be invoked on a method call with two arguments on specified type.
            Method call is defined with expression.
            Base method call will be provided so advice can choose to invoke it or ignore it.
            Arguments and base method call will be provided to the aspect.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg1">first method call argument type</typeparam>
            <typeparam name="TArg2">second method call argument type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="action">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Around``3(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Action{``0,``1,``2,System.Action{``1,``2}})">
            <summary>
            Register aspect which will be invoked on a method call with two arguments on specified type.
            Method call is defined with expression.
            Base method call will be provided so advice can choose to invoke it or ignore it.
            Target instance, arguments and base method call will be provided to the aspect.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg1">first method call argument type</typeparam>
            <typeparam name="TArg2">second method call argument type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="action">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Around``2(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{System.Func{``1},``1})">
            <summary>
            Register aspect which will be invoked on a function without arguments on specified type.
            Function is defined with expression.
            Base function be provided so advice can choose to invoke it or ignore it.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Around``2(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{``0,System.Func{``1},``1})">
            <summary>
            Register aspect which will be invoked on a function without arguments on specified type.
            Function is defined with expression.
            Base function be provided so advice can choose to invoke it or ignore it.
            Target instance and base function will be provided to the advice.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Around``3(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Func{``1,System.Func{``1,``2},``2})">
            <summary>
            Register aspect which will be invoked on a function with single argument on specified type.
            Function is defined with expression.
            Base function be provided so advice can choose to invoke it or ignore it.
            Argument and base function will be provided to the aspect.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg">function argument type</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Around``3(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Func{``0,``1,System.Func{``1,``2},``2})">
            <summary>
            Register aspect which will be invoked on a function with single argument on specified type.
            Function is defined with expression.
            Base function be provided so advice can choose to invoke it or ignore it.
            Target instance, argument and base function will be provided to the aspect.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg">function argument type</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Around``4(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Func{``1,``2,System.Func{``1,``2,``3},``3})">
            <summary>
            Register aspect which will be invoked on a function with two arguments on specified type.
            Function is defined with expression.
            Base function be provided so advice can choose to invoke it or ignore it.
            Arguments and base function will be provided to the aspect.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg1">function first argument type</typeparam>
            <typeparam name="TArg2">function second argument type</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Around``4(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Func{``0,``1,``2,System.Func{``1,``2,``3},``3})">
            <summary>
            Register aspect which will be invoked on a function with two arguments on specified type.
            Function is defined with expression.
            Base function be provided so advice can choose to invoke it or ignore it.
            Target instance, arguments and base function will be provided to the aspect.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg1">function first argument type</typeparam>
            <typeparam name="TArg2">function second argument type</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Around``5(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Func{``1,``2,``3,System.Func{``1,``2,``3,``4},``4})">
            <summary>
            Register aspect which will be invoked on a function with three arguments on specified type.
            Function is defined with expression.
            Base function be provided so advice can choose to invoke it or ignore it.
            Arguments and base function will be provided to the aspect.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg1">function first argument type</typeparam>
            <typeparam name="TArg2">function second argument type</typeparam>
            <typeparam name="TArg3">function third argument type</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Around``5(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Func{``0,``1,``2,``3,System.Func{``1,``2,``3,``4},``4})">
            <summary>
            Register aspect which will be invoked on a function with three arguments on specified type.
            Function is defined with expression.
            Base function be provided so advice can choose to invoke it or ignore it.
            Target instance, arguments and base function will be provided to the aspect.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg1">function first argument type</typeparam>
            <typeparam name="TArg2">function second argument type</typeparam>
            <typeparam name="TArg3">function third argument type</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Around``6(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Func{``1,``2,``3,``4,System.Func{``1,``2,``3,``4,``5},``5})">
            <summary>
            Register aspect which will be invoked on a function with four arguments on specified type.
            Function is defined with expression.
            Base function be provided so advice can choose to invoke it or ignore it.
            Arguments and base function will be provided to the aspect.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg1">function first argument type</typeparam>
            <typeparam name="TArg2">function second argument type</typeparam>
            <typeparam name="TArg3">function third argument type</typeparam>
            <typeparam name="TArg4">function fourth argument type</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.Around``6(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Func{``0,``1,``2,``3,``4,System.Func{``1,``2,``3,``4,``5},``5})">
            <summary>
            Register aspect which will be invoked on a function with four arguments on specified type.
            Function is defined with expression.
            Base function be provided so advice can choose to invoke it or ignore it.
            Target instance, arguments and base function will be provided to the aspect.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg1">function first argument type</typeparam>
            <typeparam name="TArg2">function second argument type</typeparam>
            <typeparam name="TArg3">function third argument type</typeparam>
            <typeparam name="TArg4">function fourth argument type</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.After``1(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Action)">
            <summary>
            Register aspect which will be invoked after method call on specified type.
            Method call is defined with expression.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="action">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.After``1(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Action{``0})">
            <summary>
            Register aspect which will be invoked after method call on specified type.
            Method call is defined with expression.
            Advice will be provided with target instance.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="action">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.After``2(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Action{``1})">
            <summary>
            Register aspect which will be invoked after method call with one argument on specified type.
            Method call is defined with expression.
            Advice will be provided with argument.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg">method argument type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="action">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.After``2(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Action{``0,``1})">
            <summary>
            Register aspect which will be invoked after method call with one argument on specified type.
            Method call is defined with expression.
            Advice will be provided with target instance and argument.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg">method argument type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="action">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.After``3(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Action{``1,``2})">
            <summary>
            Register aspect which will be invoked after method call with two arguments on specified type.
            Method call is defined with expression.
            Arguments will be provided to the advice.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg1">method argument type</typeparam>
            <typeparam name="TArg2">method argument type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="action">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.After``3(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Action{``0,``1,``2})">
            <summary>
            Register aspect which will be invoked after method call with two arguments on specified type.
            Method call is defined with expression.
            Target instance and arguments will be provided to the advice.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg1">method argument type</typeparam>
            <typeparam name="TArg2">method argument type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="action">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.After``2(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{``1})">
            <summary>
            Register aspect which will be invoked after function without arguments on specified type.
            Function is defined with expression.
            Advice should return alternative result.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.After``2(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{``0,``1})">
            <summary>
            Register aspect which will be invoked after function without arguments on specified type.
            Function is defined with expression.
            Target instance will be provided to the advice.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.After``2(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Func{``1,``1})">
            <summary>
            Register aspect which will be invoked after function without arguments on specified type.
            Function is defined with expression.
            Result will be provided to the advice.
            Advice can return alternative result.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.After``2(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Func{``0,``1,``1})">
            <summary>
            Register aspect which will be invoked after function without arguments on specified type.
            Function is defined with expression.
            Target instance and result will be provided to the advice.
            Advice can return alternative result.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.After``3(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Func{``1,``2,``2})">
            <summary>
            Register aspect which will be invoked after function with one argument on specified type.
            Function is defined with expression.
            Argument and result will be provided to the advice.
            Advice can return alternative result.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg">function argument type</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="action">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.After``3(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Func{``0,``1,``2,``2})">
            <summary>
            Register aspect which will be invoked after function with one argument on specified type.
            Function is defined with expression.
            Target instance, argument and result will be provided to the advice.
            Advice can return alternative result.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg">function argument type</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.After``4(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Func{``1,``2,``3,``3})">
            <summary>
            Register aspect which will be invoked after function with two arguments on specified type.
            Function is defined with expression.
            Arguments and result will be provided to the advice.
            Advice can return alternative result.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg1">function first argument type</typeparam>
            <typeparam name="TArg2">function second argument type</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="M:Revenj.Extensibility.AspectRepositoryHelper.After``4(Revenj.Extensibility.IAspectRegistrator,System.Linq.Expressions.Expression{System.Action{``0}},System.Func{``0,``1,``2,``3,``3})">
            <summary>
            Register aspect which will be invoked after function with two arguments on specified type.
            Function is defined with expression.
            Target instance, arguments and result will be provided to the advice.
            Advice can return alternative result.
            </summary>
            <typeparam name="TWhere">target class/interface</typeparam>
            <typeparam name="TArg1">function first argument type</typeparam>
            <typeparam name="TArg2">function second argument type</typeparam>
            <typeparam name="TResult">function result type</typeparam>
            <param name="repository">aspect management service</param>
            <param name="expression">join point</param>
            <param name="func">advice which will be applied</param>
        </member>
        <member name="T:Revenj.Extensibility.IExtensibilityProvider">
            <summary>
            MEF plugins are resolved from extensibility provider.
            Plugins are decorated with Export attribute.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.IExtensibilityProvider.FindPlugins``1(System.Func{System.Type,System.Type,System.Boolean})">
            <summary>
            Find plugin types which implement specified interface and satisfy filter predicate.
            Filter predicate tests for plugin type and target type (Implements).
            Plugin types are topologically sorted based on their dependencies.
            </summary>
            <typeparam name="TInterface">plugin must implement provided interface</typeparam>
            <param name="filter">filter plugins</param>
            <returns>found plugins</returns>
        </member>
        <member name="M:Revenj.Extensibility.IExtensibilityProvider.FindImplementations``1(System.Func{System.Type,System.Type,System.Boolean})">
            <summary>
            Find implementations for concepts for specified interface which satisfy filter predicate.
            Result is collection of found concepts and their implementations.
            Implementations are topologically sorted based on their dependencies.
            </summary>
            <typeparam name="TImplementation">plugin must implement provided interface</typeparam>
            <param name="filter">filter implementations</param>
            <returns>map of concepts and their implementations</returns>
        </member>
        <member name="M:Revenj.Extensibility.IExtensibilityProvider.FindExtensions``1">
            <summary>
            Find extensions for specified interface.
            Extensions are MEF plugins which Export target attribute.
            </summary>
            <typeparam name="TImplementation">extension must export provided interface</typeparam>
            <returns>found extensions</returns>
        </member>
        <member name="T:Revenj.Extensibility.ExtensibilityProviderHelper">
            <summary>
            Helper for plugin lookup
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.ExtensibilityProviderHelper.FindPlugins``1(Revenj.Extensibility.IExtensibilityProvider)">
            <summary>
            Find all plugin types which implement specified interface/service contract.
            Plugin types are topologically sorted based on their dependencies.
            </summary>
            <typeparam name="TService">plugin must have specified service signature</typeparam>
            <param name="provider">extensibility service</param>
            <returns>found plugins</returns>
        </member>
        <member name="M:Revenj.Extensibility.ExtensibilityProviderHelper.ResolvePlugins``1(Revenj.Extensibility.IExtensibilityProvider)">
            <summary>
            Resolve all plugins which implement specified interface.
            Plugins are cached and same instances are provided on subsequent calls.
            </summary>
            <typeparam name="TInterface">plugin must implement provided interface</typeparam>
            <param name="provider">extensibility service</param>
            <returns>resolved plugins</returns>
        </member>
        <member name="M:Revenj.Extensibility.ExtensibilityProviderHelper.FindImplementations``1(Revenj.Extensibility.IExtensibilityProvider)">
            <summary>
            Find all implementations for concepts for specified interface.
            Result is collection of found concepts and their implementations.
            Implementations are topologically sorted based on their dependencies.
            </summary>
            <typeparam name="TImplementation">plugin must implement provided interface</typeparam>
            <param name="provider">extensibility service</param>
            <returns>map of concepts and their implementations</returns>
        </member>
        <member name="T:Revenj.Extensibility.Metadata">
            <summary>
            MEF metadata.
            For specifying dependencies and additional plugin info.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Metadata.ClassType">
            <summary>
            Since MEF doesn't know actual type, repeat the target class type using this attribute.
            This should be used when class has dependencies so they can be resolved from container.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Metadata.InsteadOf">
            <summary>
            When MEF plugin should be used instead of some other plugin.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Metadata.Implements">
            <summary>
            Specify concept type which plugin implements.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Metadata.After">
            <summary>
            Define plugin dependency. This plugin should be used after specified plugin.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Metadata.Before">
            <summary>
            Define plugin dependency. This plugin should be used before specified plugin.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.Metadata.Extends">
            <summary>
            For aspects on concepts. Define which concept this plugin extends.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.IMixinProvider">
            <summary>
            Service for creating mixins.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.IMixinProvider.Create(System.Type,System.Object[],System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Create mixin instance for target type using provided constructor arguments and combining provided instances.
            </summary>
            <param name="mixinType">target class type</param>
            <param name="args">constructor arguments</param>
            <param name="implementations">additional mixins</param>
            <returns>object instance with merged mixins</returns>
        </member>
        <member name="T:Revenj.Extensibility.MixinProviderExtension">
            <summary>
            Helper method for creating mixins
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.MixinProviderExtension.Create``1(Revenj.Extensibility.IMixinProvider,System.Collections.Generic.IEnumerable{System.Object},System.Object[])">
            <summary>
            Create mixin for target class using provided instances and constructor arguments.
            </summary>
            <typeparam name="TMixin">target class</typeparam>
            <param name="provider">mixin service</param>
            <param name="implementations">additional mixins</param>
            <param name="args">constructor arguments</param>
            <returns>object instance with merged mixins</returns>
        </member>
        <member name="M:Revenj.Extensibility.MixinProviderExtension.Create``1(Revenj.Extensibility.IMixinProvider,System.Type,System.Object[])">
            <summary>
            Create mixin for target class using constructor arguments.
            Usefull for abstract classes.
            </summary>
            <typeparam name="TMixin">target instance</typeparam>
            <param name="provider">mixin service</param>
            <param name="type">target class</param>
            <param name="args">constructor arguments</param>
            <returns>object instance</returns>
        </member>
        <member name="T:Revenj.Extensibility.IObjectFactory">
            <summary>
            Inversion of control container service.
            Object factory should be used for scoping so dependencies can be specified for that scope.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.IObjectFactory.IsRegistered(System.Type)">
            <summary>
            Check if service is registered with the factory
            </summary>
            <param name="type">service type</param>
            <returns>is service registered</returns>
        </member>
        <member name="M:Revenj.Extensibility.IObjectFactory.Resolve(System.Type,System.Object[])">
            <summary>
            Resolve service from the factory. Instance is resolved based on scoping rules.
            If service can't be resolved an exception will be thrown.
            </summary>
            <param name="type">service type</param>
            <param name="args">argument for service resolution</param>
            <returns>instance for requested service</returns>
        </member>
        <member name="M:Revenj.Extensibility.IObjectFactory.CreateScope(System.String)">
            <summary>
            Create nested scope. 
            Scope should be used as unit of work, after which services resolved from that scope should be disposed.
            If id is provided scope will be traced.
            </summary>
            <param name="id">specify scope identification</param>
            <returns>created nested scope</returns>
        </member>
        <member name="M:Revenj.Extensibility.IObjectFactory.FindScope(System.String)">
            <summary>
            Named scopes can be used for durable transactions.
            </summary>
            <param name="id">scope identification</param>
            <returns>found scope</returns>
        </member>
        <member name="M:Revenj.Extensibility.IObjectFactory.Register(Revenj.Extensibility.IObjectFactoryBuilder)">
            <summary>
            Register services to the container.
            </summary>
            <param name="builder">configuration for additional services</param>
        </member>
        <member name="T:Revenj.Extensibility.ObjectFactoryHelper">
            <summary>
            Container service helper
            </summary>
            <summary>
            Helper methods for container registration
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.ObjectFactoryHelper.CreateInnerFactory(Revenj.Extensibility.IObjectFactory)">
            <summary>
            Create unnamed scope. This scope will not be tracked.
            </summary>
            <param name="factory">container service</param>
            <returns>nested service</returns>
        </member>
        <member name="M:Revenj.Extensibility.ObjectFactoryHelper.Resolve``1(Revenj.Extensibility.IObjectFactory)">
            <summary>
            Resolve service from current scope.
            If service can't be resolved an exception will be thrown.
            </summary>
            <typeparam name="T">service type</typeparam>
            <param name="factory">current scope</param>
            <returns>found and resolved service</returns>
        </member>
        <member name="M:Revenj.Extensibility.ObjectFactoryHelper.Resolve``1(Revenj.Extensibility.IObjectFactory,System.Type)">
            <summary>
            Resolve service from current scope.
            If service can't be resolved an exception will be thrown.
            </summary>
            <typeparam name="T">resolved service type</typeparam>
            <param name="factory">current scope</param>
            <param name="type">registered/actual service type</param>
            <returns>found and resolved service</returns>
        </member>
        <member name="M:Revenj.Extensibility.ObjectFactoryHelper.RegisterType(Revenj.Extensibility.IObjectFactory,System.Type)">
            <summary>
            Register specified type to the container as self using transient scope.
            </summary>
            <param name="factory">container scope</param>
            <param name="type">service</param>
        </member>
        <member name="M:Revenj.Extensibility.ObjectFactoryHelper.RegisterType(Revenj.Extensibility.IObjectFactory,System.Type,Revenj.Extensibility.InstanceScope,System.Type[])">
            <summary>
            Register specified type to the container as custom service with provided scope.
            </summary>
            <param name="factory">container scope</param>
            <param name="type">service type</param>
            <param name="asType">register as</param>
            <param name="scope">resolution scope</param>
        </member>
        <member name="M:Revenj.Extensibility.ObjectFactoryHelper.RegisterType(Revenj.Extensibility.IObjectFactoryBuilder,System.Type,Revenj.Extensibility.InstanceScope,System.Boolean,System.Type[])">
            <summary>
            Register specified type to the container as custom service with provided scope.
            </summary>
            <param name="builder">container builder</param>
            <param name="type">service type</param>
            <param name="asType">register as</param>
            <param name="scope">resolution scope</param>
            <param name="isGeneric">is generic type</param>
        </member>
        <member name="M:Revenj.Extensibility.ObjectFactoryHelper.RegisterType``1(Revenj.Extensibility.IObjectFactoryBuilder,Revenj.Extensibility.InstanceScope)">
            <summary>
            Register specified type to the container. Default scope is transient
            </summary>
            <typeparam name="TService">service type</typeparam>
            <param name="builder">container builder</param>
            <param name="scope">resolution scope</param>
        </member>
        <member name="M:Revenj.Extensibility.ObjectFactoryHelper.RegisterType``2(Revenj.Extensibility.IObjectFactoryBuilder,Revenj.Extensibility.InstanceScope)">
            <summary>
            Register specified type to the container as custom service. Default scope is transient
            </summary>
            <typeparam name="TService">service implementation</typeparam>
            <typeparam name="TAs">service type</typeparam>
            <param name="builder">container builder</param>
            <param name="scope">resolution scope</param>
        </member>
        <member name="M:Revenj.Extensibility.ObjectFactoryHelper.RegisterType``3(Revenj.Extensibility.IObjectFactoryBuilder,Revenj.Extensibility.InstanceScope)">
            <summary>
            Register specified type to the container as custom services. Default scope is transient
            </summary>
            <typeparam name="TService">service implementation</typeparam>
            <typeparam name="TAs1">service type</typeparam>
            <typeparam name="TAs2">additional service type</typeparam>
            <param name="builder">container builder</param>
            <param name="scope">resolution scope</param>
        </member>
        <member name="M:Revenj.Extensibility.ObjectFactoryHelper.RegisterGeneric(Revenj.Extensibility.IObjectFactory,System.Type,Revenj.Extensibility.InstanceScope,System.Type[])">
            <summary>
            Register generic type to the container as custom service with provided scope.
            </summary>
            <param name="factory">container scope</param>
            <param name="type">service type</param>
            <param name="asType">register as</param>
            <param name="scope">resolution scope</param>
        </member>
        <member name="M:Revenj.Extensibility.ObjectFactoryHelper.RegisterTypes(Revenj.Extensibility.IObjectFactory,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Register multiple types to the container as singletons.
            </summary>
            <param name="factory">current scope</param>
            <param name="types">services</param>
        </member>
        <member name="M:Revenj.Extensibility.ObjectFactoryHelper.RegisterTypes(Revenj.Extensibility.IObjectFactory,System.Collections.Generic.IEnumerable{System.Type},Revenj.Extensibility.InstanceScope)">
            <summary>
            Register multiple types to the container with specified scope.
            </summary>
            <param name="factory">current scope</param>
            <param name="types">services</param>
            <param name="scope">resolution scope</param>
        </member>
        <member name="M:Revenj.Extensibility.ObjectFactoryHelper.RegisterInstance``1(Revenj.Extensibility.IObjectFactory,``0)">
            <summary>
            Register instance to the container scope.
            Registered instance will be available in nested scopes too.
            </summary>
            <typeparam name="T">service</typeparam>
            <param name="factory">current scope</param>
            <param name="instance">provided instance</param>
        </member>
        <member name="M:Revenj.Extensibility.ObjectFactoryHelper.RegisterSingleton``1(Revenj.Extensibility.IObjectFactoryBuilder,``0)">
            <summary>
            Register instance to the container builder.
            Registered instance will be available in nested scopes too.
            </summary>
            <typeparam name="T">service</typeparam>
            <param name="builder">container builder</param>
            <param name="instance">provided instance</param>
        </member>
        <member name="M:Revenj.Extensibility.ObjectFactoryHelper.RegisterInterfaces``1(Revenj.Extensibility.IObjectFactory,``0)">
            <summary>
            Register all interfaces and specified service for provided instance to the container.
            Services will be available in nested scopes too.
            </summary>
            <typeparam name="T">service type</typeparam>
            <param name="factory">current scope</param>
            <param name="instance">provided instance</param>
        </member>
        <member name="M:Revenj.Extensibility.ObjectFactoryHelper.RegisterFunc``1(Revenj.Extensibility.IObjectFactory,System.Func{Revenj.Extensibility.IObjectFactory,``0})">
            <summary>
            Register factory to the container with transient scope. 
            Service will be resolved from the factory using contexed scope.
            </summary>
            <typeparam name="T">service type</typeparam>
            <param name="factory">current scope</param>
            <param name="func">factory to service</param>
        </member>
        <member name="M:Revenj.Extensibility.ObjectFactoryHelper.RegisterFunc``1(Revenj.Extensibility.IObjectFactory,System.Func{Revenj.Extensibility.IObjectFactory,``0},Revenj.Extensibility.InstanceScope)">
            <summary>
            Register factory to the container with specified scope.
            Service will be resolved from the factory using context scope.
            </summary>
            <typeparam name="T">service type</typeparam>
            <param name="factory">current scope</param>
            <param name="func">factory to service</param>
            <param name="scope">factory scope</param>
        </member>
        <member name="M:Revenj.Extensibility.ObjectFactoryHelper.RegisterFunc``1(Revenj.Extensibility.IObjectFactoryBuilder,System.Func{Revenj.Extensibility.IObjectFactory,``0},Revenj.Extensibility.InstanceScope)">
            <summary>
            Register factory to the container builder with specified scope. Default scope is Transient.
            Service will be resolved from the factory using context scope.
            </summary>
            <typeparam name="T">service type</typeparam>
            <param name="builder">container builder</param>
            <param name="func">factory to service</param>
            <param name="scope">factory scope</param>
        </member>
        <member name="M:Revenj.Extensibility.ObjectFactoryHelper.RegisterFunc``3(Revenj.Extensibility.IObjectFactoryBuilder,System.Func{Revenj.Extensibility.IObjectFactory,``0},Revenj.Extensibility.InstanceScope)">
            <summary>
            Register factory to the container builder with specified scope. Default scope is Transient.
            Service will be resolved from the factory using context scope.
            </summary>
            <typeparam name="T">implementation type</typeparam>
            <typeparam name="TAs1">as service</typeparam>
            <typeparam name="TAs2">as alternative service</typeparam>
            <param name="builder">container builder</param>
            <param name="func">factory to service</param>
            <param name="scope">factory scope</param>
        </member>
        <member name="T:Revenj.Extensibility.IObjectFactoryBuilder">
            <summary>
            Builder for registering services to the container.
            Services can be instances, types or factories
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.IObjectFactoryBuilder.Instances">
            <summary>
            Registered instances.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.IObjectFactoryBuilder.Types">
            <summary>
            Registered types.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.IObjectFactoryBuilder.Funcs">
            <summary>
            Registered factories.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.IObjectFactoryBuilder.Add(Revenj.Extensibility.IFactoryBuilderInstance)">
            <summary>
            Register new instance.
            </summary>
            <param name="item">instance builder</param>
        </member>
        <member name="M:Revenj.Extensibility.IObjectFactoryBuilder.Add(Revenj.Extensibility.IFactoryBuilderType)">
            <summary>
            Register new type.
            </summary>
            <param name="item">type builder</param>
        </member>
        <member name="M:Revenj.Extensibility.IObjectFactoryBuilder.Add(Revenj.Extensibility.IFactoryBuilderFunc)">
            <summary>
            Register new factory.
            </summary>
            <param name="item">factory builder</param>
        </member>
        <member name="T:Revenj.Extensibility.IFactoryBuilderInstance">
            <summary>
            Instance builder for container registration
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.IFactoryBuilderInstance.Instance">
            <summary>
            Provided instance.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.IFactoryBuilderInstance.AsType">
            <summary>
            Registered as service.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.InstanceScope">
            <summary>
            Service instance scope.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.InstanceScope.Singleton">
            <summary>
            Same service will be resolved on subsequent request inside this
            and nested scopes.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.InstanceScope.Transient">
            <summary>
            New service will be resolved each time.
            </summary>
        </member>
        <member name="F:Revenj.Extensibility.InstanceScope.Context">
            <summary>
            Same service will be resolved on subsequent request inside this scope.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.IFactoryBuilderType">
            <summary>
            Type builder for container registration
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.IFactoryBuilderType.Type">
            <summary>
            Registered type.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.IFactoryBuilderType.Scope">
            <summary>
            Specified scope.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.IFactoryBuilderType.IsGeneric">
            <summary>
            Is registered as generic type.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.IFactoryBuilderType.AsType">
            <summary>
            Registered as service.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.IFactoryBuilderFunc">
            <summary>
            Factory builder for container registration
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.IFactoryBuilderFunc.Func">
            <summary>
            Registered factory.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.IFactoryBuilderFunc.Scope">
            <summary>
            Specified scope.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.IFactoryBuilderFunc.AsType">
            <summary>
            Registered as service.
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.IPluginRepository`1">
            <summary>
            Helper interface for plugins.
            Plugins can be resolved by full or short name
            </summary>
            <typeparam name="TTarget">plugin type</typeparam>
        </member>
        <member name="M:Revenj.Extensibility.IPluginRepository`1.Find(System.String)">
            <summary>
            Find plugin by it's name.
            </summary>
            <param name="name">plugin name</param>
            <returns>found plugin</returns>
        </member>
        <member name="T:Revenj.Extensibility.ISystemState">
            <summary>
            Services which depend on boot state should use this to check system state.
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.ISystemState.IsBooting">
            <summary>
            Is system still booting
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.ISystemState.IsReady">
            <summary>
            Is system ready for use
            </summary>
        </member>
        <member name="E:Revenj.Extensibility.ISystemState.Ready">
            <summary>
            Event will fire when system is ready for use
            </summary>
        </member>
        <member name="E:Revenj.Extensibility.ISystemState.Change">
            <summary>
            Register for events
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.ISystemState.Notify(Revenj.Extensibility.SystemEvent)">
            <summary>
            Notify system about an system event
            </summary>
            <param name="value">event data</param>
        </member>
        <member name="T:Revenj.Extensibility.SystemEvent">
            <summary>
            Notification information about system event, such as migration
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.SystemEvent.#ctor(System.String,System.String)">
            <summary>
            System event info
            </summary>
            <param name="id">event id</param>
            <param name="detail">details</param>
        </member>
        <member name="P:Revenj.Extensibility.SystemEvent.ID">
            <summary>
            Event ID (eg. migration)
            </summary>
        </member>
        <member name="P:Revenj.Extensibility.SystemEvent.Detail">
            <summary>
            Event Details (eg. new)
            </summary>
        </member>
        <member name="T:Revenj.Extensibility.ITypeResolver">
            <summary>
            Type resolver service.
            Domain types and other system types can be resolved from this service.
            This enables access to dynamic types which are not available at compile time.
            </summary>
        </member>
        <member name="M:Revenj.Extensibility.ITypeResolver.Resolve(System.String)">
            <summary>
            Try to find type by its name.
            If type is not found null will be returned.
            </summary>
            <param name="name">type name</param>
            <returns>found type</returns>
        </member>
        <member name="T:Revenj.Utility.Exceptions">
            <summary>
            Utility for exception reporting.
            Check if application debug mode is enabled.
            Unroll exceptions in better description.
            </summary>
        </member>
        <member name="P:Revenj.Utility.Exceptions.DebugMode">
            <summary>
            Check if application is running in debug mode.
            Set in application config (configuration/appSettings) as &lt;add key="ApplicationMode" value="Debug"/&gt;
            </summary>
        </member>
        <member name="M:Revenj.Utility.Exceptions.GetMessages(System.Exception)">
            <summary>
            Get messages for this exception.
            Unroll exception stack to single message. 
            Aggregate exceptions will be unrolled too.
            Only exception message is used.
            </summary>
            <param name="exception">top exception</param>
            <returns>error message</returns>
        </member>
        <member name="M:Revenj.Utility.Exceptions.GetDetailedExplanation(System.Exception)">
            <summary>
            Get detailed messages for this exception.
            Unroll exception stack to single message. 
            Aggregate exceptions will be unrolled too.
            Whole stack trace will be used for each exception.
            </summary>
            <param name="exception">top exception</param>
            <returns>error message</returns>
        </member>
        <member name="T:Revenj.Security.IAuthentication`1">
            <summary>
            Authentication service.
            For checking if user is authenticated within the system.
            </summary>
        </member>
        <member name="M:Revenj.Security.IAuthentication`1.IsAuthenticated(System.String,`0)">
            <summary>
            Check if user with provided password is authenticated within the system.
            </summary>
            <param name="user">username</param>
            <param name="key">key</param>
            <returns>is user allowed into the system</returns>
        </member>
        <member name="T:Revenj.Security.IPermissionManager">
            <summary>
            Permission manager service for setting up permission rules
            and checking access to data.
            </summary>
        </member>
        <member name="M:Revenj.Security.IPermissionManager.CanAccess(System.String,System.Security.Principal.IPrincipal)">
            <summary>
            Check if user can access provided identifier.
            Identifier can be type name, service name or something similar.
            Rules for access can be defined for smaller parts of identifier.
            </summary>
            <param name="identifier">identifier is sliced by . and matched against the rules</param>
            <param name="user">principal to check</param>
            <returns>is user allowed to access</returns>
        </member>
        <member name="M:Revenj.Security.IPermissionManager.ApplyFilters``1(System.Security.Principal.IPrincipal,System.Linq.IQueryable{``0})">
            <summary>
            Filter data based on provided user principal.
            This will apply various permissions registered for this user and for data of type T
            If interface is provided, permissions must be defined explicitly for that interface.
            Filter will be applied on Queryable tree, which can be evaluated at a later time.
            </summary>
            <typeparam name="T">data type</typeparam>
            <param name="user">user principal</param>
            <param name="data">data to filter</param>
            <returns>filtered data based on permission rules</returns>
        </member>
        <member name="M:Revenj.Security.IPermissionManager.ApplyFilters``1(System.Security.Principal.IPrincipal,``0[])">
            <summary>
            Filter data based on provided user principal.
            This will apply various permissions registered for this user and for data of type T
            If interface is provided, permissions must be defined explicitly for that interface.
            Filter will be applied immediately.
            </summary>
            <typeparam name="T">data type</typeparam>
            <param name="user">user principal</param>
            <param name="data">data to filter</param>
            <returns>filtered data based on permission rules</returns>
        </member>
        <member name="M:Revenj.Security.IPermissionManager.RegisterFilter``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Boolean)">
            <summary>
            Register filter predicate for data.
            Apply this filter for specified roles, or when role is missing.
            Only exact match will be filtered, so if data can be queried through some 
            interface, explicit registration must be done.
            </summary>
            <typeparam name="T">data type</typeparam>
            <param name="filter">predicate for filtering</param>
            <param name="role">role for which the principal will be tested</param>
            <param name="inverse">should filter apply for this role, or when this role is missing</param>
            <returns>disposable for unregistering filter</returns>
        </member>
        <member name="T:Revenj.Security.PermissionManagerHelper">
            <summary>
            Helper for permission manager service
            </summary>
        </member>
        <member name="M:Revenj.Security.PermissionManagerHelper.CanAccess``1(Revenj.Security.IPermissionManager)">
            <summary>
            Check if current principal bound to thread can access some resource.
            Resource identity will be provided from type full name.
            </summary>
            <typeparam name="T">object type</typeparam>
            <param name="manager">permission service</param>
            <returns>is user allowed to access requested resource</returns>
        </member>
        <member name="M:Revenj.Security.PermissionManagerHelper.CanAccess(Revenj.Security.IPermissionManager,System.Type)">
            <summary>
            Check if current principal bound to thread can access some resource.
            Resource identity will be provided from target type argument full name.
            </summary>
            <param name="manager">permission service</param>
            <param name="target">type argument</param>
            <returns>is user allowed to access requested resource</returns>
        </member>
        <member name="M:Revenj.Security.PermissionManagerHelper.ApplyFilters``1(Revenj.Security.IPermissionManager,``0[])">
            <summary>
            Filter data based on user principal bound to current Thread.
            This will apply various permissions registered for this user and for data of type T
            If interface is provided, permissions must be defined explicitly for that interface.
            </summary>
            <typeparam name="T">object type</typeparam>
            <param name="manager">permission service</param>
            <param name="data">data to filter</param>
            <returns>filtered data based on permission rules</returns>
        </member>
        <member name="M:Revenj.Security.PermissionManagerHelper.RegisterForRole``1(Revenj.Security.IPermissionManager,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String)">
            <summary>
            Specify filter which will be applied when user principal is in specified role.
            Users which are not in specified role will not have this filter applied to them.
            </summary>
            <typeparam name="T">object type</typeparam>
            <param name="manager">permission service</param>
            <param name="filter">filtering expression</param>
            <param name="role">for which role filter applies</param>
            <returns>un-register instance. If called registration will be removed</returns>
        </member>
        <member name="M:Revenj.Security.PermissionManagerHelper.RegisterWhenNotInRole``1(Revenj.Security.IPermissionManager,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String)">
            <summary>
            Specify filter which will be applied when user principal is not in specified role.
            Users which are not in specified role will not have this filter applied to them.
            </summary>
            <typeparam name="T">object type</typeparam>
            <param name="manager">permission service</param>
            <param name="filter">filtering expression</param>
            <param name="role">for which role filter applies</param>
            <returns>un-register instance. If called registration will be removed</returns>
        </member>
        <member name="T:Revenj.Security.IPrincipalFactory">
            <summary>
            Factory for creating principals for users.
            </summary>
        </member>
        <member name="M:Revenj.Security.IPrincipalFactory.Create(System.Security.Principal.IIdentity)">
            <summary>
            Create principal based on provided user information.
            Principal contains information about what the user is allowed to do.
            </summary>
            <param name="user">user identity</param>
            <returns>principal for user</returns>
        </member>
        <member name="T:Revenj.Security.Roles">
            <summary>
            Static name for common roles.
            </summary>
        </member>
        <member name="F:Revenj.Security.Roles.Administrator">
            <summary>
            Administrator role
            </summary>
        </member>
        <member name="T:Revenj.Serialization.ISerialization`1">
            <summary>
            Generic serialization interface. 
            Use TFormat to specify serialization type (example: ISerialization&lt;string&gt; for JSON serialization).
            During deserialization provide IServiceProvider to context information when required
            </summary>
            <typeparam name="TFormat">define serialization type</typeparam>
        </member>
        <member name="M:Revenj.Serialization.ISerialization`1.Serialize``1(``0)">
            <summary>
            Serialize object to appropriate format (XElement, StreamReader, MemoryStream...)
            </summary>
            <typeparam name="T">argument type. It will be inferred</typeparam>
            <param name="value">argument for serialization</param>
            <returns>serialized representation of provided argument</returns>
        </member>
        <member name="M:Revenj.Serialization.ISerialization`1.Deserialize``1(`0,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialize object from provided format. 
            Provide context to initialize object and references after deserialization
            </summary>
            <typeparam name="T">Specify object type</typeparam>
            <param name="data">serialized object in provided format</param>
            <param name="context">context info for initialization after deserialization</param>
            <returns>deserialized object</returns>
        </member>
        <member name="T:Revenj.Serialization.SerializationHelper">
            <summary>
            Helper class for deserialization
            </summary>
        </member>
        <member name="M:Revenj.Serialization.SerializationHelper.Deserialize``2(Revenj.Serialization.ISerialization{``0},``0)">
            <summary>
            Deserialize object without providing context information.
            .NET objects or value objects don't require context so they can be deserialized
            without IServiceProvider in context.
            </summary>
            <typeparam name="TFormat">serialization format</typeparam>
            <typeparam name="T">object type</typeparam>
            <param name="serialization">serialization service</param>
            <param name="data">serialized object in specified format</param>
            <returns>deserialized object</returns>
        </member>
        <member name="M:Revenj.Serialization.SerializationHelper.Deserialize``2(Revenj.Serialization.ISerialization{``0},``0,System.Object)">
            <summary>
            Deserialize object using provided context information.
            Context should usually be IServiceLocator, but in special cases can be something else.
            </summary>
            <typeparam name="TFormat">serialization format</typeparam>
            <typeparam name="T">object type</typeparam>
            <param name="serialization">serialization service</param>
            <param name="data">serialized object in specified format</param>
            <param name="context">context information which will be used during deserialization</param>
            <returns>deserialized object</returns>
        </member>
        <member name="T:Revenj.Serialization.IWireSerialization">
            <summary>
            Serialization interface for on and from the wire communication. 
            Specify accept/contentType for appropriate serialization.
            During deserialization provide IServiceLocator to context information when required
            </summary>
        </member>
        <member name="M:Revenj.Serialization.IWireSerialization.Serialize(System.Object,System.String,System.IO.Stream)">
            <summary>
            Serialize object to appropriate format XML, JSON, Protocol buffer within the stream
            </summary>
            <param name="value">argument for serialization</param>
            <param name="accept">allowed formats</param>
            <param name="destination">serialization destination</param>
            <returns>serialization format</returns>
        </member>
        <member name="M:Revenj.Serialization.IWireSerialization.Deserialize(System.IO.Stream,System.Type,System.String,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialize object from provided format. 
            Provide context to initialize object and references after deserialization
            </summary>
            <param name="source">raw data in specified format</param>
            <param name="target">object type</param>
            <param name="contentType">specified serialization format</param>
            <param name="context">context info for initialization after deserialization</param>
            <returns>deserialized object</returns>
        </member>
        <member name="M:Revenj.Serialization.IWireSerialization.GetSerializer``1">
            <summary>
            Get serializer for specified format (eg. XElement for XML, string for JSON, etc...)
            </summary>
            <typeparam name="TFormat">serializer format</typeparam>
            <returns>serializer instance</returns>
        </member>
        <member name="T:Revenj.Serialization.WireSerializationHelper">
            <summary>
            Helper class for deserialization
            </summary>
        </member>
        <member name="M:Revenj.Serialization.WireSerializationHelper.Deserialize``1(Revenj.Serialization.IWireSerialization,System.IO.Stream,System.String)">
            <summary>
            Deserialize typesafe object without providing context information.
            .NET objects or value objects don't require context so they can be deserialized
            without IServiceLocator in context.
            </summary>
            <typeparam name="T">object type</typeparam>
            <param name="serialization">serialization service</param>
            <param name="source">serialized object in specified format</param>
            <param name="contentType">MIME type specifying the format</param>
            <returns>deserialized object</returns>
        </member>
    </members>
</doc>
